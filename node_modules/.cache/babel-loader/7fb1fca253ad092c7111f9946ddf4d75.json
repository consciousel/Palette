{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionWatcher = void 0;\n\nconst asyncTimer_1 = require(\"./asyncTimer\");\n\nconst errors = __importStar(require(\"./errors\"));\n\nconst logger_1 = require(\"./logger\");\n/**\n * TransactionWatcher allows one to continuously watch (monitor), by means of polling, the status of a given transaction.\n */\n\n\nclass TransactionWatcher {\n  /**\n   *\n   * @param hash The hash of the transaction to watch\n   * @param provider The provider to query the status from\n   * @param pollingInterval The polling interval, in milliseconds\n   * @param timeout The timeout, in milliseconds\n   */\n  constructor(hash, provider) {\n    let pollingInterval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TransactionWatcher.DefaultPollingInterval;\n    let timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TransactionWatcher.DefaultTimeout;\n    this.hash = hash;\n    this.provider = provider;\n    this.pollingInterval = pollingInterval;\n    this.timeout = timeout;\n  }\n  /**\n   * Waits until the transaction reaches the \"pending\" status.\n   */\n\n\n  awaitPending(onStatusReceived) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.awaitStatus(status => status.isPending(), onStatusReceived || TransactionWatcher.NoopOnStatusReceived);\n    });\n  }\n  /**\n    * Waits until the transaction reaches the \"executed\" status.\n    */\n\n\n  awaitExecuted(onStatusReceived) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.awaitStatus(status => status.isExecuted(), onStatusReceived || TransactionWatcher.NoopOnStatusReceived);\n    });\n  }\n  /**\n   * Waits until the predicate over the transaction status evaluates to \"true\".\n   * @param isAwaitedStatus A predicate over the status\n   */\n\n\n  awaitStatus(isAwaitedStatus, onStatusReceived) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let doFetch = () => __awaiter(this, void 0, void 0, function* () {\n        return yield this.provider.getTransactionStatus(this.hash);\n      });\n\n      let errorProvider = () => new errors.ErrExpectedTransactionStatusNotReached();\n\n      return this.awaitConditionally(isAwaitedStatus, doFetch, onStatusReceived, errorProvider);\n    });\n  }\n\n  awaitNotarized() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let isNotarized = data => !data.hyperblockHash.isEmpty();\n\n      let doFetch = () => __awaiter(this, void 0, void 0, function* () {\n        return yield this.provider.getTransaction(this.hash);\n      });\n\n      let errorProvider = () => new errors.ErrTransactionWatcherTimeout();\n\n      return this.awaitConditionally(isNotarized, doFetch, _ => {}, errorProvider);\n    });\n  }\n\n  awaitConditionally(isSatisfied, doFetch, onFetched, createError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let periodicTimer = new asyncTimer_1.AsyncTimer(\"watcher:periodic\");\n      let timeoutTimer = new asyncTimer_1.AsyncTimer(\"watcher:timeout\");\n      let stop = false;\n      let fetchedData = undefined;\n\n      let _ = timeoutTimer.start(this.timeout).finally(() => {\n        timeoutTimer.stop();\n        stop = true;\n      });\n\n      while (!stop) {\n        try {\n          fetchedData = yield doFetch();\n\n          if (onFetched) {\n            onFetched(fetchedData);\n          }\n\n          if (isSatisfied(fetchedData) || stop) {\n            break;\n          }\n        } catch (error) {\n          if (!(error instanceof errors.Err)) {\n            throw error;\n          }\n\n          logger_1.Logger.info(\"cannot (yet) fetch data\");\n        }\n\n        yield periodicTimer.start(this.pollingInterval);\n      }\n\n      if (!timeoutTimer.isStopped()) {\n        timeoutTimer.stop();\n      }\n\n      let notSatisfied = !fetchedData || !isSatisfied(fetchedData);\n\n      if (notSatisfied) {\n        let error = createError();\n        throw error;\n      }\n    });\n  }\n\n}\n\nexports.TransactionWatcher = TransactionWatcher;\nTransactionWatcher.DefaultPollingInterval = 6000;\nTransactionWatcher.DefaultTimeout = TransactionWatcher.DefaultPollingInterval * 15;\n\nTransactionWatcher.NoopOnStatusReceived = _ => {};","map":{"version":3,"mappings":"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","names":["TransactionWatcher","constructor","hash","provider","pollingInterval","DefaultPollingInterval","timeout","DefaultTimeout","awaitPending","onStatusReceived","awaitStatus","status","isPending","NoopOnStatusReceived","awaitExecuted","isExecuted","isAwaitedStatus","doFetch","__awaiter","getTransactionStatus","errorProvider","errors","ErrExpectedTransactionStatusNotReached","awaitConditionally","awaitNotarized","isNotarized","data","hyperblockHash","isEmpty","getTransaction","ErrTransactionWatcherTimeout","_","isSatisfied","onFetched","createError","periodicTimer","asyncTimer_1","timeoutTimer","stop","fetchedData","undefined","start","finally","error","Err","logger_1","info","isStopped","notSatisfied","exports"],"sourceRoot":"","sources":["../src/transactionWatcher.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}