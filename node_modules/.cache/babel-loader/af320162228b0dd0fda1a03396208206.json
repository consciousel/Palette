{"ast":null,"code":"'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\n\nvar helpers = require('./helpers');\n\nvar ValidatorResult = helpers.ValidatorResult;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\n\nvar Validator = function Validator() {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = []; // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n}; // Allow formats to be registered globally.\n\n\nValidator.prototype.customFormats = {}; // Hint at the presence of a property\n\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\n\nValidator.prototype.addSchema = function addSchema(schema, uri) {\n  if (!schema) {\n    return null;\n  }\n\n  var ourUri = uri || schema.id;\n  this.addSubSchema(ourUri, schema);\n\n  if (ourUri) {\n    this.schemas[ourUri] = schema;\n  }\n\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchema = function addSubSchema(baseuri, schema) {\n  if (!schema || typeof schema != 'object') return; // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined\n\n  if (schema.$ref) {\n    var resolvedUri = urilib.resolve(baseuri, schema.$ref); // Only mark unknown schemas as unresolved\n\n    if (this.schemas[resolvedUri] === undefined) {\n      this.schemas[resolvedUri] = null;\n      this.unresolvedRefs.push(resolvedUri);\n    }\n\n    return;\n  }\n\n  var ourUri = schema.id && urilib.resolve(baseuri, schema.id);\n  var ourBase = ourUri || baseuri;\n\n  if (ourUri) {\n    if (this.schemas[ourUri]) {\n      if (!helpers.deepCompareStrict(this.schemas[ourUri], schema)) {\n        throw new Error('Schema <' + schema + '> already exists with different definition');\n      }\n\n      return this.schemas[ourUri];\n    }\n\n    this.schemas[ourUri] = schema;\n    var documentUri = ourUri.replace(/^([^#]*)#$/, '$1');\n    this.schemas[documentUri] = schema;\n  }\n\n  this.addSubSchemaArray(ourBase, schema.items instanceof Array ? schema.items : [schema.items]);\n  this.addSubSchemaArray(ourBase, schema.extends instanceof Array ? schema.extends : [schema.extends]);\n  this.addSubSchema(ourBase, schema.additionalItems);\n  this.addSubSchemaObject(ourBase, schema.properties);\n  this.addSubSchema(ourBase, schema.additionalProperties);\n  this.addSubSchemaObject(ourBase, schema.definitions);\n  this.addSubSchemaObject(ourBase, schema.patternProperties);\n  this.addSubSchemaObject(ourBase, schema.dependencies);\n  this.addSubSchemaArray(ourBase, schema.disallow);\n  this.addSubSchemaArray(ourBase, schema.allOf);\n  this.addSubSchemaArray(ourBase, schema.anyOf);\n  this.addSubSchemaArray(ourBase, schema.oneOf);\n  this.addSubSchema(ourBase, schema.not);\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if (!(schemas instanceof Array)) return;\n\n  for (var i = 0; i < schemas.length; i++) {\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if (!schemas || typeof schemas != 'object') return;\n\n  for (var p in schemas) {\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\n\n\nValidator.prototype.setSchemas = function setSchemas(schemas) {\n  this.schemas = schemas;\n};\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\n\n\nValidator.prototype.getSchema = function getSchema(urn) {\n  return this.schemas[urn];\n};\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\n\n\nValidator.prototype.validate = function validate(instance, schema, options, ctx) {\n  if (!options) {\n    options = {};\n  }\n\n  var propertyName = options.propertyName || 'instance'; // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n\n  var base = urilib.resolve(options.base || '/', schema.id || '');\n\n  if (!ctx) {\n    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));\n\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n  }\n\n  if (schema) {\n    var result = this.validateSchema(instance, schema, options, ctx);\n\n    if (!result) {\n      throw new Error('Result undefined');\n    }\n\n    return result;\n  }\n\n  throw new SchemaError('no schema specified', schema);\n};\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\n\n\nfunction shouldResolve(schema) {\n  var ref = typeof schema === 'string' ? schema : schema.$ref;\n  if (typeof ref == 'string') return ref;\n  return false;\n}\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\n\n\nValidator.prototype.validateSchema = function validateSchema(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!schema) {\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (schema['extends'] instanceof Array) {\n      var schemaobj = {\n        schema: schema,\n        ctx: ctx\n      };\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  var switchSchema;\n\n  if (switchSchema = shouldResolve(schema)) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || []; // Validate each schema attribute against the instance\n\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n\n  return result;\n};\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\n\n\nValidator.prototype.schemaTraverser = function schemaTraverser(schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n};\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\n\n\nValidator.prototype.superResolve = function superResolve(schema, ctx) {\n  var ref;\n\n  if (ref = shouldResolve(schema)) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n\n  return schema;\n};\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\n\n\nValidator.prototype.resolve = function resolve(schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema); // First see if the schema exists under the provided URI\n\n  if (ctx.schemas[switchSchema]) {\n    return {\n      subschema: ctx.schemas[switchSchema],\n      switchSchema: switchSchema\n    };\n  } // Else try walking the property pointer\n\n\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n\n  if (subschema === undefined) {\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n\n  return {\n    subschema: subschema,\n    switchSchema: switchSchema\n  };\n};\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\n\n\nValidator.prototype.testType = function validateType(instance, schema, options, ctx, type) {\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  } // Undefined or properties not on the list are acceptable, same as not being defined\n\n\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\n\ntypes.string = function testString(instance) {\n  return typeof instance == 'string';\n};\n\ntypes.number = function testNumber(instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\n\ntypes.integer = function testInteger(instance) {\n  return typeof instance == 'number' && instance % 1 === 0;\n};\n\ntypes.boolean = function testBoolean(instance) {\n  return typeof instance == 'boolean';\n};\n\ntypes.array = function testArray(instance) {\n  return Array.isArray(instance);\n};\n\ntypes['null'] = function testNull(instance) {\n  return instance === null;\n};\n\ntypes.date = function testDate(instance) {\n  return instance instanceof Date;\n};\n\ntypes.any = function testAny(instance) {\n  return true;\n};\n\ntypes.object = function testObject(instance) {\n  // TODO: fix this - see #15\n  return instance && typeof instance === 'object' && !(instance instanceof Array) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;","map":{"version":3,"sources":["C:/Users/masho/OneDrive/Desktop/Blockchain/Biconomy/Projects/NFT_minter/node_modules/jsonschema/lib/validator.js"],"names":["urilib","require","attribute","helpers","ValidatorResult","SchemaError","SchemaContext","Validator","customFormats","Object","create","prototype","schemas","unresolvedRefs","types","attributes","validators","addSchema","schema","uri","ourUri","id","addSubSchema","baseuri","$ref","resolvedUri","resolve","undefined","push","ourBase","deepCompareStrict","Error","documentUri","replace","addSubSchemaArray","items","Array","extends","additionalItems","addSubSchemaObject","properties","additionalProperties","definitions","patternProperties","dependencies","disallow","allOf","anyOf","oneOf","not","i","length","p","setSchemas","getSchema","urn","validate","instance","options","ctx","propertyName","base","result","validateSchema","shouldResolve","ref","schemaobj","forEach","schemaTraverser","bind","deepMerge","superResolve","switchSchema","resolved","subctx","subschema","propertyPath","skipAttributes","key","ignoreProperties","indexOf","validatorErr","validator","call","allowUnknownAttributes","importErrors","rewrite","value","s","parsed","parse","fragment","hash","document","substr","objectGetPath","testType","validateType","type","res","errors","string","testString","number","testNumber","isFinite","integer","testInteger","boolean","testBoolean","array","testArray","isArray","testNull","date","testDate","Date","any","testAny","object","testObject","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\nvar helpers = require('./helpers');\nvar ValidatorResult = helpers.ValidatorResult;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\nvar Validator = function Validator () {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = [];\n\n  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n};\n\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\nValidator.prototype.addSchema = function addSchema (schema, uri) {\n  if (!schema) {\n    return null;\n  }\n  var ourUri = uri || schema.id;\n  this.addSubSchema(ourUri, schema);\n  if (ourUri) {\n    this.schemas[ourUri] = schema;\n  }\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchema = function addSubSchema(baseuri, schema) {\n  if(!schema || typeof schema!='object') return;\n  // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined\n  if(schema.$ref){\n    var resolvedUri = urilib.resolve(baseuri, schema.$ref);\n    // Only mark unknown schemas as unresolved\n    if (this.schemas[resolvedUri] === undefined) {\n      this.schemas[resolvedUri] = null;\n      this.unresolvedRefs.push(resolvedUri);\n    }\n    return;\n  }\n  var ourUri = schema.id && urilib.resolve(baseuri, schema.id);\n  var ourBase = ourUri || baseuri;\n  if (ourUri) {\n    if(this.schemas[ourUri]){\n      if(!helpers.deepCompareStrict(this.schemas[ourUri], schema)){\n        throw new Error('Schema <'+schema+'> already exists with different definition');\n      }\n      return this.schemas[ourUri];\n    }\n    this.schemas[ourUri] = schema;\n    var documentUri = ourUri.replace(/^([^#]*)#$/, '$1');\n    this.schemas[documentUri] = schema;\n  }\n  this.addSubSchemaArray(ourBase, ((schema.items instanceof Array)?schema.items:[schema.items]));\n  this.addSubSchemaArray(ourBase, ((schema.extends instanceof Array)?schema.extends:[schema.extends]));\n  this.addSubSchema(ourBase, schema.additionalItems);\n  this.addSubSchemaObject(ourBase, schema.properties);\n  this.addSubSchema(ourBase, schema.additionalProperties);\n  this.addSubSchemaObject(ourBase, schema.definitions);\n  this.addSubSchemaObject(ourBase, schema.patternProperties);\n  this.addSubSchemaObject(ourBase, schema.dependencies);\n  this.addSubSchemaArray(ourBase, schema.disallow);\n  this.addSubSchemaArray(ourBase, schema.allOf);\n  this.addSubSchemaArray(ourBase, schema.anyOf);\n  this.addSubSchemaArray(ourBase, schema.oneOf);\n  this.addSubSchema(ourBase, schema.not);\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if(!(schemas instanceof Array)) return;\n  for(var i=0; i<schemas.length; i++){\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if(!schemas || typeof schemas!='object') return;\n  for(var p in schemas){\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n\n\n\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\nValidator.prototype.setSchemas = function setSchemas (schemas) {\n  this.schemas = schemas;\n};\n\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\nValidator.prototype.getSchema = function getSchema (urn) {\n  return this.schemas[urn];\n};\n\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\nValidator.prototype.validate = function validate (instance, schema, options, ctx) {\n  if (!options) {\n    options = {};\n  }\n  var propertyName = options.propertyName || 'instance';\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n  var base = urilib.resolve(options.base||'/', schema.id||'');\n  if(!ctx){\n    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n  }\n  if (schema) {\n    var result = this.validateSchema(instance, schema, options, ctx);\n    if (!result) {\n      throw new Error('Result undefined');\n    }\n    return result;\n  }\n  throw new SchemaError('no schema specified', schema);\n};\n\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\nfunction shouldResolve(schema) {\n  var ref = (typeof schema === 'string') ? schema : schema.$ref;\n  if (typeof ref=='string') return ref;\n  return false;\n}\n\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\nValidator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema) {\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (schema['extends'] instanceof Array) {\n      var schemaobj = {schema: schema, ctx: ctx};\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  var switchSchema;\n  if (switchSchema = shouldResolve(schema)) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || [];\n  // Validate each schema attribute against the instance\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n  return result;\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n}\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.superResolve = function superResolve (schema, ctx) {\n  var ref;\n  if(ref = shouldResolve(schema)) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n  return schema;\n}\n\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\nValidator.prototype.resolve = function resolve (schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema);\n  // First see if the schema exists under the provided URI\n  if (ctx.schemas[switchSchema]) {\n    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};\n  }\n  // Else try walking the property pointer\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n  if(subschema===undefined){\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n  return {subschema: subschema, switchSchema: switchSchema};\n};\n\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\nValidator.prototype.testType = function validateType (instance, schema, options, ctx, type) {\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  }\n  // Undefined or properties not on the list are acceptable, same as not being defined\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\ntypes.string = function testString (instance) {\n  return typeof instance == 'string';\n};\ntypes.number = function testNumber (instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\ntypes.integer = function testInteger (instance) {\n  return (typeof instance == 'number') && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean (instance) {\n  return typeof instance == 'boolean';\n};\ntypes.array = function testArray (instance) {\n  return Array.isArray(instance);\n};\ntypes['null'] = function testNull (instance) {\n  return instance === null;\n};\ntypes.date = function testDate (instance) {\n  return instance instanceof Date;\n};\ntypes.any = function testAny (instance) {\n  return true;\n};\ntypes.object = function testObject (instance) {\n  // TODO: fix this - see #15\n  return instance && (typeof instance) === 'object' && !(instance instanceof Array) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;\n"]},"metadata":{},"sourceType":"script"}