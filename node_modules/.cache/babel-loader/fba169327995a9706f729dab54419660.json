{"ast":null,"code":"import { randomBytes } from 'crypto';\nimport { ec as EC } from 'elliptic';\nconst curve = new EC('secp256k1');\nconst N = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO = Buffer.alloc(32, 0);\n\nfunction isValidPrivateKey(key) {\n  return Buffer.isBuffer(key) && key.length === 32 && !key.equals(ZERO) && key.compare(N) < 0;\n}\n\nfunction isValidMessageHash(hash) {\n  return Buffer.isBuffer(hash) && hash.length === 32;\n}\n/** secp256k1 methods set */\n\n\nexport var secp256k1;\n\n(function (secp256k1) {\n  /**\n   * generate private key\n   * @param rng the optional random number generator, which exactly generates 32 random bytes\n   */\n  function generatePrivateKey(rng) {\n    rng = rng || (() => randomBytes(32));\n\n    for (;;) {\n      const privKey = rng();\n\n      if (isValidPrivateKey(privKey)) {\n        return privKey;\n      }\n    }\n  }\n\n  secp256k1.generatePrivateKey = generatePrivateKey;\n  /**\n   * derive public key(uncompressed) from private key\n   * @param privKey the private key\n   */\n\n  function derivePublicKey(privKey) {\n    if (!isValidPrivateKey(privKey)) {\n      throw new Error('invalid private key');\n    }\n\n    const keyPair = curve.keyFromPrivate(privKey);\n    return Buffer.from(keyPair.getPublic().encode('array', false));\n  }\n\n  secp256k1.derivePublicKey = derivePublicKey;\n  /**\n   * sign a message using elliptic curve algorithm on the curve secp256k1\n   * @param msgHash hash of message\n   * @param privKey serialized private key\n   */\n\n  function sign(msgHash, privKey) {\n    if (!isValidMessageHash(msgHash)) {\n      throw new Error('invalid message hash');\n    }\n\n    if (!isValidPrivateKey(privKey)) {\n      throw new Error('invalid private key');\n    }\n\n    const keyPair = curve.keyFromPrivate(privKey);\n    const sig = keyPair.sign(msgHash, {\n      canonical: true\n    });\n    const r = Buffer.from(sig.r.toArray('be', 32));\n    const s = Buffer.from(sig.s.toArray('be', 32));\n    return Buffer.concat([r, s, Buffer.from([sig.recoveryParam])]);\n  }\n\n  secp256k1.sign = sign;\n  /**\n   * recovery signature to public key\n   * @param msgHash hash of message\n   * @param sig signature\n   */\n\n  function recover(msgHash, sig) {\n    if (!isValidMessageHash(msgHash)) {\n      throw new Error('invalid message hash');\n    }\n\n    if (!Buffer.isBuffer(sig) || sig.length !== 65) {\n      throw new Error('invalid signature');\n    }\n\n    const recovery = sig[64];\n\n    if (recovery !== 0 && recovery !== 1) {\n      throw new Error('invalid signature recovery');\n    }\n\n    const r = sig.slice(0, 32);\n    const s = sig.slice(32, 64);\n    return Buffer.from(curve.recoverPubKey(msgHash, {\n      r,\n      s\n    }, recovery).encode('array', false));\n  }\n\n  secp256k1.recover = recover;\n})(secp256k1 || (secp256k1 = {}));","map":{"version":3,"mappings":"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","names":["randomBytes","ec","EC","curve","N","Buffer","from","ZERO","alloc","isValidPrivateKey","key","isBuffer","length","equals","compare","isValidMessageHash","hash","secp256k1","generatePrivateKey","rng","privKey","derivePublicKey","Error","keyPair","keyFromPrivate","getPublic","encode","sign","msgHash","sig","canonical","r","toArray","s","concat","recoveryParam","recover","recovery","slice","recoverPubKey"],"sourceRoot":"","sources":["../../src/cry/secp256k1.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}