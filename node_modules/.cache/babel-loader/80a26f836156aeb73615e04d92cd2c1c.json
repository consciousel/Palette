{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiRegistry = void 0;\n\nconst fs = __importStar(require(\"fs\"));\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst axios_1 = __importDefault(require(\"axios\"));\n\nconst utils_1 = require(\"../../utils\");\n\nconst struct_1 = require(\"./struct\");\n\nconst contractInterface_1 = require(\"./contractInterface\");\n\nconst enum_1 = require(\"./enum\");\n\nconst typeMapper_1 = require(\"./typeMapper\");\n\nconst endpoint_1 = require(\"./endpoint\");\n\nclass AbiRegistry {\n  constructor() {\n    this.interfaces = [];\n    this.customTypes = [];\n  }\n  /**\n   * Convenience factory function to load ABIs (from files or URLs).\n   * This function will also remap ABI types to know types (on best-efforts basis).\n   */\n\n\n  static load(json) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let registry = new AbiRegistry();\n\n      for (const file of json.files || []) {\n        yield registry.extendFromFile(file);\n      }\n\n      for (const url of json.urls || []) {\n        yield registry.extendFromUrl(url);\n      }\n\n      registry = registry.remapToKnownTypes();\n      return registry;\n    });\n  }\n  /**\n   * Generally, one should use {@link AbiRegistry.load} instead.\n   */\n\n\n  extendFromFile(file) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let jsonContent = yield fs.promises.readFile(file, {\n        encoding: \"utf8\"\n      });\n      let json = JSON.parse(jsonContent);\n      return this.extend(json);\n    });\n  }\n  /**\n   * Generally, one should use {@link AbiRegistry.load} instead.\n   */\n\n\n  extendFromUrl(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let response = yield axios_1.default.get(url);\n      let json = response.data;\n      return this.extend(json);\n    });\n  }\n\n  extend(json) {\n    json.types = json.types || {}; // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n\n    let iface = contractInterface_1.ContractInterface.fromJSON(json);\n    this.interfaces.push(iface);\n\n    for (const customTypeName in json.types) {\n      let itemJson = json.types[customTypeName];\n      let typeDiscriminant = itemJson.type; // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n\n      itemJson.name = customTypeName;\n      let customType = this.createCustomType(typeDiscriminant, itemJson);\n      this.customTypes.push(customType);\n    }\n\n    return this;\n  }\n\n  createCustomType(typeDiscriminant, json) {\n    if (typeDiscriminant == \"struct\") {\n      return struct_1.StructType.fromJSON(json);\n    }\n\n    if (typeDiscriminant == \"enum\") {\n      return enum_1.EnumType.fromJSON(json);\n    }\n\n    throw new errors.ErrTypingSystem(`Unknown type discriminant: ${typeDiscriminant}`);\n  }\n\n  getInterface(name) {\n    let result = this.interfaces.find(e => e.name == name);\n    utils_1.guardValueIsSetWithMessage(`interface [${name}] not found`, result);\n    return result;\n  }\n\n  getInterfaces(names) {\n    return names.map(name => this.getInterface(name));\n  }\n\n  getStruct(name) {\n    let result = this.customTypes.find(e => e.getName() == name && e instanceof struct_1.StructType);\n    utils_1.guardValueIsSetWithMessage(`struct [${name}] not found`, result);\n    return result;\n  }\n\n  getStructs(names) {\n    return names.map(name => this.getStruct(name));\n  }\n\n  getEnum(name) {\n    let result = this.customTypes.find(e => e.getName() == name && e instanceof enum_1.EnumType);\n    utils_1.guardValueIsSetWithMessage(`enum [${name}] not found`, result);\n    return result;\n  }\n\n  getEnums(names) {\n    return names.map(name => this.getEnum(name));\n  }\n  /**\n   * Right after loading ABI definitions into a registry (e.g. from a file), the endpoints and the custom types (structs, enums)\n   * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\n   *\n   * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\n   *\n   * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\n   * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\n   * The result is an equivalent, more explicit ABI registry.\n   */\n\n\n  remapToKnownTypes() {\n    let mapper = new typeMapper_1.TypeMapper(this.customTypes);\n    let newCustomTypes = [];\n    let newInterfaces = []; // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n\n    for (const type of this.customTypes) {\n      const mappedTyped = mapper.mapType(type);\n      newCustomTypes.push(mappedTyped);\n      mapper.feedCustomType(mappedTyped);\n    } // Then, remap types of all endpoint parameters.\n    // But we'll use an enhanced mapper, that takes into account the results from the previous step.\n\n\n    mapper = new typeMapper_1.TypeMapper(newCustomTypes);\n\n    for (const iface of this.interfaces) {\n      let newEndpoints = [];\n\n      for (const endpoint of iface.endpoints) {\n        newEndpoints.push(mapEndpoint(endpoint, mapper));\n      }\n\n      let newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n      newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n    } // Now return the new registry, with all types remapped to known types\n\n\n    let newRegistry = new AbiRegistry();\n    newRegistry.customTypes.push(...newCustomTypes);\n    newRegistry.interfaces.push(...newInterfaces);\n    return newRegistry;\n  }\n\n}\n\nexports.AbiRegistry = AbiRegistry;\n\nfunction mapEndpoint(endpoint, mapper) {\n  let newInput = endpoint.input.map(e => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n  let newOutput = endpoint.output.map(e => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n  return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}","map":{"version":3,"mappings":"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","names":["AbiRegistry","constructor","load","json","registry","file","files","extendFromFile","url","urls","extendFromUrl","remapToKnownTypes","jsonContent","fs","promises","readFile","encoding","JSON","parse","extend","response","axios_1","get","data","types","iface","contractInterface_1","fromJSON","interfaces","push","customTypeName","itemJson","typeDiscriminant","type","name","customType","createCustomType","customTypes","struct_1","enum_1","errors","ErrTypingSystem","getInterface","result","find","e","utils_1","getInterfaces","names","map","getStruct","getName","getStructs","getEnum","getEnums","mapper","typeMapper_1","newCustomTypes","newInterfaces","mappedTyped","mapType","feedCustomType","newEndpoints","endpoint","endpoints","mapEndpoint","newConstructor","constructorDefinition","newRegistry","exports","newInput","input","endpoint_1","description","newOutput","output","modifiers"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/abiRegistry.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}