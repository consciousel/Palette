{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFaucetUrl = exports.FaucetNetwork = void 0;\n\nconst https = require(\"https\");\n\nconst common_1 = require(\"../common\");\n\nconst schema_validator_1 = require(\"../common/schema-validator\");\n\nconst errors_1 = require(\"../common/errors\");\n\nvar FaucetNetwork;\n\n(function (FaucetNetwork) {\n  FaucetNetwork[\"Testnet\"] = \"faucet.altnet.rippletest.net\";\n  FaucetNetwork[\"Devnet\"] = \"faucet.devnet.rippletest.net\";\n})(FaucetNetwork = exports.FaucetNetwork || (exports.FaucetNetwork = {}));\n\nconst INTERVAL_SECONDS = 1;\nconst MAX_ATTEMPTS = 20;\n\nfunction generateFaucetWallet(address) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!this.isConnected()) throw new errors_1.RippledError(\"RippleAPI not connected, cannot call faucet\");\n    let body;\n    let startingBalance = 0;\n    let faucetUrl = getFaucetUrl(this);\n\n    if (address && schema_validator_1.isValidAddress(address)) {\n      body = new TextEncoder().encode(JSON.stringify({\n        destination: address\n      }));\n      const addressToFundBalance = yield getAddressXrpBalance(this, address);\n\n      if (addressToFundBalance && !isNaN(+addressToFundBalance)) {\n        startingBalance = +addressToFundBalance;\n      } else {\n        startingBalance = 0;\n      }\n    }\n\n    const options = {\n      hostname: faucetUrl,\n      port: 443,\n      path: '/accounts',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': body ? body.length : 0\n      }\n    };\n    return new Promise((resolve, reject) => {\n      const request = https.request(options, response => {\n        const chunks = [];\n        response.on('data', d => {\n          chunks.push(d);\n        });\n        response.on('end', () => __awaiter(this, void 0, void 0, function* () {\n          const body = Buffer.concat(chunks).toString();\n\n          if (response.headers['content-type'].startsWith('application/json')) {\n            const wallet = JSON.parse(body);\n            const classicAddress = wallet.account.classicAddress;\n\n            if (classicAddress) {\n              try {\n                const isFunded = yield hasAddressBalanceIncreased(this, classicAddress, startingBalance);\n\n                if (isFunded) {\n                  resolve(wallet);\n                } else {\n                  reject(new common_1.errors.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`));\n                }\n              } catch (err) {\n                reject(new common_1.errors.XRPLFaucetError(err));\n              }\n            } else {\n              reject(new common_1.errors.XRPLFaucetError(`The faucet account classic address is undefined`));\n            }\n          } else {\n            reject({\n              statusCode: response.statusCode,\n              contentType: response.headers['content-type'],\n              body\n            });\n          }\n        }));\n      });\n      request.write(body ? body : '');\n      request.on('error', error => {\n        reject(error);\n      });\n      request.end();\n    });\n  });\n}\n\nfunction getAddressXrpBalance(api, address) {\n  return __awaiter(this, void 0, void 0, function* () {\n    try {\n      const balances = yield api.getBalances(address);\n      const xrpBalance = balances.filter(balance => balance.currency.toUpperCase() === 'XRP');\n      return xrpBalance[0].value;\n    } catch (err) {\n      return `Unable to retrieve ${address} balance. Error: ${err}`;\n    }\n  });\n}\n\nfunction hasAddressBalanceIncreased(api, address, originalBalance) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      let attempts = MAX_ATTEMPTS;\n      const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n        if (attempts < 0) {\n          clearInterval(interval);\n          resolve(false);\n        } else {\n          attempts--;\n        }\n\n        try {\n          const newBalance = +(yield getAddressXrpBalance(api, address));\n\n          if (newBalance > originalBalance) {\n            clearInterval(interval);\n            resolve(true);\n          }\n        } catch (err) {\n          clearInterval(interval);\n          reject(new common_1.errors.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err}`));\n        }\n      }), INTERVAL_SECONDS * 1000);\n    });\n  });\n}\n\nfunction getFaucetUrl(api) {\n  const connectionUrl = api.connection.getUrl();\n\n  if (connectionUrl.includes('altnet') || connectionUrl.includes('testnet')) {\n    return FaucetNetwork.Testnet;\n  }\n\n  if (connectionUrl.includes('devnet')) {\n    return FaucetNetwork.Devnet;\n  }\n\n  return undefined;\n}\n\nexports.getFaucetUrl = getFaucetUrl;\nexports.default = generateFaucetWallet;","map":{"version":3,"mappings":"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","names":["FaucetNetwork","exports","INTERVAL_SECONDS","MAX_ATTEMPTS","generateFaucetWallet","address","isConnected","errors_1","body","startingBalance","faucetUrl","getFaucetUrl","schema_validator_1","TextEncoder","encode","JSON","stringify","destination","addressToFundBalance","getAddressXrpBalance","isNaN","options","hostname","port","path","method","headers","length","Promise","resolve","reject","request","https","response","chunks","on","d","push","__awaiter","Buffer","concat","toString","startsWith","wallet","parse","classicAddress","account","isFunded","hasAddressBalanceIncreased","common_1","XRPLFaucetError","err","statusCode","contentType","write","error","end","api","balances","getBalances","xrpBalance","filter","balance","currency","toUpperCase","value","originalBalance","attempts","interval","setInterval","clearInterval","newBalance","connectionUrl","connection","getUrl","includes","Testnet","Devnet","undefined"],"sourceRoot":"","sources":["../../../src/wallet/wallet-generation.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}