{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinaryCodecConstraints = exports.BinaryCodec = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst typesystem_1 = require(\"../typesystem\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst option_1 = require(\"./option\");\n\nconst primitive_1 = require(\"./primitive\");\n\nconst list_1 = require(\"./list\");\n\nconst struct_1 = require(\"./struct\");\n\nconst enum_1 = require(\"./enum\");\n\nconst tuple_1 = require(\"./tuple\");\n\nclass BinaryCodec {\n  constructor() {\n    let constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.constraints = constraints || new BinaryCodecConstraints();\n    this.optionCodec = new option_1.OptionValueBinaryCodec(this);\n    this.listCodec = new list_1.ListBinaryCodec(this);\n    this.primitiveCodec = new primitive_1.PrimitiveBinaryCodec(this);\n    this.structCodec = new struct_1.StructBinaryCodec(this);\n    this.tupleCodec = new tuple_1.TupleBinaryCodec(this);\n    this.enumCodec = new enum_1.EnumBinaryCodec(this);\n  }\n\n  decodeTopLevel(buffer, type) {\n    this.constraints.checkBufferLength(buffer);\n    let typedValue = typesystem_1.onTypeSelect(type, {\n      onOption: () => this.optionCodec.decodeTopLevel(buffer, type.getFirstTypeParameter()),\n      onList: () => this.listCodec.decodeTopLevel(buffer, type),\n      onPrimitive: () => this.primitiveCodec.decodeTopLevel(buffer, type),\n      onStruct: () => this.structCodec.decodeTopLevel(buffer, type),\n      onTuple: () => this.tupleCodec.decodeTopLevel(buffer, type),\n      onEnum: () => this.enumCodec.decodeTopLevel(buffer, type)\n    });\n    return typedValue;\n  }\n\n  decodeNested(buffer, type) {\n    this.constraints.checkBufferLength(buffer);\n    let [typedResult, decodedLength] = typesystem_1.onTypeSelect(type, {\n      onOption: () => this.optionCodec.decodeNested(buffer, type.getFirstTypeParameter()),\n      onList: () => this.listCodec.decodeNested(buffer, type),\n      onPrimitive: () => this.primitiveCodec.decodeNested(buffer, type),\n      onStruct: () => this.structCodec.decodeNested(buffer, type),\n      onTuple: () => this.tupleCodec.decodeNested(buffer, type),\n      onEnum: () => this.enumCodec.decodeNested(buffer, type)\n    });\n    return [typedResult, decodedLength];\n  }\n\n  encodeNested(typedValue) {\n    utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), \"singular cardinality, thus encodable type\");\n    return typesystem_1.onTypedValueSelect(typedValue, {\n      onPrimitive: () => this.primitiveCodec.encodeNested(typedValue),\n      onOption: () => this.optionCodec.encodeNested(typedValue),\n      onList: () => this.listCodec.encodeNested(typedValue),\n      onStruct: () => this.structCodec.encodeNested(typedValue),\n      onTuple: () => this.tupleCodec.encodeNested(typedValue),\n      onEnum: () => this.enumCodec.encodeNested(typedValue)\n    });\n  }\n\n  encodeTopLevel(typedValue) {\n    utils_1.guardType(\"value\", typesystem_1.TypedValue, typedValue, false);\n    utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), \"singular cardinality, thus encodable type\");\n    return typesystem_1.onTypedValueSelect(typedValue, {\n      onPrimitive: () => this.primitiveCodec.encodeTopLevel(typedValue),\n      onOption: () => this.optionCodec.encodeTopLevel(typedValue),\n      onList: () => this.listCodec.encodeTopLevel(typedValue),\n      onStruct: () => this.structCodec.encodeTopLevel(typedValue),\n      onTuple: () => this.tupleCodec.encodeTopLevel(typedValue),\n      onEnum: () => this.enumCodec.encodeTopLevel(typedValue)\n    });\n  }\n\n}\n\nexports.BinaryCodec = BinaryCodec;\n\nclass BinaryCodecConstraints {\n  constructor(init) {\n    this.maxBufferLength = (init === null || init === void 0 ? void 0 : init.maxBufferLength) || 4096;\n    this.maxListLength = (init === null || init === void 0 ? void 0 : init.maxListLength) || 1024;\n  }\n\n  checkBufferLength(buffer) {\n    if (buffer.length > this.maxBufferLength) {\n      throw new errors.ErrCodec(`Buffer too large: ${buffer.length} > ${this.maxBufferLength}`);\n    }\n  }\n  /**\n   * This constraint avoids computer-freezing decode bugs (e.g. due to invalid ABI or struct definitions).\n   */\n\n\n  checkListLength(length) {\n    if (length > this.maxListLength) {\n      throw new errors.ErrCodec(`List too large: ${length} > ${this.maxListLength}`);\n    }\n  }\n\n}\n\nexports.BinaryCodecConstraints = BinaryCodecConstraints;","map":{"version":3,"mappings":"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","names":["BinaryCodec","constructor","constraints","BinaryCodecConstraints","optionCodec","option_1","listCodec","list_1","primitiveCodec","primitive_1","structCodec","struct_1","tupleCodec","tuple_1","enumCodec","enum_1","decodeTopLevel","buffer","type","checkBufferLength","typedValue","typesystem_1","onOption","getFirstTypeParameter","onList","onPrimitive","onStruct","onTuple","onEnum","decodeNested","typedResult","decodedLength","encodeNested","utils_1","getType","getCardinality","isSingular","encodeTopLevel","exports","init","maxBufferLength","maxListLength","length","errors","ErrCodec","checkListLength"],"sourceRoot":"","sources":["../../../src/smartcontracts/codec/binary.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}