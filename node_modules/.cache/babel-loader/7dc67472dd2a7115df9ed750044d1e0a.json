{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\n/**\n * Helper for converting functions which take a callback as their final argument\n * to functions which return a promise.\n */\n\nexport function promisify(f) {\n  return new Promise(function (resolve, reject) {\n    return f(function (error, result) {\n      if (error != null) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n/**\n * Helper for converting functions which return a promise to functions which\n * take a callback as their final argument.\n */\n\nexport function callWhenDone(promise, callback) {\n  promise.then(function (result) {\n    callback(null, result);\n  }, function (error) {\n    callback(error);\n  });\n}\nexport function delay(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\nexport function withTimeout(promise, ms) {\n  return Promise.race([promise, new Promise(function (_, reject) {\n    return setTimeout(function () {\n      return reject(new Error(\"Timeout\"));\n    }, ms);\n  })]);\n}\nvar MIN_RETRY_DELAY = 1000;\nvar RETRY_BACKOFF_FACTOR = 2;\nvar MAX_RETRY_DELAY = 30000;\nexport function withBackoffRetries(f, retryCount, shouldRetry) {\n  if (shouldRetry === void 0) {\n    shouldRetry = function () {\n      return true;\n    };\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var nextWaitTime, i, error_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          nextWaitTime = 0;\n          i = 0;\n          _a.label = 1;\n\n        case 1:\n          if (!true) return [3\n          /*break*/\n          , 7];\n          _a.label = 2;\n\n        case 2:\n          _a.trys.push([2, 4,, 6]);\n\n          return [4\n          /*yield*/\n          , f()];\n\n        case 3:\n          return [2\n          /*return*/\n          , _a.sent()];\n\n        case 4:\n          error_1 = _a.sent();\n          i++;\n\n          if (i >= retryCount || !shouldRetry(error_1)) {\n            throw error_1;\n          }\n\n          return [4\n          /*yield*/\n          , delay(nextWaitTime)];\n\n        case 5:\n          _a.sent();\n\n          if (!shouldRetry(error_1)) {\n            throw error_1;\n          }\n\n          nextWaitTime = nextWaitTime === 0 ? MIN_RETRY_DELAY : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n          return [3\n          /*break*/\n          , 6];\n\n        case 6:\n          return [3\n          /*break*/\n          , 1];\n\n        case 7:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\nexport function makeCancelToken() {\n  var cancelled = false;\n  return {\n    cancel: function () {\n      return cancelled = true;\n    },\n    isCancelled: function () {\n      return cancelled;\n    }\n  };\n}\nexport function throwIfCancelled(isCancelled) {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\nexport var CANCELLED = new Error(\"Cancelled\");","map":{"version":3,"mappings":";AAEA;;;;;AAIA,OAAM,SAAUA,SAAV,CACJC,CADI,EACkC;AAEtC,SAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAgB;AACjC,YAAC,CAAC,UAACC,KAAD,EAAQC,MAAR,EAAc;AACd,UAAID,KAAK,IAAI,IAAb,EAAmB;AACjBD,cAAM,CAACC,KAAD,CAAN;AACD,OAFD,MAEO;AACLF,eAAO,CAACG,MAAD,CAAP;AACD;AACF,KANA,CAAD;AAME,GAPG,CAAP;AASD;AAED;;;;;AAIA,OAAM,SAAUC,YAAV,CACJC,OADI,EAEJC,QAFI,EAEqB;AAEzBD,SAAO,CAACE,IAAR,CACE,UAACJ,MAAD,EAAO;AACLG,YAAQ,CAAC,IAAD,EAAOH,MAAP,CAAR;AACD,GAHH,EAIE,UAACD,KAAD,EAAM;AACJI,YAAQ,CAACJ,KAAD,CAAR;AACD,GANH;AAQD;AAED,OAAM,SAAUM,KAAV,CAAgBC,EAAhB,EAA0B;AAC9B,SAAO,IAAIV,OAAJ,CAAY,UAACC,OAAD,EAAQ;AAAK,qBAAU,CAACA,OAAD,EAAUS,EAAV,CAAV;AAAuB,GAAhD,CAAP;AACD;AAED,OAAM,SAAUC,WAAV,CAAyBL,OAAzB,EAA8CI,EAA9C,EAAwD;AAC5D,SAAOV,OAAO,CAACY,IAAR,CAAa,CAClBN,OADkB,EAElB,IAAIN,OAAJ,CAAe,UAACa,CAAD,EAAIX,MAAJ,EAAU;AACvB,qBAAU,CAAC;AAAM,mBAAM,CAAC,IAAIY,KAAJ,CAAU,SAAV,CAAD,CAAN;AAA4B,KAAnC,EAAqCJ,EAArC,CAAV;AAAkD,GADpD,CAFkB,CAAb,CAAP;AAMD;AAED,IAAMK,eAAe,GAAG,IAAxB;AACA,IAAMC,oBAAoB,GAAG,CAA7B;AACA,IAAMC,eAAe,GAAG,KAAxB;AAEA,OAAM,SAAgBC,kBAAhB,CACJnB,CADI,EAEJoB,UAFI,EAGJC,WAHI,EAGiD;AAArD;AAAAA;AAAiD;AAAI,KAArD;AAAqD;;;;;;;AAEjDC,sBAAY,GAAG,CAAf;AACAC,WAAC,GAAG,CAAJ;;;;eACG,MAAI;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA,YAAMvB,CAAC,EAAP;;;AAAP;AAAA;AAAA,YAAOwB,SAAP;;;;AAEAD,WAAC;;AACD,cAAIA,CAAC,IAAIH,UAAL,IAAmB,CAACC,WAAW,CAACI,OAAD,CAAnC,EAA4C;AAC1C,kBAAMA,OAAN;AACD;;AACD;AAAA;AAAA,YAAMf,KAAK,CAACY,YAAD,CAAX;;;AAAAE;;AACA,cAAI,CAACH,WAAW,CAACI,OAAD,CAAhB,EAAyB;AACvB,kBAAMA,OAAN;AACD;;AACDH,sBAAY,GACVA,YAAY,KAAK,CAAjB,GACIN,eADJ,GAEIU,IAAI,CAACC,GAAL,CAAST,eAAT,EAA0BD,oBAAoB,GAAGK,YAAjD,CAHN;;;;;;;;;;;;;;;;;AAML;AAOD,OAAM,SAAUM,eAAV,GAAyB;AAC7B,MAAIC,SAAS,GAAG,KAAhB;AACA,SAAO;AAAEC,UAAM,EAAE;AAAM,aAACD,SAAS,GAAG,IAAb;AAAkB,KAAlC;AAAoCE,eAAW,EAAE;AAAM;AAAS;AAAhE,GAAP;AACD;AAED,OAAM,SAAUC,gBAAV,CAA2BD,WAA3B,EAAqD;AACzD,MAAIA,WAAW,EAAf,EAAmB;AACjB,UAAME,SAAN;AACD;AACF;AAED,OAAO,IAAMA,SAAS,GAAG,IAAIlB,KAAJ,CAAU,WAAV,CAAlB","names":["promisify","f","Promise","resolve","reject","error","result","callWhenDone","promise","callback","then","delay","ms","withTimeout","race","_","Error","MIN_RETRY_DELAY","RETRY_BACKOFF_FACTOR","MAX_RETRY_DELAY","withBackoffRetries","retryCount","shouldRetry","nextWaitTime","i","_a","error_1","Math","min","makeCancelToken","cancelled","cancel","isCancelled","throwIfCancelled","CANCELLED"],"sourceRoot":"","sources":["../../../src/util/promises.ts"],"sourcesContent":["import { Web3Callback } from \"../types\";\n\n/**\n * Helper for converting functions which take a callback as their final argument\n * to functions which return a promise.\n */\nexport function promisify<T>(\n  f: (callback: Web3Callback<T>) => void,\n): Promise<T> {\n  return new Promise((resolve, reject) =>\n    f((error, result) => {\n      if (error != null) {\n        reject(error);\n      } else {\n        resolve(result!);\n      }\n    }),\n  );\n}\n\n/**\n * Helper for converting functions which return a promise to functions which\n * take a callback as their final argument.\n */\nexport function callWhenDone<T>(\n  promise: Promise<T>,\n  callback: Web3Callback<T>,\n): void {\n  promise.then(\n    (result) => {\n      callback(null, result);\n    },\n    (error) => {\n      callback(error);\n    },\n  );\n}\n\nexport function delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error(\"Timeout\")), ms),\n    ),\n  ]);\n}\n\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nexport async function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true,\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nexport interface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\nexport function makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n\nexport const CANCELLED = new Error(\"Cancelled\");\n"]},"metadata":{},"sourceType":"module"}