{"ast":null,"code":"const bech32 = require('bech32');\n\nconst {\n  validateString,\n  validateBuffer\n} = require('./validation');\n\nfunction encode(prefix, data) {\n  validateString(prefix);\n  validateBuffer(data);\n  const words = bech32.toWords(data); // we need longer than default length for privkeys and 1000 should suffice\n\n  return bech32.encode(prefix, words, 1000);\n}\n\nfunction decode(str) {\n  validateString(str);\n  const tmp = bech32.decode(str, 1000);\n  return {\n    prefix: tmp.prefix,\n    data: Buffer.from(bech32.fromWords(tmp.words))\n  };\n}\n\nmodule.exports = {\n  encode,\n  decode\n};","map":{"version":3,"sources":["C:/Users/masho/OneDrive/Desktop/Blockchain/Biconomy/Projects/NFT_minter/node_modules/cardano-crypto.js/utils/bech32.js"],"names":["bech32","require","validateString","validateBuffer","encode","prefix","data","words","toWords","decode","str","tmp","Buffer","from","fromWords","module","exports"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM;AAACC,EAAAA,cAAD;AAAiBC,EAAAA;AAAjB,IAAmCF,OAAO,CAAC,cAAD,CAAhD;;AAEA,SAASG,MAAT,CAAgBC,MAAhB,EAAwBC,IAAxB,EAA8B;AAC5BJ,EAAAA,cAAc,CAACG,MAAD,CAAd;AACAF,EAAAA,cAAc,CAACG,IAAD,CAAd;AAEA,QAAMC,KAAK,GAAGP,MAAM,CAACQ,OAAP,CAAeF,IAAf,CAAd,CAJ4B,CAK5B;;AACA,SAAON,MAAM,CAACI,MAAP,CAAcC,MAAd,EAAsBE,KAAtB,EAA6B,IAA7B,CAAP;AACD;;AAED,SAASE,MAAT,CAAgBC,GAAhB,EAAqB;AACnBR,EAAAA,cAAc,CAACQ,GAAD,CAAd;AAEA,QAAMC,GAAG,GAAGX,MAAM,CAACS,MAAP,CAAcC,GAAd,EAAmB,IAAnB,CAAZ;AACA,SAAO;AACLL,IAAAA,MAAM,EAAEM,GAAG,CAACN,MADP;AAELC,IAAAA,IAAI,EAAEM,MAAM,CAACC,IAAP,CAAYb,MAAM,CAACc,SAAP,CAAiBH,GAAG,CAACJ,KAArB,CAAZ;AAFD,GAAP;AAID;;AAEDQ,MAAM,CAACC,OAAP,GAAiB;AACfZ,EAAAA,MADe;AAEfK,EAAAA;AAFe,CAAjB","sourcesContent":["const bech32 = require('bech32')\nconst {validateString, validateBuffer} = require('./validation')\n\nfunction encode(prefix, data) {\n  validateString(prefix)\n  validateBuffer(data)\n\n  const words = bech32.toWords(data)\n  // we need longer than default length for privkeys and 1000 should suffice\n  return bech32.encode(prefix, words, 1000)\n}\n\nfunction decode(str) {\n  validateString(str)\n\n  const tmp = bech32.decode(str, 1000)\n  return {\n    prefix: tmp.prefix,\n    data: Buffer.from(bech32.fromWords(tmp.words)),\n  }\n}\n\nmodule.exports = {\n  encode,\n  decode\n}\n"]},"metadata":{},"sourceType":"script"}