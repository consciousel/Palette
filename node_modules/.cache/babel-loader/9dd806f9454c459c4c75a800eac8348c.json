{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport assertNever from \"assert-never\";\nimport { delay, promisify } from \"../util/promises\";\nvar ALCHEMY_DISALLOWED_METHODS = [\"eth_accounts\", \"eth_sendTransaction\", \"eth_sign\", \"eth_signTypedData_v3\", \"eth_signTypedData\"];\nvar ALCHEMY_DISALLOWED_PREFIXES = [\"personal\"];\nexport function makeJsonRpcPayloadSender(alchemySendJsonRpc, config) {\n  var currentWriteProvider = config.writeProvider;\n\n  var sendJsonRpcPayload = function (payload) {\n    var disallowedMethod = getDisallowedMethod(payload);\n\n    if (!disallowedMethod) {\n      try {\n        return sendJsonRpcWithRetries(payload, alchemySendJsonRpc, config);\n      } catch (alchemyError) {\n        // Fallback to write provider, but if both fail throw the error from\n        // Alchemy.\n        if (!currentWriteProvider) {\n          throw alchemyError;\n        }\n\n        try {\n          return sendJsonRpcWithProvider(currentWriteProvider, payload);\n        } catch (_a) {\n          throw alchemyError;\n        }\n      }\n    } else {\n      if (!currentWriteProvider) {\n        throw new Error(\"No provider available for method \\\"\" + disallowedMethod + \"\\\"\");\n      }\n\n      return sendJsonRpcWithProvider(currentWriteProvider, payload);\n    }\n  };\n\n  function setWriteProvider(writeProvider) {\n    currentWriteProvider = writeProvider !== null && writeProvider !== void 0 ? writeProvider : null;\n  }\n\n  return {\n    sendJsonRpcPayload: sendJsonRpcPayload,\n    setWriteProvider: setWriteProvider\n  };\n}\n\nfunction sendJsonRpcWithProvider(provider, payload) {\n  var anyProvider = provider;\n  var sendMethod = (anyProvider.sendAsync ? anyProvider.sendAsync : anyProvider.send).bind(anyProvider);\n  return promisify(function (callback) {\n    return sendMethod(payload, callback);\n  });\n}\n\nfunction getDisallowedMethod(payload) {\n  var payloads = Array.isArray(payload) ? payload : [payload]; // Check if the payload method is a disallowed method or starts with a\n  // disallowed prefix.\n\n  var disallowedRequest = payloads.find(function (p) {\n    return ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0 || ALCHEMY_DISALLOWED_PREFIXES.some(function (prefix) {\n      return p.method.startsWith(prefix);\n    });\n  }) || undefined;\n  return disallowedRequest && disallowedRequest.method;\n}\n\nfunction sendJsonRpcWithRetries(payload, alchemySendJsonRpc, _a) {\n  var maxRetries = _a.maxRetries,\n      retryInterval = _a.retryInterval,\n      retryJitter = _a.retryJitter;\n  return __awaiter(this, void 0, void 0, function () {\n    var i, result, status_1, message, statusString;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          i = 0;\n          _b.label = 1;\n\n        case 1:\n          if (!(i < maxRetries + 1)) return [3\n          /*break*/\n          , 5];\n          return [4\n          /*yield*/\n          , alchemySendJsonRpc(payload)];\n\n        case 2:\n          result = _b.sent();\n\n          switch (result.type) {\n            case \"jsonrpc\":\n              return [2\n              /*return*/\n              , result.response];\n\n            case \"rateLimit\":\n              break;\n\n            case \"networkError\":\n              {\n                status_1 = result.status, message = result.message;\n                statusString = status_1 !== 0 ? \"(\" + status_1 + \") \" : \"\";\n                throw new Error(statusString + \" \" + message);\n              }\n\n            default:\n              return [2\n              /*return*/\n              , assertNever(result)];\n          }\n\n          return [4\n          /*yield*/\n          , delay(retryInterval + (retryJitter * Math.random() | 0))];\n\n        case 3:\n          _b.sent();\n\n          _b.label = 4;\n\n        case 4:\n          i++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 5:\n          throw new Error(\"Rate limited for \" + (maxRetries + 1) + \" consecutive attempts.\");\n      }\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["assertNever","delay","promisify","ALCHEMY_DISALLOWED_METHODS","ALCHEMY_DISALLOWED_PREFIXES","makeJsonRpcPayloadSender","alchemySendJsonRpc","config","currentWriteProvider","writeProvider","sendJsonRpcPayload","payload","disallowedMethod","getDisallowedMethod","sendJsonRpcWithRetries","alchemyError","sendJsonRpcWithProvider","Error","setWriteProvider","provider","anyProvider","sendMethod","sendAsync","send","bind","callback","payloads","Array","isArray","disallowedRequest","find","p","indexOf","method","some","prefix","startsWith","undefined","_a","maxRetries","retryInterval","retryJitter","i","result","_b","type","response","status_1","message","statusString","Math","random"],"sourceRoot":"","sources":["../../../src/web3-adapter/sendJsonRpcPayload.ts"],"sourcesContent":["import assertNever from \"assert-never\";\nimport {\n  FullConfig,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  Provider,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n} from \"../types\";\nimport { delay, promisify } from \"../util/promises\";\nimport { AlchemySendJsonRpcFunction } from \"./alchemySend\";\n\nconst ALCHEMY_DISALLOWED_METHODS: string[] = [\n  \"eth_accounts\",\n  \"eth_sendTransaction\",\n  \"eth_sign\",\n  \"eth_signTypedData_v3\",\n  \"eth_signTypedData\",\n];\n\nconst ALCHEMY_DISALLOWED_PREFIXES: string[] = [\"personal\"];\n\nexport interface JsonRpcPayloadSender {\n  sendJsonRpcPayload: SendJsonRpcPayloadFunction;\n  setWriteProvider(writeProvider: Provider | null | undefined): void;\n}\n\nexport interface SendJsonRpcPayloadFunction {\n  (payload: JsonRpcRequest): Promise<JsonRpcResponse>;\n  (payload: SingleOrBatchRequest): Promise<SingleOrBatchResponse>;\n}\n\nexport function makeJsonRpcPayloadSender(\n  alchemySendJsonRpc: AlchemySendJsonRpcFunction,\n  config: FullConfig,\n): JsonRpcPayloadSender {\n  let currentWriteProvider = config.writeProvider;\n\n  const sendJsonRpcPayload = (\n    payload: SingleOrBatchRequest,\n  ): Promise<SingleOrBatchResponse> => {\n    const disallowedMethod = getDisallowedMethod(payload);\n    if (!disallowedMethod) {\n      try {\n        return sendJsonRpcWithRetries(payload, alchemySendJsonRpc, config);\n      } catch (alchemyError) {\n        // Fallback to write provider, but if both fail throw the error from\n        // Alchemy.\n        if (!currentWriteProvider) {\n          throw alchemyError;\n        }\n        try {\n          return sendJsonRpcWithProvider(currentWriteProvider, payload);\n        } catch {\n          throw alchemyError;\n        }\n      }\n    } else {\n      if (!currentWriteProvider) {\n        throw new Error(\n          `No provider available for method \"${disallowedMethod}\"`,\n        );\n      }\n      return sendJsonRpcWithProvider(currentWriteProvider, payload);\n    }\n  };\n\n  function setWriteProvider(writeProvider: Provider | null | undefined) {\n    currentWriteProvider = writeProvider ?? null;\n  }\n\n  return {\n    sendJsonRpcPayload: sendJsonRpcPayload as SendJsonRpcPayloadFunction,\n    setWriteProvider,\n  };\n}\n\nfunction sendJsonRpcWithProvider(\n  provider: Provider,\n  payload: SingleOrBatchRequest,\n): Promise<SingleOrBatchResponse> {\n  const anyProvider: any = provider;\n  const sendMethod = (\n    anyProvider.sendAsync ? anyProvider.sendAsync : anyProvider.send\n  ).bind(anyProvider);\n  return promisify((callback) => sendMethod(payload, callback));\n}\n\nfunction getDisallowedMethod(\n  payload: SingleOrBatchRequest,\n): string | undefined {\n  const payloads = Array.isArray(payload) ? payload : [payload];\n\n  // Check if the payload method is a disallowed method or starts with a\n  // disallowed prefix.\n  const disallowedRequest =\n    payloads.find(\n      (p) =>\n        ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0 ||\n        ALCHEMY_DISALLOWED_PREFIXES.some((prefix) =>\n          p.method.startsWith(prefix),\n        ),\n    ) || undefined;\n  return disallowedRequest && disallowedRequest.method;\n}\n\nasync function sendJsonRpcWithRetries(\n  payload: SingleOrBatchRequest,\n  alchemySendJsonRpc: AlchemySendJsonRpcFunction,\n  { maxRetries, retryInterval, retryJitter }: FullConfig,\n): Promise<SingleOrBatchResponse> {\n  for (let i = 0; i < maxRetries + 1; i++) {\n    const result = await alchemySendJsonRpc(payload);\n    switch (result.type) {\n      case \"jsonrpc\":\n        return result.response;\n      case \"rateLimit\":\n        break;\n      case \"networkError\": {\n        const { status, message } = result;\n        const statusString = status !== 0 ? `(${status}) ` : \"\";\n        throw new Error(`${statusString} ${message}`);\n      }\n      default:\n        return assertNever(result);\n    }\n    await delay(retryInterval + ((retryJitter * Math.random()) | 0));\n  }\n  throw new Error(`Rate limited for ${maxRetries + 1} consecutive attempts.`);\n}\n"]},"metadata":{},"sourceType":"module"}