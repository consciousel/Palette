{"ast":null,"code":"import { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id); // $FlowFixMe\n\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu, key) {\n  const result = Buffer.alloc(apdu.length);\n\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n\n  return result;\n} // Convert from normal to web-safe, strip trailing \"=\"s\n\n\nconst webSafe64 = base64 => base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\"); // Convert from web-safe to normal, add trailing \"=\"s\n\n\nconst normal64 = base64 => base64.replace(/-/g, \"+\").replace(/_/g, \"/\") + \"==\".substring(0, 3 * base64.length % 4);\n\nfunction attemptExchange(apdu, timeoutMillis, scrambleKey, unwrap) {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\");\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then(response => {\n    const {\n      signatureData\n    } = response;\n\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      let result;\n\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach(t => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\n\n\nexport default class TransportU2F extends Transport {\n  /*\n   */\n\n  /*\n   */\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_) {\n    let _openTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;\n\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    this.scrambleKey = void 0;\n    this.unwrap = true;\n    transportInstances.push(this);\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  async exchange(apdu) {\n    try {\n      return await attemptExchange(apdu, this.exchangeTimeout, this.scrambleKey, this.unwrap);\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        } // the wrapping make error more usable and \"printable\" to the end user.\n\n\n        throw wrapU2FTransportError(e, \"Failed to sign with Ledger device: U2F \" + e.metaData.type, \"U2F_\" + e.metaData.code);\n      } else {\n        throw e;\n      }\n    }\n  }\n  /**\n   */\n\n\n  setScrambleKey(scrambleKey) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n  /**\n   */\n\n\n  setUnwrap(unwrap) {\n    this.unwrap = unwrap;\n  }\n\n  close() {\n    // u2f have no way to clean things up\n    return Promise.resolve();\n  }\n\n}\nTransportU2F.isSupported = isSupported;\n\nTransportU2F.list = () => // this transport is not discoverable but we are going to guess if it is here with isSupported()\nisSupported().then(supported => supported ? [null] : []);\n\nTransportU2F.listen = observer => {\n  let unsubscribed = false;\n  isSupported().then(supported => {\n    if (unsubscribed) return;\n\n    if (supported) {\n      observer.next({\n        type: \"add\",\n        descriptor: null\n      });\n      observer.complete();\n    } else {\n      observer.error(new TransportError(\"U2F browser support is needed for Ledger. \" + \"Please use Chrome, Opera or Firefox with a U2F extension. \" + \"Also make sure you're on an HTTPS connection\", \"U2FNotSupported\"));\n    }\n  });\n  return {\n    unsubscribe: () => {\n      unsubscribed = true;\n    }\n  };\n};","map":{"version":3,"mappings":"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","names":["sign","isSupported","Transport","log","TransportError","wrapU2FTransportError","originalError","message","id","err","wrapApdu","apdu","key","result","Buffer","alloc","length","i","webSafe64","base64","replace","normal64","substring","attemptExchange","timeoutMillis","scrambleKey","unwrap","keyHandle","challenge","from","signRequest","version","toString","appId","location","origin","then","response","signatureData","data","slice","transportInstances","emitDisconnect","forEach","t","emit","isTimeoutU2FError","u2fError","metaData","code","TransportU2F","open","_","_openTimeout","constructor","push","exchange","exchangeTimeout","e","isU2FError","type","setScrambleKey","setUnwrap","close","Promise","resolve","list","supported","listen","observer","unsubscribed","next","descriptor","complete","error","unsubscribe"],"sources":["../src/TransportU2F.js"],"sourcesContent":["//@flow\n\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id);\n  // $FlowFixMe\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu: Buffer, key: Buffer) {\n  const result = Buffer.alloc(apdu.length);\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n}\n\n// Convert from normal to web-safe, strip trailing \"=\"s\nconst webSafe64 = (base64: string) =>\n  base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n\n// Convert from web-safe to normal, add trailing \"=\"s\nconst normal64 = (base64: string) =>\n  base64.replace(/-/g, \"+\").replace(/_/g, \"/\") +\n  \"==\".substring(0, (3 * base64.length) % 4);\n\nfunction attemptExchange(\n  apdu: Buffer,\n  timeoutMillis: number,\n  scrambleKey: Buffer,\n  unwrap: boolean\n): Promise<Buffer> {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"hex\"\n  );\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin,\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then((response) => {\n    const { signatureData } = response;\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      let result;\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach((t) => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\nexport default class TransportU2F extends Transport<null> {\n  static isSupported = isSupported;\n\n  /*\n   */\n  static list = (): * =>\n    // this transport is not discoverable but we are going to guess if it is here with isSupported()\n    isSupported().then((supported) => (supported ? [null] : []));\n\n  /*\n   */\n  static listen = (observer: *) => {\n    let unsubscribed = false;\n    isSupported().then((supported) => {\n      if (unsubscribed) return;\n      if (supported) {\n        observer.next({ type: \"add\", descriptor: null });\n        observer.complete();\n      } else {\n        observer.error(\n          new TransportError(\n            \"U2F browser support is needed for Ledger. \" +\n              \"Please use Chrome, Opera or Firefox with a U2F extension. \" +\n              \"Also make sure you're on an HTTPS connection\",\n            \"U2FNotSupported\"\n          )\n        );\n      }\n    });\n    return {\n      unsubscribe: () => {\n        unsubscribed = true;\n      },\n    };\n  };\n\n  scrambleKey: Buffer;\n\n  unwrap: boolean = true;\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_: *, _openTimeout?: number = 5000): Promise<TransportU2F> {\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    transportInstances.push(this);\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    try {\n      return await attemptExchange(\n        apdu,\n        this.exchangeTimeout,\n        this.scrambleKey,\n        this.unwrap\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        }\n        // the wrapping make error more usable and \"printable\" to the end user.\n        throw wrapU2FTransportError(\n          e,\n          \"Failed to sign with Ledger device: U2F \" + e.metaData.type,\n          \"U2F_\" + e.metaData.code\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   */\n  setScrambleKey(scrambleKey: string) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  /**\n   */\n  setUnwrap(unwrap: boolean) {\n    this.unwrap = unwrap;\n  }\n\n  close(): Promise<void> {\n    // u2f have no way to clean things up\n    return Promise.resolve();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}