{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;\n\nvar assert_1 = require(\"assert\");\n\nvar types_1 = require(\"./types\");\n\nvar hash_prefixes_1 = require(\"./hash-prefixes\");\n\nvar hashes_1 = require(\"./hashes\");\n\nvar buffer_1 = require(\"buffer/\");\n/**\n * Abstract class describing a SHAMapNode\n */\n\n\nvar ShaMapNode =\n/** @class */\nfunction () {\n  function ShaMapNode() {}\n\n  return ShaMapNode;\n}();\n\nexports.ShaMapNode = ShaMapNode;\n/**\n * Class describing a Leaf of SHAMap\n */\n\nvar ShaMapLeaf =\n/** @class */\nfunction (_super) {\n  __extends(ShaMapLeaf, _super);\n\n  function ShaMapLeaf(index, item) {\n    var _this = _super.call(this) || this;\n\n    _this.index = index;\n    _this.item = item;\n    return _this;\n  }\n  /**\n   * @returns true as ShaMapLeaf is a leaf node\n   */\n\n\n  ShaMapLeaf.prototype.isLeaf = function () {\n    return true;\n  };\n  /**\n   * @returns false as ShaMapLeaf is not an inner node\n   */\n\n\n  ShaMapLeaf.prototype.isInner = function () {\n    return false;\n  };\n  /**\n   * Get the prefix of the this.item\n   *\n   * @returns The hash prefix, unless this.item is undefined, then it returns an empty Buffer\n   */\n\n\n  ShaMapLeaf.prototype.hashPrefix = function () {\n    return this.item === undefined ? buffer_1.Buffer.alloc(0) : this.item.hashPrefix();\n  };\n  /**\n   * Hash the bytes representation of this\n   *\n   * @returns hash of this.item concatenated with this.index\n   */\n\n\n  ShaMapLeaf.prototype.hash = function () {\n    var hash = hashes_1.Sha512Half.put(this.hashPrefix());\n    this.toBytesSink(hash);\n    return hash.finish();\n  };\n  /**\n   * Write the bytes representation of this to a BytesList\n   * @param list BytesList to write bytes to\n   */\n\n\n  ShaMapLeaf.prototype.toBytesSink = function (list) {\n    if (this.item !== undefined) {\n      this.item.toBytesSink(list);\n    }\n\n    this.index.toBytesSink(list);\n  };\n\n  return ShaMapLeaf;\n}(ShaMapNode);\n\nexports.ShaMapLeaf = ShaMapLeaf;\n/**\n * Class defining an Inner Node of a SHAMap\n */\n\nvar ShaMapInner =\n/** @class */\nfunction (_super) {\n  __extends(ShaMapInner, _super);\n\n  function ShaMapInner(depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.depth = depth;\n    _this.slotBits = 0;\n    _this.branches = Array(16);\n    return _this;\n  }\n  /**\n   * @returns true as ShaMapInner is an inner node\n   */\n\n\n  ShaMapInner.prototype.isInner = function () {\n    return true;\n  };\n  /**\n   * @returns false as ShaMapInner is not a leaf node\n   */\n\n\n  ShaMapInner.prototype.isLeaf = function () {\n    return false;\n  };\n  /**\n   * Get the hash prefix for this node\n   *\n   * @returns hash prefix describing an inner node\n   */\n\n\n  ShaMapInner.prototype.hashPrefix = function () {\n    return hash_prefixes_1.HashPrefix.innerNode;\n  };\n  /**\n   * Set a branch of this node to be another node\n   *\n   * @param slot Slot to add branch to this.branches\n   * @param branch Branch to add\n   */\n\n\n  ShaMapInner.prototype.setBranch = function (slot, branch) {\n    this.slotBits = this.slotBits | 1 << slot;\n    this.branches[slot] = branch;\n  };\n  /**\n   * @returns true if node is empty\n   */\n\n\n  ShaMapInner.prototype.empty = function () {\n    return this.slotBits === 0;\n  };\n  /**\n   * Compute the hash of this node\n   *\n   * @returns The hash of this node\n   */\n\n\n  ShaMapInner.prototype.hash = function () {\n    if (this.empty()) {\n      return types_1.coreTypes.Hash256.ZERO_256;\n    }\n\n    var hash = hashes_1.Sha512Half.put(this.hashPrefix());\n    this.toBytesSink(hash);\n    return hash.finish();\n  };\n  /**\n   * Writes the bytes representation of this node to a BytesList\n   *\n   * @param list BytesList to write bytes to\n   */\n\n\n  ShaMapInner.prototype.toBytesSink = function (list) {\n    for (var i = 0; i < this.branches.length; i++) {\n      var branch = this.branches[i];\n      var hash = branch ? branch.hash() : types_1.coreTypes.Hash256.ZERO_256;\n      hash.toBytesSink(list);\n    }\n  };\n  /**\n   * Add item to the SHAMap\n   *\n   * @param index Hash of the index of the item being inserted\n   * @param item Item to insert in the map\n   * @param leaf Leaf node to insert when branch doesn't exist\n   */\n\n\n  ShaMapInner.prototype.addItem = function (index, item, leaf) {\n    assert_1.strict.ok(index !== undefined);\n    var nibble = index.nibblet(this.depth);\n    var existing = this.branches[nibble];\n\n    if (existing === undefined) {\n      this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));\n    } else if (existing instanceof ShaMapLeaf) {\n      var newInner = new ShaMapInner(this.depth + 1);\n      newInner.addItem(existing.index, undefined, existing);\n      newInner.addItem(index, item, leaf);\n      this.setBranch(nibble, newInner);\n    } else if (existing instanceof ShaMapInner) {\n      existing.addItem(index, item, leaf);\n    } else {\n      throw new Error('invalid ShaMap.addItem call');\n    }\n  };\n\n  return ShaMapInner;\n}(ShaMapNode);\n\nvar ShaMap =\n/** @class */\nfunction (_super) {\n  __extends(ShaMap, _super);\n\n  function ShaMap() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return ShaMap;\n}(ShaMapInner);\n\nexports.ShaMap = ShaMap;","map":{"version":3,"mappings":"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","names":["exports","__extends","index","item","_super","_this","ShaMapLeaf","undefined","buffer_1","alloc","hashPrefix","hash","hashes_1","put","toBytesSink","finish","list","ShaMapNode","depth","Array","ShaMapInner","hash_prefixes_1","innerNode","slot","branch","slotBits","branches","empty","types_1","Hash256","ZERO_256","i","length","leaf","assert_1","ok","nibble","nibblet","existing","setBranch","newInner","addItem","Error"],"sourceRoot":"","sources":["../src/shamap.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}