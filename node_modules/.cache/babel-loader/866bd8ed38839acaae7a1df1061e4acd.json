{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prepareXrpSignedOffchainTransaction = exports.signXrpOffchainKMSTransaction = exports.sendXrpOffchainTransaction = void 0;\n\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nconst ripple_lib_1 = require(\"ripple-lib\");\n\nconst blockchain_1 = require(\"../blockchain\");\n\nconst tatum_1 = require(\"../connector/tatum\");\n\nconst model_1 = require(\"../model\");\n\nconst common_1 = require(\"./common\");\n/**\n * Send Xrp transaction from Tatum Ledger account to the blockchain. This method broadcasts signed transaction to the blockchain.\n * This operation is irreversible.\n * @param testnet mainnet or testnet version\n * @param body content of the transaction to broadcast\n * @returns transaction id of the transaction in the blockchain or id of the withdrawal, if it was not cancelled automatically\n */\n\n\nconst sendXrpOffchainTransaction = async (testnet, body) => {\n  await tatum_1.validateBody(body, model_1.TransferXrpOffchain);\n\n  const {\n    account,\n    secret\n  } = body,\n        withdrawal = __rest(body, [\"account\", \"secret\"]);\n\n  if (!withdrawal.fee) {\n    withdrawal.fee = new bignumber_js_1.default((await blockchain_1.xrpGetFee()).drops.base_fee).dividedBy(1000000).toString();\n  }\n\n  const acc = await blockchain_1.xrpGetAccountInfo(account);\n  const {\n    id\n  } = await common_1.offchainStoreWithdrawal(withdrawal);\n  const {\n    amount,\n    fee,\n    address\n  } = withdrawal;\n  let txData;\n\n  try {\n    txData = await exports.prepareXrpSignedOffchainTransaction(testnet, amount, address, secret, acc, fee, withdrawal.sourceTag, withdrawal.attr);\n  } catch (e) {\n    console.error(e);\n    await common_1.offchainCancelWithdrawal(id);\n    throw e;\n  }\n\n  try {\n    return Object.assign(Object.assign({}, await common_1.offchainBroadcast({\n      txData,\n      withdrawalId: id,\n      currency: model_1.Currency.XRP\n    })), {\n      id\n    });\n  } catch (e) {\n    console.error(e);\n\n    try {\n      await common_1.offchainCancelWithdrawal(id);\n    } catch (e1) {\n      console.log(e);\n      return {\n        id\n      };\n    }\n\n    throw e;\n  }\n};\n\nexports.sendXrpOffchainTransaction = sendXrpOffchainTransaction;\n/**\n * Sign Xrp pending transaction from Tatum KMS\n * @param tx pending transaction from KMS\n * @param secret secret key to sign transaction with.\n * @returns transaction data to be broadcast to blockchain.\n */\n\nconst signXrpOffchainKMSTransaction = async (tx, secret) => {\n  if (tx.chain !== model_1.Currency.XRP) {\n    throw Error('Unsupported chain.');\n  }\n\n  const rippleAPI = new ripple_lib_1.RippleAPI();\n  return rippleAPI.sign(tx.serializedTransaction, secret).signedTransaction;\n};\n\nexports.signXrpOffchainKMSTransaction = signXrpOffchainKMSTransaction;\n/**\n * Sign Xrp transaction with private keys locally. Nothing is broadcast to the blockchain.\n * @param testnet mainnet or testnet version\n * @param amount amount to send\n * @param address recipient address\n * @param secret secret to sign transaction with\n * @param account Xrp source account\n * @param fee fee to pay\n * @param sourceTag source tag to include in transaction\n * @param destinationTag\n * @returns transaction data to be broadcast to blockchain.\n */\n\nconst prepareXrpSignedOffchainTransaction = async (testnet, amount, address, secret, account, fee, sourceTag, destinationTag) => {\n  const currency = 'XRP';\n  const payment = {\n    source: {\n      address: account.account_data.Account,\n      maxAmount: {\n        currency,\n        value: amount\n      },\n      tag: sourceTag\n    },\n    destination: {\n      address,\n      amount: {\n        currency,\n        value: amount\n      }\n    }\n  };\n\n  if (destinationTag) {\n    payment.destination.tag = parseInt(destinationTag);\n  }\n\n  const rippleAPI = new ripple_lib_1.RippleAPI();\n  const prepared = await rippleAPI.preparePayment(account.account_data.Account, payment, {\n    fee: `${fee}`,\n    sequence: account.account_data.Sequence,\n    maxLedgerVersion: (account.ledger_current_index || account.ledger_index) + 500\n  });\n  return (await rippleAPI.sign(prepared.txJSON, secret)).signedTransaction;\n};\n\nexports.prepareXrpSignedOffchainTransaction = prepareXrpSignedOffchainTransaction;","map":{"version":3,"mappings":"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","names":["sendXrpOffchainTransaction","testnet","body","tatum_1","model_1","account","secret","withdrawal","fee","bignumber_js_1","blockchain_1","drops","base_fee","dividedBy","toString","acc","id","common_1","amount","address","txData","exports","sourceTag","attr","e","console","error","withdrawalId","currency","XRP","e1","log","signXrpOffchainKMSTransaction","tx","chain","Error","rippleAPI","ripple_lib_1","sign","serializedTransaction","signedTransaction","prepareXrpSignedOffchainTransaction","destinationTag","payment","source","account_data","Account","maxAmount","value","tag","destination","parseInt","prepared","preparePayment","sequence","Sequence","maxLedgerVersion","ledger_current_index","ledger_index","txJSON"],"sourceRoot":"","sources":["../../../src/offchain/xrp.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}