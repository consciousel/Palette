{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeExpressionParser = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst types_1 = require(\"./types\");\n\nvar jsonHandler = require(\"json-duplicate-key-handle\");\n\nclass TypeExpressionParser {\n  parse(expression) {\n    let root = this.doParse(expression);\n    let rootKeys = Object.keys(root);\n\n    if (rootKeys.length != 1) {\n      throw new errors.ErrTypingSystem(`bad type expression: ${expression}`);\n    }\n\n    let name = rootKeys[0];\n    let type = this.nodeToType(name, root[name]);\n    return type;\n  }\n\n  doParse(expression) {\n    let jsoned = this.getJsonedString(expression);\n\n    try {\n      return jsonHandler.parse(jsoned);\n    } catch (error) {\n      throw new errors.ErrTypingSystem(`cannot parse type expression: ${expression}. internal json: ${jsoned}.`);\n    }\n  }\n  /**\n   * Converts a raw type expression to a JSON, parsing-friendly format.\n   * This is a workaround, so that the parser implementation is simpler (thus we actually rely on the JSON parser).\n   *\n   * @param expression a string such as:\n   *\n   * ```\n   *  - Option<List<Address>>\n   *  - VarArgs<MultiArg2<bytes, Address>>\n   *  - MultiResultVec<MultiResult2<Address, u64>\n   * ```\n   */\n\n\n  getJsonedString(expression) {\n    let jsoned = \"\";\n\n    for (var i = 0; i < expression.length; i++) {\n      let char = expression.charAt(i);\n      let previousChar = expression.charAt(i - 1);\n      let nextChar = expression.charAt(i + 1);\n\n      if (char == \"<\") {\n        jsoned += \": {\";\n      } else if (char == \">\") {\n        if (previousChar != \">\") {\n          jsoned += \": {} }\";\n        } else {\n          jsoned += \"}\";\n        }\n      } else if (char == \",\") {\n        if (nextChar == \">\") {// Skip superfluous comma\n        } else {\n          jsoned += \": {},\";\n        }\n      } else {\n        jsoned += char;\n      }\n    } // Split by the delimiters, but exclude the spaces that are found in the middle of \"utf-8 string\"\n\n\n    let symbolsRegex = /(:|\\{|\\}|,|\\s)/;\n    let tokens = jsoned // Hack for Safari compatibility, where we can't use negative lookbehind\n    .replace(/utf\\-8\\sstring/ig, \"utf-8-string\").split(symbolsRegex).filter(token => token);\n    jsoned = tokens.map(token => symbolsRegex.test(token) ? token : `\"${token}\"`).map(token => token.replace(/utf\\-8\\-string/ig, \"utf-8 string\")).join(\"\");\n\n    if (tokens.length == 1) {\n      // Workaround for simple, non-generic types.\n      return `{${jsoned}: {}}`;\n    }\n\n    return `{${jsoned}}`;\n  }\n\n  nodeToType(name, node) {\n    if (name.charAt(name.length - 1) === \"1\") {\n      name = name.slice(0, -1);\n    }\n\n    let typeParameters = Object.keys(node).map(key => this.nodeToType(key, node[key]));\n    return new types_1.Type(name, typeParameters);\n  }\n\n}\n\nexports.TypeExpressionParser = TypeExpressionParser;","map":{"version":3,"mappings":"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","names":["jsonHandler","require","TypeExpressionParser","parse","expression","root","doParse","rootKeys","Object","keys","length","errors","ErrTypingSystem","name","type","nodeToType","jsoned","getJsonedString","error","i","char","charAt","previousChar","nextChar","symbolsRegex","tokens","replace","split","filter","token","map","test","join","node","slice","typeParameters","key","types_1","exports"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/typeExpressionParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}