{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\n\nconst assert = require(\"assert\");\n\nconst xrp_codec_1 = require(\"./xrp-codec\");\n\nObject.defineProperty(exports, \"codec\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.codec;\n  }\n});\nObject.defineProperty(exports, \"encodeSeed\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeSeed;\n  }\n});\nObject.defineProperty(exports, \"decodeSeed\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeSeed;\n  }\n});\nObject.defineProperty(exports, \"encodeAccountID\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeAccountID;\n  }\n});\nObject.defineProperty(exports, \"decodeAccountID\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeAccountID;\n  }\n});\nObject.defineProperty(exports, \"encodeNodePublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeNodePublic;\n  }\n});\nObject.defineProperty(exports, \"decodeNodePublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeNodePublic;\n  }\n});\nObject.defineProperty(exports, \"encodeAccountPublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeAccountPublic;\n  }\n});\nObject.defineProperty(exports, \"decodeAccountPublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeAccountPublic;\n  }\n});\nObject.defineProperty(exports, \"isValidClassicAddress\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.isValidClassicAddress;\n  }\n});\nconst PREFIX_BYTES = {\n  // 5, 68\n  main: Buffer.from([0x05, 0x44]),\n  // 4, 147\n  test: Buffer.from([0x04, 0x93])\n};\nconst MAX_32_BIT_UNSIGNED_INT = 4294967295;\n\nfunction classicAddressToXAddress(classicAddress, tag, test) {\n  const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);\n  return encodeXAddress(accountId, tag, test);\n}\n\nexports.classicAddressToXAddress = classicAddressToXAddress;\n\nfunction encodeXAddress(accountId, tag, test) {\n  if (accountId.length !== 20) {\n    // RIPEMD160 is 160 bits = 20 bytes\n    throw new Error('Account ID must be 20 bytes');\n  }\n\n  if (tag > MAX_32_BIT_UNSIGNED_INT) {\n    throw new Error('Invalid tag');\n  }\n\n  const theTag = tag || 0; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake\n\n  const flag = tag === false || tag == null ? 0 : 1;\n  /* eslint-disable no-bitwise ---\n   * need to use bitwise operations here */\n\n  const bytes = Buffer.concat([test ? PREFIX_BYTES.test : PREFIX_BYTES.main, accountId, Buffer.from([// 0x00 if no tag, 0x01 if 32-bit tag\n  flag, // first byte\n  theTag & 0xff, // second byte\n  theTag >> 8 & 0xff, // third byte\n  theTag >> 16 & 0xff, // fourth byte\n  theTag >> 24 & 0xff, 0, 0, 0, // four zero bytes (reserved for 64-bit tags)\n  0])]);\n  /* eslint-enable no-bitwise */\n\n  return xrp_codec_1.codec.encodeChecked(bytes);\n}\n\nexports.encodeXAddress = encodeXAddress;\n\nfunction xAddressToClassicAddress(xAddress) {\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n  const {\n    accountId,\n    tag,\n    test\n  } = decodeXAddress(xAddress);\n  /* eslint-enable @typescript-eslint/naming-convention */\n\n  const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);\n  return {\n    classicAddress,\n    tag,\n    test\n  };\n}\n\nexports.xAddressToClassicAddress = xAddressToClassicAddress;\n\nfunction decodeXAddress(xAddress) {\n  const decoded = xrp_codec_1.codec.decodeChecked(xAddress);\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n\n  const test = isBufferForTestAddress(decoded);\n  /* eslint-enable @typescript-eslint/naming-convention */\n\n  const accountId = decoded.slice(2, 22);\n  const tag = tagFromBuffer(decoded);\n  return {\n    accountId,\n    tag,\n    test\n  };\n}\n\nexports.decodeXAddress = decodeXAddress;\n\nfunction isBufferForTestAddress(buf) {\n  const decodedPrefix = buf.slice(0, 2);\n\n  if (PREFIX_BYTES.main.equals(decodedPrefix)) {\n    return false;\n  }\n\n  if (PREFIX_BYTES.test.equals(decodedPrefix)) {\n    return true;\n  }\n\n  throw new Error('Invalid X-address: bad prefix');\n}\n\nfunction tagFromBuffer(buf) {\n  const flag = buf[22];\n\n  if (flag >= 2) {\n    // No support for 64-bit tags at this time\n    throw new Error('Unsupported X-address');\n  }\n\n  if (flag === 1) {\n    // Little-endian to big-endian\n    return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;\n  }\n\n  assert.strictEqual(flag, 0, 'flag must be zero to indicate no tag');\n  assert.ok(Buffer.from('0000000000000000', 'hex').equals(buf.slice(23, 23 + 8)), 'remaining bytes must be zero');\n  return false;\n}\n\nfunction isValidXAddress(xAddress) {\n  try {\n    decodeXAddress(xAddress);\n  } catch (_error) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isValidXAddress = isValidXAddress;","map":{"version":3,"mappings":"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","names":["Object","enumerable","get","xrp_codec_1","PREFIX_BYTES","main","Buffer","from","test","MAX_32_BIT_UNSIGNED_INT","classicAddressToXAddress","classicAddress","tag","accountId","encodeXAddress","exports","length","Error","theTag","flag","bytes","concat","encodeChecked","xAddressToClassicAddress","xAddress","decodeXAddress","decoded","decodeChecked","isBufferForTestAddress","slice","tagFromBuffer","buf","decodedPrefix","equals","assert","strictEqual","ok","isValidXAddress","_error"],"sourceRoot":"","sources":["../src/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}