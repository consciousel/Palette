{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\n\nvar Base58 = require('./encoding/base58');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar Hash = require('./crypto/hash');\n\nvar HDPrivateKey = require('./hdprivatekey');\n\nvar HDKeyCache = require('./hdkeycache');\n\nvar Network = require('./networks');\n\nvar Point = require('./crypto/point');\n\nvar PublicKey = require('./publickey');\n\nvar bitcoreErrors = require('./errors');\n\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\n\nvar assert = require('assert');\n\nvar JSUtil = require('./util/js');\n\nvar BufferUtil = require('./util/buffer');\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\n\n\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidPath = function (arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n/**\n * WARNING: This method is deprecated. Use deriveChild instead.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\n\n\nHDPublicKey.prototype.derive = function (arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\n\n\nHDPublicKey.prototype.deriveChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPublicKey.prototype._deriveWithNumber = function (index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  var cached = HDKeyCache.get(this.xpubkey, index, false);\n\n  if (cached) {\n    return cached;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var publicKey;\n\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n  HDKeyCache.set(this.xpubkey, index, false, derived);\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function (path) {\n  /* jshint maxcomplexity: 8 */\n  if (path.includes(\"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n\n  var derived = indexes.reduce(function (prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n  return derived;\n};\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidSerialized = function (data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\n\n\nHDPublicKey.getSerializedError = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n\n    if (error) {\n      return error;\n    }\n  }\n\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n\n  return null;\n};\n\nHDPublicKey._validateNetwork = function (data, networkArg) {\n  var network = Network.get(networkArg);\n\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function (arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? BufferUtil.hexToBuffer(arg.publicKey) : BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart, HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.publicKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\n\n\nHDPublicKey.prototype._buildFromBuffers = function (arg) {\n  /* jshint maxcomplexity: 8 */\n\n  /* jshint maxstatements: 20 */\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, arg.publicKey];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = new Buffer(xpubkey);\n  var publicKey = new PublicKey(arg.publicKey, {\n    network: network\n  });\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function (name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(buff.length === size, name + ' has not the expected size: found ' + buff.length + ', expected ' + size);\n  };\n\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function (arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function (arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\n\n\nHDPublicKey.prototype.toString = function () {\n  return this.xpubkey;\n};\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\n\n\nHDPublicKey.prototype.inspect = function () {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\n\n\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\n\n\nHDPublicKey.fromBuffer = function (arg) {\n  return new HDPublicKey(arg);\n};\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\n\n\nHDPublicKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\nHDPublicKey.VersionStart = 0;\nHDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\nmodule.exports = HDPublicKey;","map":{"version":3,"sources":["C:/Users/masho/OneDrive/Desktop/Blockchain/Biconomy/Projects/NFT_minter/node_modules/bitcore-lib-doge/lib/hdpublickey.js"],"names":["_","require","$","BN","Base58","Base58Check","Hash","HDPrivateKey","HDKeyCache","Network","Point","PublicKey","bitcoreErrors","errors","hdErrors","HDPublicKey","assert","JSUtil","BufferUtil","arg","isString","isBuffer","error","getSerializedError","_buildFromSerialized","toString","ArgumentIsPrivateExtended","hdPublicKey","isObject","_buildFromPrivate","_buildFromObject","UnrecognizedArgument","MustSupplyArgument","isValidPath","indexes","_getDerivationIndexes","every","isNumber","Hardened","prototype","derive","hardened","deriveChild","_deriveWithNumber","_deriveFromString","InvalidDerivationArgument","index","InvalidIndexCantDeriveHardened","InvalidPath","cached","get","xpubkey","indexBuffer","integerAsBuffer","data","concat","publicKey","toBuffer","hash","sha512hmac","_buffers","chainCode","leftPart","fromBuffer","slice","size","fromPoint","getG","mul","add","point","e","derived","network","depth","parentFingerPrint","fingerPrint","childIndex","set","path","includes","reduce","prev","isValidSerialized","isNull","validCharacters","InvalidB58Char","decode","InvalidB58Checksum","length","DataSize","InvalidLength","isUndefined","_validateNetwork","version","integerFromBuffer","livenet","xprivkey","testnet","networkArg","InvalidNetworkArgument","VersionStart","VersionEnd","InvalidNetwork","args","clone","privateKey","pointToCompressed","undefined","checksum","_buildFromBuffers","buffers","integerAsSingleByteBuffer","hexToBuffer","decoded","DepthStart","DepthEnd","ParentFingerPrintStart","ParentFingerPrintEnd","ChildIndexStart","ChildIndexEnd","ChainCodeStart","ChainCodeEnd","PublicKeyStart","PublicKeyEnd","ChecksumStart","ChecksumEnd","_validateBufferArguments","defineImmutable","sequence","encode","Buffer","ParentFingerPrintSize","sha256ripemd160","integerFromSingleByteBuffer","checkBuffer","name","buff","VersionSize","DepthSize","ChildIndexSize","ChainCodeSize","PublicKeySize","CheckSumSize","fromString","checkArgument","fromObject","inspect","toObject","toJSON","bufferToHex","copy","RootElementAlias","SerializedByteSize","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAf;;AACA,IAAIC,CAAC,GAAGD,OAAO,CAAC,sBAAD,CAAf;;AAEA,IAAIE,EAAE,GAAGF,OAAO,CAAC,aAAD,CAAhB;;AACA,IAAIG,MAAM,GAAGH,OAAO,CAAC,mBAAD,CAApB;;AACA,IAAII,WAAW,GAAGJ,OAAO,CAAC,wBAAD,CAAzB;;AACA,IAAIK,IAAI,GAAGL,OAAO,CAAC,eAAD,CAAlB;;AACA,IAAIM,YAAY,GAAGN,OAAO,CAAC,gBAAD,CAA1B;;AACA,IAAIO,UAAU,GAAGP,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIQ,OAAO,GAAGR,OAAO,CAAC,YAAD,CAArB;;AACA,IAAIS,KAAK,GAAGT,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIU,SAAS,GAAGV,OAAO,CAAC,aAAD,CAAvB;;AAEA,IAAIW,aAAa,GAAGX,OAAO,CAAC,UAAD,CAA3B;;AACA,IAAIY,MAAM,GAAGD,aAAb;AACA,IAAIE,QAAQ,GAAGF,aAAa,CAACG,WAA7B;;AACA,IAAIC,MAAM,GAAGf,OAAO,CAAC,QAAD,CAApB;;AAEA,IAAIgB,MAAM,GAAGhB,OAAO,CAAC,WAAD,CAApB;;AACA,IAAIiB,UAAU,GAAGjB,OAAO,CAAC,eAAD,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASc,WAAT,CAAqBI,GAArB,EAA0B;AACxB;;AACA;AACA,MAAIA,GAAG,YAAYJ,WAAnB,EAAgC;AAC9B,WAAOI,GAAP;AACD;;AACD,MAAI,EAAE,gBAAgBJ,WAAlB,CAAJ,EAAoC;AAClC,WAAO,IAAIA,WAAJ,CAAgBI,GAAhB,CAAP;AACD;;AACD,MAAIA,GAAJ,EAAS;AACP,QAAInB,CAAC,CAACoB,QAAF,CAAWD,GAAX,KAAmBD,UAAU,CAACG,QAAX,CAAoBF,GAApB,CAAvB,EAAiD;AAC/C,UAAIG,KAAK,GAAGP,WAAW,CAACQ,kBAAZ,CAA+BJ,GAA/B,CAAZ;;AACA,UAAI,CAACG,KAAL,EAAY;AACV,eAAO,KAAKE,oBAAL,CAA0BL,GAA1B,CAAP;AACD,OAFD,MAEO,IAAID,UAAU,CAACG,QAAX,CAAoBF,GAApB,KAA4B,CAACJ,WAAW,CAACQ,kBAAZ,CAA+BJ,GAAG,CAACM,QAAJ,EAA/B,CAAjC,EAAiF;AACtF,eAAO,KAAKD,oBAAL,CAA0BL,GAAG,CAACM,QAAJ,EAA1B,CAAP;AACD,OAFM,MAEA;AACL,YAAIH,KAAK,YAAYR,QAAQ,CAACY,yBAA9B,EAAyD;AACvD,iBAAO,IAAInB,YAAJ,CAAiBY,GAAjB,EAAsBQ,WAA7B;AACD;;AACD,cAAML,KAAN;AACD;AACF,KAZD,MAYO;AACL,UAAItB,CAAC,CAAC4B,QAAF,CAAWT,GAAX,CAAJ,EAAqB;AACnB,YAAIA,GAAG,YAAYZ,YAAnB,EAAiC;AAC/B,iBAAO,KAAKsB,iBAAL,CAAuBV,GAAvB,CAAP;AACD,SAFD,MAEO;AACL,iBAAO,KAAKW,gBAAL,CAAsBX,GAAtB,CAAP;AACD;AACF,OAND,MAMO;AACL,cAAM,IAAIL,QAAQ,CAACiB,oBAAb,CAAkCZ,GAAlC,CAAN;AACD;AACF;AACF,GAxBD,MAwBO;AACL,UAAM,IAAIL,QAAQ,CAACkB,kBAAb,EAAN;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;;;AACAjB,WAAW,CAACkB,WAAZ,GAA0B,UAASd,GAAT,EAAc;AACtC,MAAInB,CAAC,CAACoB,QAAF,CAAWD,GAAX,CAAJ,EAAqB;AACnB,QAAIe,OAAO,GAAG3B,YAAY,CAAC4B,qBAAb,CAAmChB,GAAnC,CAAd;;AACA,WAAOe,OAAO,KAAK,IAAZ,IAAoBlC,CAAC,CAACoC,KAAF,CAAQF,OAAR,EAAiBnB,WAAW,CAACkB,WAA7B,CAA3B;AACD;;AAED,MAAIjC,CAAC,CAACqC,QAAF,CAAWlB,GAAX,CAAJ,EAAqB;AACnB,WAAOA,GAAG,IAAI,CAAP,IAAYA,GAAG,GAAGJ,WAAW,CAACuB,QAArC;AACD;;AAED,SAAO,KAAP;AACD,CAXD;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAvB,WAAW,CAACwB,SAAZ,CAAsBC,MAAtB,GAA+B,UAASrB,GAAT,EAAcsB,QAAd,EAAwB;AACrD,SAAO,KAAKC,WAAL,CAAiBvB,GAAjB,EAAsBsB,QAAtB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1B,WAAW,CAACwB,SAAZ,CAAsBG,WAAtB,GAAoC,UAASvB,GAAT,EAAcsB,QAAd,EAAwB;AAE1D,MAAIzC,CAAC,CAACqC,QAAF,CAAWlB,GAAX,CAAJ,EAAqB;AACnB,WAAO,KAAKwB,iBAAL,CAAuBxB,GAAvB,EAA4BsB,QAA5B,CAAP;AACD,GAFD,MAEO,IAAIzC,CAAC,CAACoB,QAAF,CAAWD,GAAX,CAAJ,EAAqB;AAC1B,WAAO,KAAKyB,iBAAL,CAAuBzB,GAAvB,CAAP;AACD,GAFM,MAEA;AACL,UAAM,IAAIL,QAAQ,CAAC+B,yBAAb,CAAuC1B,GAAvC,CAAN;AACD;AACF,CATD;;AAWAJ,WAAW,CAACwB,SAAZ,CAAsBI,iBAAtB,GAA0C,UAASG,KAAT,EAAgBL,QAAhB,EAA0B;AAClE,MAAIK,KAAK,IAAI/B,WAAW,CAACuB,QAArB,IAAiCG,QAArC,EAA+C;AAC7C,UAAM,IAAI3B,QAAQ,CAACiC,8BAAb,EAAN;AACD;;AACD,MAAID,KAAK,GAAG,CAAZ,EAAe;AACb,UAAM,IAAIhC,QAAQ,CAACkC,WAAb,CAAyBF,KAAzB,CAAN;AACD;;AACD,MAAIG,MAAM,GAAGzC,UAAU,CAAC0C,GAAX,CAAe,KAAKC,OAApB,EAA6BL,KAA7B,EAAoC,KAApC,CAAb;;AACA,MAAIG,MAAJ,EAAY;AACV,WAAOA,MAAP;AACD;;AAED,MAAIG,WAAW,GAAGlC,UAAU,CAACmC,eAAX,CAA2BP,KAA3B,CAAlB;AACA,MAAIQ,IAAI,GAAGpC,UAAU,CAACqC,MAAX,CAAkB,CAAC,KAAKC,SAAL,CAAeC,QAAf,EAAD,EAA4BL,WAA5B,CAAlB,CAAX;AACA,MAAIM,IAAI,GAAGpD,IAAI,CAACqD,UAAL,CAAgBL,IAAhB,EAAsB,KAAKM,QAAL,CAAcC,SAApC,CAAX;AACA,MAAIC,QAAQ,GAAG3D,EAAE,CAAC4D,UAAH,CAAcL,IAAI,CAACM,KAAL,CAAW,CAAX,EAAc,EAAd,CAAd,EAAiC;AAACC,IAAAA,IAAI,EAAE;AAAP,GAAjC,CAAf;AACA,MAAIJ,SAAS,GAAGH,IAAI,CAACM,KAAL,CAAW,EAAX,EAAe,EAAf,CAAhB;AAEA,MAAIR,SAAJ;;AACA,MAAI;AACFA,IAAAA,SAAS,GAAG7C,SAAS,CAACuD,SAAV,CAAoBxD,KAAK,CAACyD,IAAN,GAAaC,GAAb,CAAiBN,QAAjB,EAA2BO,GAA3B,CAA+B,KAAKb,SAAL,CAAec,KAA9C,CAApB,CAAZ;AACD,GAFD,CAEE,OAAOC,CAAP,EAAU;AACV,WAAO,KAAK5B,iBAAL,CAAuBG,KAAK,GAAG,CAA/B,CAAP;AACD;;AAED,MAAI0B,OAAO,GAAG,IAAIzD,WAAJ,CAAgB;AAC5B0D,IAAAA,OAAO,EAAE,KAAKA,OADc;AAE5BC,IAAAA,KAAK,EAAE,KAAKA,KAAL,GAAa,CAFQ;AAG5BC,IAAAA,iBAAiB,EAAE,KAAKC,WAHI;AAI5BC,IAAAA,UAAU,EAAE/B,KAJgB;AAK5Be,IAAAA,SAAS,EAAEA,SALiB;AAM5BL,IAAAA,SAAS,EAAEA;AANiB,GAAhB,CAAd;AAQAhD,EAAAA,UAAU,CAACsE,GAAX,CAAe,KAAK3B,OAApB,EAA6BL,KAA7B,EAAoC,KAApC,EAA2C0B,OAA3C;AACA,SAAOA,OAAP;AACD,CAnCD;;AAqCAzD,WAAW,CAACwB,SAAZ,CAAsBK,iBAAtB,GAA0C,UAASmC,IAAT,EAAe;AACvD;AACA,MAAIA,IAAI,CAACC,QAAL,CAAc,GAAd,CAAJ,EAAwB;AACtB,UAAM,IAAIlE,QAAQ,CAACiC,8BAAb,EAAN;AACD,GAFD,MAEO,IAAI,CAAChC,WAAW,CAACkB,WAAZ,CAAwB8C,IAAxB,CAAL,EAAoC;AACzC,UAAM,IAAIjE,QAAQ,CAACkC,WAAb,CAAyB+B,IAAzB,CAAN;AACD;;AAED,MAAI7C,OAAO,GAAG3B,YAAY,CAAC4B,qBAAb,CAAmC4C,IAAnC,CAAd;;AACA,MAAIP,OAAO,GAAGtC,OAAO,CAAC+C,MAAR,CAAe,UAASC,IAAT,EAAepC,KAAf,EAAsB;AACjD,WAAOoC,IAAI,CAACvC,iBAAL,CAAuBG,KAAvB,CAAP;AACD,GAFa,EAEX,IAFW,CAAd;AAIA,SAAO0B,OAAP;AACD,CAdD;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAzD,WAAW,CAACoE,iBAAZ,GAAgC,UAAS7B,IAAT,EAAemB,OAAf,EAAwB;AACtD,SAAOzE,CAAC,CAACoF,MAAF,CAASrE,WAAW,CAACQ,kBAAZ,CAA+B+B,IAA/B,EAAqCmB,OAArC,CAAT,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1D,WAAW,CAACQ,kBAAZ,GAAiC,UAAS+B,IAAT,EAAemB,OAAf,EAAwB;AACvD;;AACA;AACA,MAAI,EAAEzE,CAAC,CAACoB,QAAF,CAAWkC,IAAX,KAAoBpC,UAAU,CAACG,QAAX,CAAoBiC,IAApB,CAAtB,CAAJ,EAAsD;AACpD,WAAO,IAAIxC,QAAQ,CAACiB,oBAAb,CAAkC,2BAAlC,CAAP;AACD;;AACD,MAAI,CAAC3B,MAAM,CAACiF,eAAP,CAAuB/B,IAAvB,CAAL,EAAmC;AACjC,WAAO,IAAIzC,MAAM,CAACyE,cAAX,CAA0B,WAA1B,EAAuChC,IAAvC,CAAP;AACD;;AACD,MAAI;AACFA,IAAAA,IAAI,GAAGjD,WAAW,CAACkF,MAAZ,CAAmBjC,IAAnB,CAAP;AACD,GAFD,CAEE,OAAOiB,CAAP,EAAU;AACV,WAAO,IAAI1D,MAAM,CAAC2E,kBAAX,CAA8BlC,IAA9B,CAAP;AACD;;AACD,MAAIA,IAAI,CAACmC,MAAL,KAAgB1E,WAAW,CAAC2E,QAAhC,EAA0C;AACxC,WAAO,IAAI5E,QAAQ,CAAC6E,aAAb,CAA2BrC,IAA3B,CAAP;AACD;;AACD,MAAI,CAACtD,CAAC,CAAC4F,WAAF,CAAcnB,OAAd,CAAL,EAA6B;AAC3B,QAAInD,KAAK,GAAGP,WAAW,CAAC8E,gBAAZ,CAA6BvC,IAA7B,EAAmCmB,OAAnC,CAAZ;;AACA,QAAInD,KAAJ,EAAW;AACT,aAAOA,KAAP;AACD;AACF;;AACD,MAAIwE,OAAO,GAAG5E,UAAU,CAAC6E,iBAAX,CAA6BzC,IAAI,CAACU,KAAL,CAAW,CAAX,EAAc,CAAd,CAA7B,CAAd;;AACA,MAAI8B,OAAO,KAAKrF,OAAO,CAACuF,OAAR,CAAgBC,QAA5B,IAAwCH,OAAO,KAAKrF,OAAO,CAACyF,OAAR,CAAgBD,QAAxE,EAAmF;AACjF,WAAO,IAAInF,QAAQ,CAACY,yBAAb,EAAP;AACD;;AACD,SAAO,IAAP;AACD,CA5BD;;AA8BAX,WAAW,CAAC8E,gBAAZ,GAA+B,UAASvC,IAAT,EAAe6C,UAAf,EAA2B;AACxD,MAAI1B,OAAO,GAAGhE,OAAO,CAACyC,GAAR,CAAYiD,UAAZ,CAAd;;AACA,MAAI,CAAC1B,OAAL,EAAc;AACZ,WAAO,IAAI5D,MAAM,CAACuF,sBAAX,CAAkCD,UAAlC,CAAP;AACD;;AACD,MAAIL,OAAO,GAAGxC,IAAI,CAACU,KAAL,CAAWjD,WAAW,CAACsF,YAAvB,EAAqCtF,WAAW,CAACuF,UAAjD,CAAd;;AACA,MAAIpF,UAAU,CAAC6E,iBAAX,CAA6BD,OAA7B,MAA0CrB,OAAO,CAACtB,OAAtD,EAA+D;AAC7D,WAAO,IAAItC,MAAM,CAAC0F,cAAX,CAA0BT,OAA1B,CAAP;AACD;;AACD,SAAO,IAAP;AACD,CAVD;;AAYA/E,WAAW,CAACwB,SAAZ,CAAsBV,iBAAtB,GAA0C,UAAUV,GAAV,EAAe;AACvD,MAAIqF,IAAI,GAAGxG,CAAC,CAACyG,KAAF,CAAQtF,GAAG,CAACyC,QAAZ,CAAX;;AACA,MAAIU,KAAK,GAAG5D,KAAK,CAACyD,IAAN,GAAaC,GAAb,CAAiBjE,EAAE,CAAC4D,UAAH,CAAcyC,IAAI,CAACE,UAAnB,CAAjB,CAAZ;AACAF,EAAAA,IAAI,CAAChD,SAAL,GAAiB9C,KAAK,CAACiG,iBAAN,CAAwBrC,KAAxB,CAAjB;AACAkC,EAAAA,IAAI,CAACV,OAAL,GAAe5E,UAAU,CAACmC,eAAX,CAA2B5C,OAAO,CAACyC,GAAR,CAAYhC,UAAU,CAAC6E,iBAAX,CAA6BS,IAAI,CAACV,OAAlC,CAAZ,EAAwD3C,OAAnF,CAAf;AACAqD,EAAAA,IAAI,CAACE,UAAL,GAAkBE,SAAlB;AACAJ,EAAAA,IAAI,CAACK,QAAL,GAAgBD,SAAhB;AACAJ,EAAAA,IAAI,CAACP,QAAL,GAAgBW,SAAhB;AACA,SAAO,KAAKE,iBAAL,CAAuBN,IAAvB,CAAP;AACD,CATD;;AAWAzF,WAAW,CAACwB,SAAZ,CAAsBT,gBAAtB,GAAyC,UAASX,GAAT,EAAc;AACrD;AACA;AACA,MAAI4F,OAAO,GAAG;AACZjB,IAAAA,OAAO,EAAE3E,GAAG,CAACsD,OAAJ,GAAcvD,UAAU,CAACmC,eAAX,CAA2B5C,OAAO,CAACyC,GAAR,CAAY/B,GAAG,CAACsD,OAAhB,EAAyBtB,OAApD,CAAd,GAA6EhC,GAAG,CAAC2E,OAD9E;AAEZpB,IAAAA,KAAK,EAAE1E,CAAC,CAACqC,QAAF,CAAWlB,GAAG,CAACuD,KAAf,IAAwBxD,UAAU,CAAC8F,yBAAX,CAAqC7F,GAAG,CAACuD,KAAzC,CAAxB,GAA0EvD,GAAG,CAACuD,KAFzE;AAGZC,IAAAA,iBAAiB,EAAE3E,CAAC,CAACqC,QAAF,CAAWlB,GAAG,CAACwD,iBAAf,IAAoCzD,UAAU,CAACmC,eAAX,CAA2BlC,GAAG,CAACwD,iBAA/B,CAApC,GAAwFxD,GAAG,CAACwD,iBAHnG;AAIZE,IAAAA,UAAU,EAAE7E,CAAC,CAACqC,QAAF,CAAWlB,GAAG,CAAC0D,UAAf,IAA6B3D,UAAU,CAACmC,eAAX,CAA2BlC,GAAG,CAAC0D,UAA/B,CAA7B,GAA0E1D,GAAG,CAAC0D,UAJ9E;AAKZhB,IAAAA,SAAS,EAAE7D,CAAC,CAACoB,QAAF,CAAWD,GAAG,CAAC0C,SAAf,IAA4B3C,UAAU,CAAC+F,WAAX,CAAuB9F,GAAG,CAAC0C,SAA3B,CAA5B,GAAoE1C,GAAG,CAAC0C,SALvE;AAMZL,IAAAA,SAAS,EAAExD,CAAC,CAACoB,QAAF,CAAWD,GAAG,CAACqC,SAAf,IAA4BtC,UAAU,CAAC+F,WAAX,CAAuB9F,GAAG,CAACqC,SAA3B,CAA5B,GACTtC,UAAU,CAACG,QAAX,CAAoBF,GAAG,CAACqC,SAAxB,IAAqCrC,GAAG,CAACqC,SAAzC,GAAqDrC,GAAG,CAACqC,SAAJ,CAAcC,QAAd,EAP3C;AAQZoD,IAAAA,QAAQ,EAAE7G,CAAC,CAACqC,QAAF,CAAWlB,GAAG,CAAC0F,QAAf,IAA2B3F,UAAU,CAACmC,eAAX,CAA2BlC,GAAG,CAAC0F,QAA/B,CAA3B,GAAsE1F,GAAG,CAAC0F;AARxE,GAAd;AAUA,SAAO,KAAKC,iBAAL,CAAuBC,OAAvB,CAAP;AACD,CAdD;;AAgBAhG,WAAW,CAACwB,SAAZ,CAAsBf,oBAAtB,GAA6C,UAASL,GAAT,EAAc;AACzD,MAAI+F,OAAO,GAAG7G,WAAW,CAACkF,MAAZ,CAAmBpE,GAAnB,CAAd;AACA,MAAI4F,OAAO,GAAG;AACZjB,IAAAA,OAAO,EAAEoB,OAAO,CAAClD,KAAR,CAAcjD,WAAW,CAACsF,YAA1B,EAAwCtF,WAAW,CAACuF,UAApD,CADG;AAEZ5B,IAAAA,KAAK,EAAEwC,OAAO,CAAClD,KAAR,CAAcjD,WAAW,CAACoG,UAA1B,EAAsCpG,WAAW,CAACqG,QAAlD,CAFK;AAGZzC,IAAAA,iBAAiB,EAAEuC,OAAO,CAAClD,KAAR,CAAcjD,WAAW,CAACsG,sBAA1B,EACctG,WAAW,CAACuG,oBAD1B,CAHP;AAKZzC,IAAAA,UAAU,EAAEqC,OAAO,CAAClD,KAAR,CAAcjD,WAAW,CAACwG,eAA1B,EAA2CxG,WAAW,CAACyG,aAAvD,CALA;AAMZ3D,IAAAA,SAAS,EAAEqD,OAAO,CAAClD,KAAR,CAAcjD,WAAW,CAAC0G,cAA1B,EAA0C1G,WAAW,CAAC2G,YAAtD,CANC;AAOZlE,IAAAA,SAAS,EAAE0D,OAAO,CAAClD,KAAR,CAAcjD,WAAW,CAAC4G,cAA1B,EAA0C5G,WAAW,CAAC6G,YAAtD,CAPC;AAQZf,IAAAA,QAAQ,EAAEK,OAAO,CAAClD,KAAR,CAAcjD,WAAW,CAAC8G,aAA1B,EAAyC9G,WAAW,CAAC+G,WAArD,CARE;AASZ3E,IAAAA,OAAO,EAAEhC;AATG,GAAd;AAWA,SAAO,KAAK2F,iBAAL,CAAuBC,OAAvB,CAAP;AACD,CAdD;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAhG,WAAW,CAACwB,SAAZ,CAAsBuE,iBAAtB,GAA0C,UAAS3F,GAAT,EAAc;AACtD;;AACA;AAEAJ,EAAAA,WAAW,CAACgH,wBAAZ,CAAqC5G,GAArC;;AAEAF,EAAAA,MAAM,CAAC+G,eAAP,CAAuB,IAAvB,EAA6B;AAC3BpE,IAAAA,QAAQ,EAAEzC;AADiB,GAA7B;AAIA,MAAI8G,QAAQ,GAAG,CACb9G,GAAG,CAAC2E,OADS,EACA3E,GAAG,CAACuD,KADJ,EACWvD,GAAG,CAACwD,iBADf,EACkCxD,GAAG,CAAC0D,UADtC,EACkD1D,GAAG,CAAC0C,SADtD,EAEb1C,GAAG,CAACqC,SAFS,CAAf;AAIA,MAAID,MAAM,GAAGrC,UAAU,CAACqC,MAAX,CAAkB0E,QAAlB,CAAb;AACA,MAAIpB,QAAQ,GAAGxG,WAAW,CAACwG,QAAZ,CAAqBtD,MAArB,CAAf;;AACA,MAAI,CAACpC,GAAG,CAAC0F,QAAL,IAAiB,CAAC1F,GAAG,CAAC0F,QAAJ,CAAapB,MAAnC,EAA2C;AACzCtE,IAAAA,GAAG,CAAC0F,QAAJ,GAAeA,QAAf;AACD,GAFD,MAEO;AACL,QAAI1F,GAAG,CAAC0F,QAAJ,CAAapF,QAAb,CAAsB,KAAtB,MAAiCoF,QAAQ,CAACpF,QAAT,CAAkB,KAAlB,CAArC,EAA+D;AAC7D,YAAM,IAAIZ,MAAM,CAAC2E,kBAAX,CAA8BjC,MAA9B,EAAsCsD,QAAtC,CAAN;AACD;AACF;;AACD,MAAIpC,OAAO,GAAGhE,OAAO,CAACyC,GAAR,CAAYhC,UAAU,CAAC6E,iBAAX,CAA6B5E,GAAG,CAAC2E,OAAjC,CAAZ,CAAd;AAEA,MAAI3C,OAAJ;AACAA,EAAAA,OAAO,GAAG9C,WAAW,CAAC6H,MAAZ,CAAmBhH,UAAU,CAACqC,MAAX,CAAkB0E,QAAlB,CAAnB,CAAV;AACA9G,EAAAA,GAAG,CAACgC,OAAJ,GAAc,IAAIgF,MAAJ,CAAWhF,OAAX,CAAd;AAEA,MAAIK,SAAS,GAAG,IAAI7C,SAAJ,CAAcQ,GAAG,CAACqC,SAAlB,EAA6B;AAACiB,IAAAA,OAAO,EAAEA;AAAV,GAA7B,CAAhB;AACA,MAAIR,IAAI,GAAGlD,WAAW,CAACqH,qBAAvB;AACA,MAAIxD,WAAW,GAAGtE,IAAI,CAAC+H,eAAL,CAAqB7E,SAAS,CAACC,QAAV,EAArB,EAA2CO,KAA3C,CAAiD,CAAjD,EAAoDC,IAApD,CAAlB;AAEAhD,EAAAA,MAAM,CAAC+G,eAAP,CAAuB,IAAvB,EAA6B;AAC3B7E,IAAAA,OAAO,EAAEA,OADkB;AAE3BsB,IAAAA,OAAO,EAAEA,OAFkB;AAG3BC,IAAAA,KAAK,EAAExD,UAAU,CAACoH,2BAAX,CAAuCnH,GAAG,CAACuD,KAA3C,CAHoB;AAI3BlB,IAAAA,SAAS,EAAEA,SAJgB;AAK3BoB,IAAAA,WAAW,EAAEA;AALc,GAA7B;AAQA,SAAO,IAAP;AACD,CA1CD;;AA4CA7D,WAAW,CAACgH,wBAAZ,GAAuC,UAAS5G,GAAT,EAAc;AACnD,MAAIoH,WAAW,GAAG,UAASC,IAAT,EAAevE,IAAf,EAAqB;AACrC,QAAIwE,IAAI,GAAGtH,GAAG,CAACqH,IAAD,CAAd;AACAxH,IAAAA,MAAM,CAACE,UAAU,CAACG,QAAX,CAAoBoH,IAApB,CAAD,EAA4BD,IAAI,GAAG,mCAAP,GAA6C,OAAOC,IAAhF,CAAN;AACAzH,IAAAA,MAAM,CACJyH,IAAI,CAAChD,MAAL,KAAgBxB,IADZ,EAEJuE,IAAI,GAAG,oCAAP,GAA8CC,IAAI,CAAChD,MAAnD,GAA4D,aAA5D,GAA4ExB,IAFxE,CAAN;AAID,GAPD;;AAQAsE,EAAAA,WAAW,CAAC,SAAD,EAAYxH,WAAW,CAAC2H,WAAxB,CAAX;AACAH,EAAAA,WAAW,CAAC,OAAD,EAAUxH,WAAW,CAAC4H,SAAtB,CAAX;AACAJ,EAAAA,WAAW,CAAC,mBAAD,EAAsBxH,WAAW,CAACqH,qBAAlC,CAAX;AACAG,EAAAA,WAAW,CAAC,YAAD,EAAexH,WAAW,CAAC6H,cAA3B,CAAX;AACAL,EAAAA,WAAW,CAAC,WAAD,EAAcxH,WAAW,CAAC8H,aAA1B,CAAX;AACAN,EAAAA,WAAW,CAAC,WAAD,EAAcxH,WAAW,CAAC+H,aAA1B,CAAX;;AACA,MAAI3H,GAAG,CAAC0F,QAAJ,IAAgB1F,GAAG,CAAC0F,QAAJ,CAAapB,MAAjC,EAAyC;AACvC8C,IAAAA,WAAW,CAAC,UAAD,EAAaxH,WAAW,CAACgI,YAAzB,CAAX;AACD;AACF,CAlBD;;AAoBAhI,WAAW,CAACiI,UAAZ,GAAyB,UAAS7H,GAAT,EAAc;AACrCjB,EAAAA,CAAC,CAAC+I,aAAF,CAAgBjJ,CAAC,CAACoB,QAAF,CAAWD,GAAX,CAAhB,EAAiC,8BAAjC;AACA,SAAO,IAAIJ,WAAJ,CAAgBI,GAAhB,CAAP;AACD,CAHD;;AAKAJ,WAAW,CAACmI,UAAZ,GAAyB,UAAS/H,GAAT,EAAc;AACrCjB,EAAAA,CAAC,CAAC+I,aAAF,CAAgBjJ,CAAC,CAAC4B,QAAF,CAAWT,GAAX,CAAhB,EAAiC,gCAAjC;AACA,SAAO,IAAIJ,WAAJ,CAAgBI,GAAhB,CAAP;AACD,CAHD;AAKA;AACA;AACA;AACA;;;AACAJ,WAAW,CAACwB,SAAZ,CAAsBd,QAAtB,GAAiC,YAAW;AAC1C,SAAO,KAAK0B,OAAZ;AACD,CAFD;AAIA;AACA;AACA;AACA;;;AACApC,WAAW,CAACwB,SAAZ,CAAsB4G,OAAtB,GAAgC,YAAW;AACzC,SAAO,mBAAmB,KAAKhG,OAAxB,GAAkC,GAAzC;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACApC,WAAW,CAACwB,SAAZ,CAAsB6G,QAAtB,GAAiCrI,WAAW,CAACwB,SAAZ,CAAsB8G,MAAtB,GAA+B,SAASD,QAAT,GAAoB;AAClF,SAAO;AACL3E,IAAAA,OAAO,EAAEhE,OAAO,CAACyC,GAAR,CAAYhC,UAAU,CAAC6E,iBAAX,CAA6B,KAAKnC,QAAL,CAAckC,OAA3C,CAAZ,EAAiE0C,IADrE;AAEL9D,IAAAA,KAAK,EAAExD,UAAU,CAACoH,2BAAX,CAAuC,KAAK1E,QAAL,CAAcc,KAArD,CAFF;AAGLE,IAAAA,WAAW,EAAE1D,UAAU,CAAC6E,iBAAX,CAA6B,KAAKnB,WAAlC,CAHR;AAILD,IAAAA,iBAAiB,EAAEzD,UAAU,CAAC6E,iBAAX,CAA6B,KAAKnC,QAAL,CAAce,iBAA3C,CAJd;AAKLE,IAAAA,UAAU,EAAE3D,UAAU,CAAC6E,iBAAX,CAA6B,KAAKnC,QAAL,CAAciB,UAA3C,CALP;AAMLhB,IAAAA,SAAS,EAAE3C,UAAU,CAACoI,WAAX,CAAuB,KAAK1F,QAAL,CAAcC,SAArC,CANN;AAOLL,IAAAA,SAAS,EAAE,KAAKA,SAAL,CAAe/B,QAAf,EAPN;AAQLoF,IAAAA,QAAQ,EAAE3F,UAAU,CAAC6E,iBAAX,CAA6B,KAAKnC,QAAL,CAAciD,QAA3C,CARL;AASL1D,IAAAA,OAAO,EAAE,KAAKA;AATT,GAAP;AAWD,CAZD;AAcA;AACA;AACA;AACA;AACA;AACA;;;AACApC,WAAW,CAACgD,UAAZ,GAAyB,UAAS5C,GAAT,EAAc;AACrC,SAAO,IAAIJ,WAAJ,CAAgBI,GAAhB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACAJ,WAAW,CAACwB,SAAZ,CAAsBkB,QAAtB,GAAiC,YAAW;AAC1C,SAAOvC,UAAU,CAACqI,IAAX,CAAgB,KAAK3F,QAAL,CAAcT,OAA9B,CAAP;AACD,CAFD;;AAIApC,WAAW,CAACuB,QAAZ,GAAuB,UAAvB;AACAvB,WAAW,CAACyI,gBAAZ,GAA+B,CAAC,GAAD,EAAM,GAAN,CAA/B;AAEAzI,WAAW,CAAC2H,WAAZ,GAA0B,CAA1B;AACA3H,WAAW,CAAC4H,SAAZ,GAAwB,CAAxB;AACA5H,WAAW,CAACqH,qBAAZ,GAAoC,CAApC;AACArH,WAAW,CAAC6H,cAAZ,GAA6B,CAA7B;AACA7H,WAAW,CAAC8H,aAAZ,GAA4B,EAA5B;AACA9H,WAAW,CAAC+H,aAAZ,GAA4B,EAA5B;AACA/H,WAAW,CAACgI,YAAZ,GAA2B,CAA3B;AAEAhI,WAAW,CAAC2E,QAAZ,GAAuB,EAAvB;AACA3E,WAAW,CAAC0I,kBAAZ,GAAiC,EAAjC;AAEA1I,WAAW,CAACsF,YAAZ,GAAqC,CAArC;AACAtF,WAAW,CAACuF,UAAZ,GAAqCvF,WAAW,CAACsF,YAAZ,GAA2BtF,WAAW,CAAC2H,WAA5E;AACA3H,WAAW,CAACoG,UAAZ,GAAqCpG,WAAW,CAACuF,UAAjD;AACAvF,WAAW,CAACqG,QAAZ,GAAqCrG,WAAW,CAACoG,UAAZ,GAAyBpG,WAAW,CAAC4H,SAA1E;AACA5H,WAAW,CAACsG,sBAAZ,GAAqCtG,WAAW,CAACqG,QAAjD;AACArG,WAAW,CAACuG,oBAAZ,GAAqCvG,WAAW,CAACsG,sBAAZ,GAAqCtG,WAAW,CAACqH,qBAAtF;AACArH,WAAW,CAACwG,eAAZ,GAAqCxG,WAAW,CAACuG,oBAAjD;AACAvG,WAAW,CAACyG,aAAZ,GAAqCzG,WAAW,CAACwG,eAAZ,GAA8BxG,WAAW,CAAC6H,cAA/E;AACA7H,WAAW,CAAC0G,cAAZ,GAAqC1G,WAAW,CAACyG,aAAjD;AACAzG,WAAW,CAAC2G,YAAZ,GAAqC3G,WAAW,CAAC0G,cAAZ,GAA6B1G,WAAW,CAAC8H,aAA9E;AACA9H,WAAW,CAAC4G,cAAZ,GAAqC5G,WAAW,CAAC2G,YAAjD;AACA3G,WAAW,CAAC6G,YAAZ,GAAqC7G,WAAW,CAAC4G,cAAZ,GAA6B5G,WAAW,CAAC+H,aAA9E;AACA/H,WAAW,CAAC8G,aAAZ,GAAqC9G,WAAW,CAAC6G,YAAjD;AACA7G,WAAW,CAAC+G,WAAZ,GAAqC/G,WAAW,CAAC8G,aAAZ,GAA4B9G,WAAW,CAACgI,YAA7E;AAEA/H,MAAM,CAACD,WAAW,CAAC6G,YAAZ,KAA6B7G,WAAW,CAAC2E,QAA1C,CAAN;AACA1E,MAAM,CAACD,WAAW,CAAC+G,WAAZ,KAA4B/G,WAAW,CAAC0I,kBAAzC,CAAN;AAEAC,MAAM,CAACC,OAAP,GAAiB5I,WAAjB","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar HDPrivateKey = require('./hdprivatekey');\nvar HDKeyCache = require('./hdkeycache');\nvar Network = require('./networks');\nvar Point = require('./crypto/point');\nvar PublicKey = require('./publickey');\n\nvar bitcoreErrors = require('./errors');\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\nvar assert = require('assert');\n\nvar JSUtil = require('./util/js');\nvar BufferUtil = require('./util/buffer');\n\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\nHDPublicKey.isValidPath = function(arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild instead.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.derive = function(arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.deriveChild = function(arg, hardened) {\n\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPublicKey.prototype._deriveWithNumber = function(index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n  var cached = HDKeyCache.get(this.xpubkey, index, false);\n  if (cached) {\n    return cached;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});\n  var chainCode = hash.slice(32, 64);\n\n  var publicKey;\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n  HDKeyCache.set(this.xpubkey, index, false, derived);\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function(path) {\n  /* jshint maxcomplexity: 8 */\n  if (path.includes(\"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPublicKey.isValidSerialized = function(data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\nHDPublicKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n  return null;\n};\n\nHDPublicKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? BufferUtil.hexToBuffer(arg.publicKey) :\n      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,\n                                     HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.publicKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\nHDPublicKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    arg.publicKey\n  ];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = new Buffer(xpubkey);\n\n  var publicKey = new PublicKey(arg.publicKey, {network: network});\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\nHDPublicKey.prototype.toString = function() {\n  return this.xpubkey;\n};\n\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\nHDPublicKey.prototype.inspect = function() {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\nHDPublicKey.fromBuffer = function(arg) {\n  return new HDPublicKey(arg);\n};\n\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\nHDPublicKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\n\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\n\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\n\nHDPublicKey.VersionStart           = 0;\nHDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart             = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\n\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\n\nmodule.exports = HDPublicKey;\n"]},"metadata":{},"sourceType":"script"}