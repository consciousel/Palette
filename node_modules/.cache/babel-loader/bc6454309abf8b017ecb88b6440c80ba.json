{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SHAMap = exports.Leaf = exports.InnerNode = exports.Node = exports.NodeType = void 0;\n\nconst hash_prefix_1 = __importDefault(require(\"./hash-prefix\"));\n\nconst sha512Half_1 = __importDefault(require(\"./sha512Half\"));\n\nconst HEX_ZERO = '0000000000000000000000000000000000000000000000000000000000000000';\nvar NodeType;\n\n(function (NodeType) {\n  NodeType[NodeType[\"INNER\"] = 1] = \"INNER\";\n  NodeType[NodeType[\"TRANSACTION_NO_METADATA\"] = 2] = \"TRANSACTION_NO_METADATA\";\n  NodeType[NodeType[\"TRANSACTION_METADATA\"] = 3] = \"TRANSACTION_METADATA\";\n  NodeType[NodeType[\"ACCOUNT_STATE\"] = 4] = \"ACCOUNT_STATE\";\n})(NodeType = exports.NodeType || (exports.NodeType = {}));\n\nclass Node {\n  constructor() {}\n\n  addItem(_tag, _node) {\n    throw new Error('Called unimplemented virtual method SHAMapTreeNode#addItem.');\n  }\n\n  get hash() {\n    throw new Error('Called unimplemented virtual method SHAMapTreeNode#hash.');\n  }\n\n}\n\nexports.Node = Node;\n\nclass InnerNode extends Node {\n  constructor() {\n    let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    super();\n    this.leaves = {};\n    this.type = NodeType.INNER;\n    this.depth = depth;\n    this.empty = true;\n  }\n\n  addItem(tag, node) {\n    const existingNode = this.getNode(parseInt(tag[this.depth], 16));\n\n    if (existingNode) {\n      if (existingNode instanceof InnerNode) {\n        existingNode.addItem(tag, node);\n      } else if (existingNode instanceof Leaf) {\n        if (existingNode.tag === tag) {\n          throw new Error('Tried to add a node to a SHAMap that was already in there.');\n        } else {\n          const newInnerNode = new InnerNode(this.depth + 1);\n          newInnerNode.addItem(existingNode.tag, existingNode);\n          newInnerNode.addItem(tag, node);\n          this.setNode(parseInt(tag[this.depth], 16), newInnerNode);\n        }\n      }\n    } else {\n      this.setNode(parseInt(tag[this.depth], 16), node);\n    }\n  }\n\n  setNode(slot, node) {\n    if (slot < 0 || slot > 15) {\n      throw new Error('Invalid slot: slot must be between 0-15.');\n    }\n\n    this.leaves[slot] = node;\n    this.empty = false;\n  }\n\n  getNode(slot) {\n    if (slot < 0 || slot > 15) {\n      throw new Error('Invalid slot: slot must be between 0-15.');\n    }\n\n    return this.leaves[slot];\n  }\n\n  get hash() {\n    if (this.empty) return HEX_ZERO;\n    let hex = '';\n\n    for (let i = 0; i < 16; i++) {\n      hex += this.leaves[i] ? this.leaves[i].hash : HEX_ZERO;\n    }\n\n    const prefix = hash_prefix_1.default.INNER_NODE.toString(16);\n    return sha512Half_1.default(prefix + hex);\n  }\n\n}\n\nexports.InnerNode = InnerNode;\n\nclass Leaf extends Node {\n  constructor(tag, data, type) {\n    super();\n    this.tag = tag;\n    this.type = type;\n    this.data = data;\n  }\n\n  get hash() {\n    switch (this.type) {\n      case NodeType.ACCOUNT_STATE:\n        {\n          const leafPrefix = hash_prefix_1.default.LEAF_NODE.toString(16);\n          return sha512Half_1.default(leafPrefix + this.data + this.tag);\n        }\n\n      case NodeType.TRANSACTION_NO_METADATA:\n        {\n          const txIDPrefix = hash_prefix_1.default.TRANSACTION_ID.toString(16);\n          return sha512Half_1.default(txIDPrefix + this.data);\n        }\n\n      case NodeType.TRANSACTION_METADATA:\n        {\n          const txNodePrefix = hash_prefix_1.default.TRANSACTION_NODE.toString(16);\n          return sha512Half_1.default(txNodePrefix + this.data + this.tag);\n        }\n\n      default:\n        throw new Error('Tried to hash a SHAMap node of unknown type.');\n    }\n  }\n\n}\n\nexports.Leaf = Leaf;\n\nclass SHAMap {\n  constructor() {\n    this.root = new InnerNode(0);\n  }\n\n  addItem(tag, data, type) {\n    this.root.addItem(tag, new Leaf(tag, data, type));\n  }\n\n  get hash() {\n    return this.root.hash;\n  }\n\n}\n\nexports.SHAMap = SHAMap;","map":{"version":3,"mappings":"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","names":["HEX_ZERO","NodeType","exports","Node","constructor","addItem","_tag","_node","Error","hash","InnerNode","depth","leaves","type","INNER","empty","tag","node","existingNode","getNode","parseInt","Leaf","newInnerNode","setNode","slot","hex","i","prefix","hash_prefix_1","INNER_NODE","toString","sha512Half_1","data","ACCOUNT_STATE","leafPrefix","LEAF_NODE","TRANSACTION_NO_METADATA","txIDPrefix","TRANSACTION_ID","TRANSACTION_METADATA","txNodePrefix","TRANSACTION_NODE","SHAMap","root"],"sourceRoot":"","sources":["../../../../src/common/hashes/shamap.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}