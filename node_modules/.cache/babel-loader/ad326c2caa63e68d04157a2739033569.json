{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\n\nconst codec_1 = require(\"./codec\");\n\nconst composite_1 = require(\"./typesystem/composite\");\n\nconst variadic_1 = require(\"./typesystem/variadic\");\n\nconst algebraic_1 = require(\"./typesystem/algebraic\");\n\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\n\nconst Codec = new codec_1.BinaryCodec();\n\nclass ArgSerializer {\n  /**\n   * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n   */\n  stringToValues(joinedString, parameters) {\n    let buffers = this.stringToBuffers(joinedString);\n    let values = this.buffersToValues(buffers, parameters);\n    return values;\n  }\n  /**\n   * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n   */\n\n\n  stringToBuffers(joinedString) {\n    // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n    return joinedString.split(exports.ArgumentsSeparator).map(item => Buffer.from(item, \"hex\"));\n  }\n  /**\n   * Decodes a set of buffers into a set of typed values, given parameter definitions.\n   */\n\n\n  buffersToValues(buffers, parameters) {\n    // TODO: Refactor, split (function is quite complex).\n    buffers = buffers || [];\n    let values = [];\n    let bufferIndex = 0;\n    let numBuffers = buffers.length;\n\n    for (let i = 0; i < parameters.length; i++) {\n      let parameter = parameters[i];\n      let type = parameter.type;\n      let value = readValue(type);\n      values.push(value);\n    } // This is a recursive function.\n\n\n    function readValue(type) {\n      // TODO: Use matchers.\n      if (type instanceof algebraic_1.OptionalType) {\n        let typedValue = readValue(type.getFirstTypeParameter());\n        return new algebraic_1.OptionalValue(type, typedValue);\n      } else if (type instanceof variadic_1.VariadicType) {\n        let typedValues = [];\n\n        while (!hasReachedTheEnd()) {\n          typedValues.push(readValue(type.getFirstTypeParameter()));\n        }\n\n        return new variadic_1.VariadicValue(type, typedValues);\n      } else if (type instanceof composite_1.CompositeType) {\n        let typedValues = [];\n\n        for (const typeParameter of type.getTypeParameters()) {\n          typedValues.push(readValue(typeParameter));\n        }\n\n        return new composite_1.CompositeValue(type, typedValues);\n      } else {\n        // Non-composite (singular), non-variadic (fixed) type.\n        // The only branching without a recursive call.\n        let typedValue = decodeNextBuffer(type);\n        return typedValue;\n      }\n    }\n\n    function decodeNextBuffer(type) {\n      if (hasReachedTheEnd()) {\n        return null;\n      }\n\n      let buffer = buffers[bufferIndex++];\n      let decodedValue = Codec.decodeTopLevel(buffer, type);\n      return decodedValue;\n    }\n\n    function hasReachedTheEnd() {\n      return bufferIndex >= numBuffers;\n    }\n\n    return values;\n  }\n  /**\n   * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n   */\n\n\n  valuesToString(values) {\n    let strings = this.valuesToStrings(values);\n    let joinedString = strings.join(exports.ArgumentsSeparator);\n    return joinedString;\n  }\n  /**\n   * Serializes a set of typed values into a set of strings.\n   */\n\n\n  valuesToStrings(values) {\n    let buffers = this.valuesToBuffers(values);\n    let strings = buffers.map(buffer => buffer.toString(\"hex\"));\n    return strings;\n  }\n  /**\n   * Serializes a set of typed values into a set of strings buffers.\n   * Variadic types and composite types might result into none, one or more buffers.\n   */\n\n\n  valuesToBuffers(values) {\n    // TODO: Refactor, split (function is quite complex).\n    let buffers = [];\n\n    for (const value of values) {\n      handleValue(value);\n    } // This is a recursive function. It appends to the \"buffers\" variable.\n\n\n    function handleValue(value) {\n      // TODO: Use matchers.\n      if (value instanceof algebraic_1.OptionalValue) {\n        if (value.isSet()) {\n          handleValue(value.getTypedValue());\n        }\n      } else if (value instanceof variadic_1.VariadicValue) {\n        for (const item of value.getItems()) {\n          handleValue(item);\n        }\n      } else if (value instanceof composite_1.CompositeValue) {\n        for (const item of value.getItems()) {\n          handleValue(item);\n        }\n      } else {\n        // Non-composite (singular), non-variadic (fixed) type.\n        // The only branching without a recursive call.\n        let buffer = Codec.encodeTopLevel(value);\n        buffers.push(buffer);\n      }\n    }\n\n    return buffers;\n  }\n\n}\n\nexports.ArgSerializer = ArgSerializer;","map":{"version":3,"mappings":"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","names":["exports","Codec","codec_1","ArgSerializer","stringToValues","joinedString","parameters","buffers","stringToBuffers","values","buffersToValues","split","map","item","Buffer","from","bufferIndex","numBuffers","length","i","parameter","type","value","readValue","push","algebraic_1","typedValue","getFirstTypeParameter","variadic_1","typedValues","hasReachedTheEnd","composite_1","typeParameter","getTypeParameters","decodeNextBuffer","buffer","decodedValue","decodeTopLevel","valuesToString","strings","valuesToStrings","join","valuesToBuffers","toString","handleValue","isSet","getTypedValue","getItems","encodeTopLevel"],"sourceRoot":"","sources":["../../src/smartcontracts/argSerializer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}