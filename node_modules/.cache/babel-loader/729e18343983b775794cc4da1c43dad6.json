{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinaryParser = void 0;\n\nvar assert = require(\"assert\");\n\nvar enums_1 = require(\"../enums\");\n\nvar buffer_1 = require(\"buffer/\");\n/**\n * BinaryParser is used to compute fields and values from a HexString\n */\n\n\nvar BinaryParser =\n/** @class */\nfunction () {\n  /**\n   * Initialize bytes to a hex string\n   *\n   * @param hexBytes a hex string\n   */\n  function BinaryParser(hexBytes) {\n    this.bytes = buffer_1.Buffer.from(hexBytes, 'hex');\n  }\n  /**\n   * Peek the first byte of the BinaryParser\n   *\n   * @returns The first byte of the BinaryParser\n   */\n\n\n  BinaryParser.prototype.peek = function () {\n    assert.ok(this.bytes.byteLength !== 0);\n    return this.bytes[0];\n  };\n  /**\n   * Consume the first n bytes of the BinaryParser\n   *\n   * @param n the number of bytes to skip\n   */\n\n\n  BinaryParser.prototype.skip = function (n) {\n    assert.ok(n <= this.bytes.byteLength);\n    this.bytes = this.bytes.slice(n);\n  };\n  /**\n   * read the first n bytes from the BinaryParser\n   *\n   * @param n The number of bytes to read\n   * @return The bytes\n   */\n\n\n  BinaryParser.prototype.read = function (n) {\n    assert.ok(n <= this.bytes.byteLength);\n    var slice = this.bytes.slice(0, n);\n    this.skip(n);\n    return slice;\n  };\n  /**\n   * Read an integer of given size\n   *\n   * @param n The number of bytes to read\n   * @return The number represented by those bytes\n   */\n\n\n  BinaryParser.prototype.readUIntN = function (n) {\n    assert.ok(0 < n && n <= 4, 'invalid n');\n    return this.read(n).reduce(function (a, b) {\n      return a << 8 | b;\n    }) >>> 0;\n  };\n\n  BinaryParser.prototype.readUInt8 = function () {\n    return this.readUIntN(1);\n  };\n\n  BinaryParser.prototype.readUInt16 = function () {\n    return this.readUIntN(2);\n  };\n\n  BinaryParser.prototype.readUInt32 = function () {\n    return this.readUIntN(4);\n  };\n\n  BinaryParser.prototype.size = function () {\n    return this.bytes.byteLength;\n  };\n\n  BinaryParser.prototype.end = function (customEnd) {\n    var length = this.bytes.byteLength;\n    return length === 0 || customEnd !== undefined && length <= customEnd;\n  };\n  /**\n   * Reads variable length encoded bytes\n   *\n   * @return The variable length bytes\n   */\n\n\n  BinaryParser.prototype.readVariableLength = function () {\n    return this.read(this.readVariableLengthLength());\n  };\n  /**\n   * Reads the length of the variable length encoded bytes\n   *\n   * @return The length of the variable length encoded bytes\n   */\n\n\n  BinaryParser.prototype.readVariableLengthLength = function () {\n    var b1 = this.readUInt8();\n\n    if (b1 <= 192) {\n      return b1;\n    } else if (b1 <= 240) {\n      var b2 = this.readUInt8();\n      return 193 + (b1 - 193) * 256 + b2;\n    } else if (b1 <= 254) {\n      var b2 = this.readUInt8();\n      var b3 = this.readUInt8();\n      return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;\n    }\n\n    throw new Error('Invalid variable length indicator');\n  };\n  /**\n   * Reads the field ordinal from the BinaryParser\n   *\n   * @return Field ordinal\n   */\n\n\n  BinaryParser.prototype.readFieldOrdinal = function () {\n    var type = this.readUInt8();\n    var nth = type & 15;\n    type >>= 4;\n\n    if (type === 0) {\n      type = this.readUInt8();\n\n      if (type === 0 || type < 16) {\n        throw new Error('Cannot read FieldOrdinal, type_code out of range');\n      }\n    }\n\n    if (nth === 0) {\n      nth = this.readUInt8();\n\n      if (nth === 0 || nth < 16) {\n        throw new Error('Cannot read FieldOrdinal, field_code out of range');\n      }\n    }\n\n    return type << 16 | nth;\n  };\n  /**\n   * Read the field from the BinaryParser\n   *\n   * @return The field represented by the bytes at the head of the BinaryParser\n   */\n\n\n  BinaryParser.prototype.readField = function () {\n    return enums_1.Field.fromString(this.readFieldOrdinal().toString());\n  };\n  /**\n   * Read a given type from the BinaryParser\n   *\n   * @param type The type that you want to read from the BinaryParser\n   * @return The instance of that type read from the BinaryParser\n   */\n\n\n  BinaryParser.prototype.readType = function (type) {\n    return type.fromParser(this);\n  };\n  /**\n   * Get the type associated with a given field\n   *\n   * @param field The field that you wan to get the type of\n   * @return The type associated with the given field\n   */\n\n\n  BinaryParser.prototype.typeForField = function (field) {\n    return field.associatedType;\n  };\n  /**\n   * Read value of the type specified by field from the BinaryParser\n   *\n   * @param field The field that you want to get the associated value for\n   * @return The value associated with the given field\n   */\n\n\n  BinaryParser.prototype.readFieldValue = function (field) {\n    var type = this.typeForField(field);\n\n    if (!type) {\n      throw new Error(\"unsupported: (\".concat(field.name, \", \").concat(field.type.name, \")\"));\n    }\n\n    var sizeHint = field.isVariableLengthEncoded ? this.readVariableLengthLength() : undefined;\n    var value = type.fromParser(this, sizeHint);\n\n    if (value === undefined) {\n      throw new Error(\"fromParser for (\".concat(field.name, \", \").concat(field.type.name, \") -> undefined \"));\n    }\n\n    return value;\n  };\n  /**\n   * Get the next field and value from the BinaryParser\n   *\n   * @return The field and value\n   */\n\n\n  BinaryParser.prototype.readFieldAndValue = function () {\n    var field = this.readField();\n    return [field, this.readFieldValue(field)];\n  };\n\n  return BinaryParser;\n}();\n\nexports.BinaryParser = BinaryParser;","map":{"version":3,"mappings":"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","names":["hexBytes","bytes","buffer_1","from","BinaryParser","assert","ok","byteLength","n","slice","skip","read","reduce","a","b","readUIntN","customEnd","length","undefined","readVariableLengthLength","b1","readUInt8","b2","b3","Error","type","nth","enums_1","fromString","readFieldOrdinal","toString","fromParser","field","associatedType","typeForField","name","concat","sizeHint","isVariableLengthEncoded","value","readField","readFieldValue","exports"],"sourceRoot":"","sources":["../../src/serdes/binary-parser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}