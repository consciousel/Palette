{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ListBinaryCodec = void 0;\n\nconst typesystem_1 = require(\"../typesystem\");\n\nconst constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"List\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\n\n\nclass ListBinaryCodec {\n  constructor(binaryCodec) {\n    this.binaryCodec = binaryCodec;\n  }\n\n  decodeNested(buffer, type) {\n    let typeParameter = type.getFirstTypeParameter();\n    let result = [];\n    let numItems = buffer.readUInt32BE();\n    this.binaryCodec.constraints.checkListLength(numItems);\n    let originalBuffer = buffer;\n    let offset = constants_1.SizeOfU32;\n    buffer = originalBuffer.slice(offset);\n\n    for (let i = 0; i < numItems; i++) {\n      let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);\n      result.push(decoded);\n      offset += decodedLength;\n      buffer = originalBuffer.slice(offset);\n    }\n\n    return [new typesystem_1.List(type, result), offset];\n  }\n\n  decodeTopLevel(buffer, type) {\n    let typeParameter = type.getFirstTypeParameter();\n    let result = [];\n    let originalBuffer = buffer;\n    let offset = 0;\n\n    while (buffer.length > 0) {\n      let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);\n      result.push(decoded);\n      offset += decodedLength;\n      buffer = originalBuffer.slice(offset);\n      this.binaryCodec.constraints.checkListLength(result.length);\n    }\n\n    return new typesystem_1.List(type, result);\n  }\n\n  encodeNested(list) {\n    this.binaryCodec.constraints.checkListLength(list.getLength());\n    let lengthBuffer = Buffer.alloc(constants_1.SizeOfU32);\n    lengthBuffer.writeUInt32BE(list.getLength());\n    let itemsBuffers = [];\n\n    for (const item of list.getItems()) {\n      let itemBuffer = this.binaryCodec.encodeNested(item);\n      itemsBuffers.push(itemBuffer);\n    }\n\n    let buffer = Buffer.concat([lengthBuffer, ...itemsBuffers]);\n    return buffer;\n  }\n\n  encodeTopLevel(list) {\n    this.binaryCodec.constraints.checkListLength(list.getLength());\n    let itemsBuffers = [];\n\n    for (const item of list.getItems()) {\n      let itemBuffer = this.binaryCodec.encodeNested(item);\n      itemsBuffers.push(itemBuffer);\n    }\n\n    let buffer = Buffer.concat(itemsBuffers);\n    return buffer;\n  }\n\n}\n\nexports.ListBinaryCodec = ListBinaryCodec;","map":{"version":3,"mappings":"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","names":["ListBinaryCodec","constructor","binaryCodec","decodeNested","buffer","type","typeParameter","getFirstTypeParameter","result","numItems","readUInt32BE","constraints","checkListLength","originalBuffer","offset","constants_1","slice","i","decoded","decodedLength","push","typesystem_1","decodeTopLevel","length","encodeNested","list","getLength","lengthBuffer","Buffer","alloc","writeUInt32BE","itemsBuffers","item","getItems","itemBuffer","concat","encodeTopLevel","exports"],"sourceRoot":"","sources":["../../../src/smartcontracts/codec/list.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}