{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = __importStar(require(\"lodash\"));\n\nconst hashes_1 = require(\"../common/hashes\");\n\nconst common = __importStar(require(\"../common\"));\n\nfunction convertLedgerHeader(header) {\n  return {\n    account_hash: header.stateHash,\n    close_time: common.iso8601ToRippleTime(header.closeTime),\n    close_time_resolution: header.closeTimeResolution,\n    close_flags: header.closeFlags,\n    hash: header.ledgerHash,\n    ledger_hash: header.ledgerHash,\n    ledger_index: header.ledgerVersion.toString(),\n    parent_hash: header.parentLedgerHash,\n    parent_close_time: common.iso8601ToRippleTime(header.parentCloseTime),\n    total_coins: header.totalDrops,\n    transaction_hash: header.transactionHash\n  };\n}\n\nfunction hashLedgerHeader(ledgerHeader) {\n  const header = convertLedgerHeader(ledgerHeader);\n  return hashes_1.computeLedgerHash(header);\n}\n\nfunction computeTransactionHash(ledger, options) {\n  let transactions;\n\n  if (ledger.rawTransactions) {\n    transactions = JSON.parse(ledger.rawTransactions);\n  } else if (ledger.transactions) {\n    try {\n      transactions = ledger.transactions.map(tx => JSON.parse(tx.rawTransaction));\n    } catch (e) {\n      if (e.toString() === 'SyntaxError: Unexpected' + ' token u in JSON at position 0') {\n        throw new common.errors.ValidationError('ledger' + ' is missing raw transactions');\n      }\n    }\n  } else {\n    if (options.computeTreeHashes) {\n      throw new common.errors.ValidationError('transactions' + ' property is missing from the ledger');\n    }\n\n    return ledger.transactionHash;\n  }\n\n  const txs = transactions.map(tx => {\n    const mergeTx = Object.assign({}, _.omit(tx, 'tx'), tx.tx || {});\n    const renameMeta = Object.assign({}, _.omit(mergeTx, 'meta'), tx.meta ? {\n      metaData: tx.meta\n    } : {});\n    return renameMeta;\n  });\n  const transactionHash = hashes_1.computeTransactionTreeHash(txs);\n\n  if (ledger.transactionHash != null && ledger.transactionHash !== transactionHash) {\n    throw new common.errors.ValidationError('transactionHash in header' + ' does not match computed hash of transactions', {\n      transactionHashInHeader: ledger.transactionHash,\n      computedHashOfTransactions: transactionHash\n    });\n  }\n\n  return transactionHash;\n}\n\nfunction computeStateHash(ledger, options) {\n  if (ledger.rawState == null) {\n    if (options.computeTreeHashes) {\n      throw new common.errors.ValidationError('rawState' + ' property is missing from the ledger');\n    }\n\n    return ledger.stateHash;\n  }\n\n  const state = JSON.parse(ledger.rawState);\n  const stateHash = hashes_1.computeStateTreeHash(state);\n\n  if (ledger.stateHash != null && ledger.stateHash !== stateHash) {\n    throw new common.errors.ValidationError('stateHash in header' + ' does not match computed hash of state');\n  }\n\n  return stateHash;\n}\n\nfunction computeLedgerHeaderHash(ledger) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const subhashes = {\n    transactionHash: computeTransactionHash(ledger, options),\n    stateHash: computeStateHash(ledger, options)\n  };\n  return hashLedgerHeader(Object.assign({}, ledger, subhashes));\n}\n\nexports.default = computeLedgerHeaderHash;","map":{"version":3,"mappings":"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","names":["convertLedgerHeader","header","account_hash","stateHash","close_time","common","iso8601ToRippleTime","closeTime","close_time_resolution","closeTimeResolution","close_flags","closeFlags","hash","ledgerHash","ledger_hash","ledger_index","ledgerVersion","toString","parent_hash","parentLedgerHash","parent_close_time","parentCloseTime","total_coins","totalDrops","transaction_hash","transactionHash","hashLedgerHeader","ledgerHeader","hashes_1","computeTransactionHash","ledger","options","transactions","rawTransactions","JSON","parse","map","tx","rawTransaction","e","errors","ValidationError","computeTreeHashes","txs","mergeTx","Object","assign","_","omit","renameMeta","meta","metaData","transactionHashInHeader","computedHashOfTransactions","computeStateHash","rawState","state","computeLedgerHeaderHash","subhashes","exports"],"sourceRoot":"","sources":["../../../src/offline/ledgerhash.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}