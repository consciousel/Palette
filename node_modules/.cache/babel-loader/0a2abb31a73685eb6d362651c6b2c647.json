{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullType = exports.TypePlaceholder = exports.isTyped = exports.PrimitiveValue = exports.TypedValue = exports.CustomType = exports.PrimitiveType = exports.TypeCardinality = exports.Type = void 0;\n\nconst utils_1 = require(\"../../utils\");\n/**\n * An abstraction that represents a Type. Handles both generic and non-generic types.\n * Once instantiated as a Type, a generic type is \"closed\" (as opposed to \"open\").\n */\n\n\nclass Type {\n  constructor(name) {\n    let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let cardinality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TypeCardinality.fixed(1);\n    utils_1.guardValueIsSet(\"name\", name);\n    this.name = name;\n    this.typeParameters = typeParameters;\n    this.cardinality = cardinality;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  getTypeParameters() {\n    return this.typeParameters;\n  }\n\n  isGenericType() {\n    return this.typeParameters.length > 0;\n  }\n\n  getFirstTypeParameter() {\n    utils_1.guardTrue(this.typeParameters.length > 0, \"type parameters length > 0\");\n    return this.typeParameters[0];\n  }\n  /**\n   * Generates type expressions similar to elrond-wasm-rs.\n   */\n\n\n  toString() {\n    let typeParameters = this.getTypeParameters().map(type => type.toString()).join(\", \");\n    let typeParametersExpression = typeParameters ? `<${typeParameters}>` : \"\";\n    return `${this.name}${typeParametersExpression}`;\n  }\n\n  equals(other) {\n    return Type.equals(this, other);\n  }\n\n  static equals(a, b) {\n    // Workaround that seems to always work properly. Most probable reasons: \n    // - ES6 is quite strict about enumerating over the properties on an object.\n    // - toJSON() returns an object literal (most probably, this results in deterministic iteration in all browser implementations).\n    let aJson = JSON.stringify(a.toJSON());\n    let bJson = JSON.stringify(b.toJSON());\n    return aJson == bJson;\n  }\n\n  static equalsMany(a, b) {\n    return a.every((type, i) => type.equals(b[i]));\n  }\n\n  static isAssignableFromMany(a, b) {\n    return a.every((type, i) => type.isAssignableFrom(b[i]));\n  }\n\n  differs(other) {\n    return !this.equals(other);\n  }\n\n  valueOf() {\n    return this.name;\n  }\n  /**\n   * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom\n   * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).\n   *\n   * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.\n   * For example, Option<u32> is assignable from Option<?>.\n   * For more details, see the implementation of {@link OptionType}.\n   *\n   * Also see:\n   *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\n   *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance\n   */\n\n\n  isAssignableFrom(type) {\n    let invariantTypeParameters = Type.equalsMany(this.getTypeParameters(), type.getTypeParameters());\n    return type instanceof this.constructor && invariantTypeParameters;\n  }\n  /**\n   * Converts the account to a pretty, plain JavaScript object.\n   */\n\n\n  toJSON() {\n    return {\n      name: this.name,\n      typeParameters: this.typeParameters.map(item => item.toJSON())\n    };\n  }\n\n  getCardinality() {\n    return this.cardinality;\n  }\n\n}\n\nexports.Type = Type;\n/**\n * TODO: Simplify this class, keep only what is needed.\n *\n * An abstraction for defining and operating with the cardinality of a (composite or simple) type.\n *\n * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].\n * Composite types (not directly encodable) do not follow this constraint. For example:\n *  - VarArgs: [lower = 0, upper = *]\n *  - OptionalResult: [lower = 0, upper = 1]\n */\n\nclass TypeCardinality {\n  constructor(lowerBound, upperBound) {\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n  }\n\n  static fixed(value) {\n    return new TypeCardinality(value, value);\n  }\n\n  static variable(value) {\n    return new TypeCardinality(0, value);\n  }\n\n  isSingular() {\n    return this.lowerBound == 1 && this.upperBound == 1;\n  }\n\n  isSingularOrNone() {\n    return this.lowerBound == 0 && this.upperBound == 1;\n  }\n\n  isComposite() {\n    return !this.isSingular();\n  }\n\n  isFixed() {\n    return this.lowerBound == this.upperBound;\n  }\n\n  getLowerBound() {\n    return this.lowerBound;\n  }\n\n  getUpperBound() {\n    return this.upperBound || TypeCardinality.MaxCardinality;\n  }\n\n}\n\nexports.TypeCardinality = TypeCardinality;\n/**\n * An arbitrarily chosen, reasonably large number.\n */\n\nTypeCardinality.MaxCardinality = 4096;\n\nclass PrimitiveType extends Type {\n  constructor(name) {\n    super(name);\n  }\n\n}\n\nexports.PrimitiveType = PrimitiveType;\n\nclass CustomType extends Type {}\n\nexports.CustomType = CustomType;\n\nclass TypedValue {\n  constructor(type) {\n    this.type = type;\n  }\n\n  getType() {\n    return this.type;\n  }\n\n}\n\nexports.TypedValue = TypedValue;\n\nclass PrimitiveValue extends TypedValue {\n  constructor(type) {\n    super(type);\n  }\n\n}\n\nexports.PrimitiveValue = PrimitiveValue;\n\nfunction isTyped(value) {\n  return value instanceof TypedValue;\n}\n\nexports.isTyped = isTyped;\n\nclass TypePlaceholder extends Type {\n  constructor() {\n    super(\"...\");\n  }\n\n}\n\nexports.TypePlaceholder = TypePlaceholder;\n\nclass NullType extends Type {\n  constructor() {\n    super(\"?\");\n  }\n\n}\n\nexports.NullType = NullType;","map":{"version":3,"mappings":"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","names":["Type","constructor","name","typeParameters","cardinality","TypeCardinality","fixed","utils_1","getName","getTypeParameters","isGenericType","length","getFirstTypeParameter","toString","map","type","join","typeParametersExpression","equals","other","a","b","aJson","JSON","stringify","toJSON","bJson","equalsMany","every","i","isAssignableFromMany","isAssignableFrom","differs","valueOf","invariantTypeParameters","item","getCardinality","exports","lowerBound","upperBound","value","variable","isSingular","isSingularOrNone","isComposite","isFixed","getLowerBound","getUpperBound","MaxCardinality","PrimitiveType","CustomType","TypedValue","getType","PrimitiveValue","isTyped","TypePlaceholder","NullType"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/types.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}