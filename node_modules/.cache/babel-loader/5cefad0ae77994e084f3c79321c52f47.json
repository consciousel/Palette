{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StructField = exports.Struct = exports.StructFieldDefinition = exports.StructType = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst typeExpressionParser_1 = require(\"./typeExpressionParser\");\n\nconst types_1 = require(\"./types\");\n\nclass StructType extends types_1.CustomType {\n  constructor(name, fields) {\n    super(name);\n    this.fields = [];\n    this.fields = fields;\n  }\n\n  static fromJSON(json) {\n    let fields = (json.fields || []).map(field => StructFieldDefinition.fromJSON(field));\n    return new StructType(json.name, fields);\n  }\n\n}\n\nexports.StructType = StructType; // TODO: Perhaps rename to FieldDefinition and extract to separate file, fields.ts?\n\nclass StructFieldDefinition {\n  constructor(name, description, type) {\n    this.name = name;\n    this.description = description;\n    this.type = type;\n  }\n\n  static fromJSON(json) {\n    let parsedType = new typeExpressionParser_1.TypeExpressionParser().parse(json.type);\n    return new StructFieldDefinition(json.name, json.description, parsedType);\n  }\n\n}\n\nexports.StructFieldDefinition = StructFieldDefinition; // TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\n\nclass Struct extends types_1.TypedValue {\n  /**\n   * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n   */\n  constructor(type, fields) {\n    super(type);\n    this.fields = [];\n    this.fields = fields;\n    this.checkTyping();\n  }\n\n  checkTyping() {\n    let fields = this.fields;\n    let type = this.getType();\n    let definitions = type.fields;\n\n    if (fields.length != definitions.length) {\n      throw new errors.ErrStructTyping(\"fields length vs. field definitions length\");\n    }\n\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i];\n      let definition = definitions[i];\n      let fieldType = field.value.getType();\n      let definitionType = definition.type;\n\n      if (!fieldType.equals(definitionType)) {\n        throw new errors.ErrStructTyping(`check type of field \"${definition.name}; expected: ${definitionType}, actual: ${fieldType}\"`);\n      }\n\n      if (field.name != definition.name) {\n        throw new errors.ErrStructTyping(`check name of field \"${definition.name}\"`);\n      }\n    }\n  }\n\n  getFields() {\n    return this.fields;\n  }\n\n  valueOf() {\n    let result = {};\n\n    for (const field of this.fields) {\n      result[field.name] = field.value.valueOf();\n    }\n\n    return result;\n  }\n\n  equals(other) {\n    if (!this.getType().equals(other.getType())) {\n      return false;\n    }\n\n    let selfFields = this.getFields();\n    let otherFields = other.getFields();\n\n    if (selfFields.length != otherFields.length) {\n      return false;\n    }\n\n    for (let i = 0; i < selfFields.length; i++) {\n      let selfField = selfFields[i];\n      let otherField = otherFields[i];\n\n      if (!selfField.equals(otherField)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexports.Struct = Struct; // TODO: Perhaps rename to Field and extract to separate file, fields.ts?\n\nclass StructField {\n  constructor(value) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    this.value = value;\n    this.name = name;\n  }\n\n  equals(other) {\n    return this.name == other.name && this.value.equals(other.value);\n  }\n\n}\n\nexports.StructField = StructField;","map":{"version":3,"mappings":"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","names":["StructType","types_1","constructor","name","fields","fromJSON","json","map","field","StructFieldDefinition","exports","description","type","parsedType","typeExpressionParser_1","parse","Struct","checkTyping","getType","definitions","length","errors","ErrStructTyping","i","definition","fieldType","value","definitionType","equals","getFields","valueOf","result","other","selfFields","otherFields","selfField","otherField","StructField"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/struct.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}