{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar GlobalBigNumber = require('bignumber.js');\n\nvar BigNumber = GlobalBigNumber.clone({\n  DECIMAL_PLACES: 40\n});\n\nvar parseQuality = require('./quality');\n\nvar lsfSell = 0x00020000; // see \"lsfSell\" flag in rippled source code\n\nfunction removeUndefined(obj) {\n  return _.omitBy(obj, _.isUndefined);\n}\n\nfunction convertOrderChange(order) {\n  var takerGets = order.taker_gets;\n  var takerPays = order.taker_pays;\n  var direction = order.sell ? 'sell' : 'buy';\n  var quantity = direction === 'buy' ? takerPays : takerGets;\n  var totalPrice = direction === 'buy' ? takerGets : takerPays;\n  return removeUndefined({\n    direction: direction,\n    quantity: quantity,\n    totalPrice: totalPrice,\n    sequence: order.sequence,\n    status: order.status,\n    makerExchangeRate: order.quality,\n    expirationTime: order.expiration\n  });\n}\n\nfunction rippleToUnixTimestamp(rpepoch) {\n  return (rpepoch + 0x386D4380) * 1000;\n}\n\nfunction getExpirationTime(node) {\n  var expirationTime = node.finalFields.Expiration || node.newFields.Expiration;\n\n  if (expirationTime === undefined) {\n    return undefined;\n  }\n\n  return new Date(rippleToUnixTimestamp(expirationTime)).toISOString();\n}\n\nfunction getQuality(node) {\n  var takerGets = node.finalFields.TakerGets || node.newFields.TakerGets;\n  var takerPays = node.finalFields.TakerPays || node.newFields.TakerPays;\n  var takerGetsCurrency = takerGets.currency || 'XRP';\n  var takerPaysCurrency = takerPays.currency || 'XRP';\n  var bookDirectory = node.finalFields.BookDirectory || node.newFields.BookDirectory;\n  var qualityHex = bookDirectory.substring(bookDirectory.length - 16);\n  return parseQuality(qualityHex, takerGetsCurrency, takerPaysCurrency);\n}\n\nfunction parseOrderStatus(node) {\n  if (node.diffType === 'CreatedNode') {\n    // \"submitted\" is more conventional, but could be confusing in the\n    // context of Ripple\n    return 'created';\n  }\n\n  if (node.diffType === 'ModifiedNode') {\n    return 'partially-filled';\n  }\n\n  if (node.diffType === 'DeletedNode') {\n    // A filled order has previous fields\n    if (node.previousFields.hasOwnProperty('TakerPays')) {\n      return 'filled';\n    } // A cancelled order has no previous fields\n    // google search for \"cancelled order\" shows 5x more results than\n    // \"canceled order\", even though both spellings are correct\n\n\n    return 'cancelled';\n  }\n\n  return undefined;\n}\n\nfunction calculateDelta(finalAmount, previousAmount) {\n  if (previousAmount) {\n    var finalValue = new BigNumber(finalAmount.value);\n    var previousValue = new BigNumber(previousAmount.value);\n    return finalValue.minus(previousValue).abs().toString();\n  }\n\n  return '0';\n}\n\nfunction parseChangeAmount(node, type) {\n  var status = parseOrderStatus(node);\n\n  if (status === 'cancelled') {\n    // Canceled orders do not have PreviousFields; FinalFields\n    // have positive values\n    return utils.parseCurrencyAmount(node.finalFields[type]);\n  } else if (status === 'created') {\n    return utils.parseCurrencyAmount(node.newFields[type]);\n  }\n\n  var finalAmount = utils.parseCurrencyAmount(node.finalFields[type]);\n  var previousAmount = utils.parseCurrencyAmount(node.previousFields[type]);\n  var value = calculateDelta(finalAmount, previousAmount);\n  return _.assign({}, finalAmount, {\n    value: value\n  });\n}\n\nfunction parseOrderChange(node) {\n  var orderChange = convertOrderChange({\n    taker_pays: parseChangeAmount(node, 'TakerPays'),\n    taker_gets: parseChangeAmount(node, 'TakerGets'),\n    sell: (node.finalFields.Flags & lsfSell) !== 0,\n    sequence: node.finalFields.Sequence || node.newFields.Sequence,\n    status: parseOrderStatus(node),\n    quality: getQuality(node),\n    expiration: getExpirationTime(node)\n  });\n  Object.defineProperty(orderChange, 'account', {\n    value: node.finalFields.Account || node.newFields.Account\n  });\n  return orderChange;\n}\n\nfunction groupByAddress(orderChanges) {\n  return _.groupBy(orderChanges, function (change) {\n    return change.account;\n  });\n}\n/**\n * Computes the complete list of every Offer that changed in the ledger\n * as a result of the given transaction.\n * Returns changes grouped by Ripple account.\n *\n *  @param {Object} metadata - Transaction metadata as return by ripple-lib\n *  @returns {Object} - Orderbook changes grouped by Ripple account\n *\n */\n\n\nexports.parseOrderbookChanges = function parseOrderbookChanges(metadata) {\n  var nodes = utils.normalizeNodes(metadata);\n\n  var orderChanges = _.map(_.filter(nodes, function (node) {\n    return node.entryType === 'Offer';\n  }), parseOrderChange);\n\n  return groupByAddress(orderChanges);\n};","map":{"version":3,"sources":["C:/Users/masho/OneDrive/Desktop/Blockchain/Biconomy/Projects/NFT_minter/node_modules/ripple-lib-transactionparser/src/orderbookchanges.js"],"names":["_","require","utils","GlobalBigNumber","BigNumber","clone","DECIMAL_PLACES","parseQuality","lsfSell","removeUndefined","obj","omitBy","isUndefined","convertOrderChange","order","takerGets","taker_gets","takerPays","taker_pays","direction","sell","quantity","totalPrice","sequence","status","makerExchangeRate","quality","expirationTime","expiration","rippleToUnixTimestamp","rpepoch","getExpirationTime","node","finalFields","Expiration","newFields","undefined","Date","toISOString","getQuality","TakerGets","TakerPays","takerGetsCurrency","currency","takerPaysCurrency","bookDirectory","BookDirectory","qualityHex","substring","length","parseOrderStatus","diffType","previousFields","hasOwnProperty","calculateDelta","finalAmount","previousAmount","finalValue","value","previousValue","minus","abs","toString","parseChangeAmount","type","parseCurrencyAmount","assign","parseOrderChange","orderChange","Flags","Sequence","Object","defineProperty","Account","groupByAddress","orderChanges","groupBy","change","account","exports","parseOrderbookChanges","metadata","nodes","normalizeNodes","map","filter","entryType"],"mappings":"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","sourcesContent":["'use strict'\nvar _ = require('lodash')\nvar utils = require('./utils')\nvar GlobalBigNumber = require('bignumber.js')\nvar BigNumber = GlobalBigNumber.clone({DECIMAL_PLACES: 40})\nvar parseQuality = require('./quality')\n\nvar lsfSell = 0x00020000 // see \"lsfSell\" flag in rippled source code\n\nfunction removeUndefined(obj) {\n  return _.omitBy(obj, _.isUndefined)\n}\n\nfunction convertOrderChange(order) {\n  var takerGets = order.taker_gets\n  var takerPays = order.taker_pays\n  var direction = order.sell ? 'sell' : 'buy'\n  var quantity = (direction === 'buy') ? takerPays : takerGets\n  var totalPrice = (direction === 'buy') ? takerGets : takerPays\n  return removeUndefined({\n    direction: direction,\n    quantity: quantity,\n    totalPrice: totalPrice,\n    sequence: order.sequence,\n    status: order.status,\n    makerExchangeRate: order.quality,\n    expirationTime: order.expiration\n  })\n}\n\nfunction rippleToUnixTimestamp(rpepoch) {\n  return (rpepoch + 0x386D4380) * 1000\n}\n\nfunction getExpirationTime(node) {\n  var expirationTime = node.finalFields.Expiration || node.newFields.Expiration\n  if (expirationTime === undefined) {\n    return undefined\n  }\n  return (new Date(rippleToUnixTimestamp(expirationTime))).toISOString()\n}\n\nfunction getQuality(node) {\n  var takerGets = node.finalFields.TakerGets || node.newFields.TakerGets\n  var takerPays = node.finalFields.TakerPays || node.newFields.TakerPays\n  var takerGetsCurrency = takerGets.currency || 'XRP'\n  var takerPaysCurrency = takerPays.currency || 'XRP'\n  var bookDirectory = node.finalFields.BookDirectory\n    || node.newFields.BookDirectory\n  var qualityHex = bookDirectory.substring(bookDirectory.length - 16)\n  return parseQuality(qualityHex, takerGetsCurrency, takerPaysCurrency)\n}\n\nfunction parseOrderStatus(node) {\n  if (node.diffType === 'CreatedNode') {\n    // \"submitted\" is more conventional, but could be confusing in the\n    // context of Ripple\n    return 'created'\n  }\n\n  if (node.diffType === 'ModifiedNode') {\n    return 'partially-filled'\n  }\n\n  if (node.diffType === 'DeletedNode') {\n    // A filled order has previous fields\n    if (node.previousFields.hasOwnProperty('TakerPays')) {\n      return 'filled'\n    }\n\n    // A cancelled order has no previous fields\n    // google search for \"cancelled order\" shows 5x more results than\n    // \"canceled order\", even though both spellings are correct\n    return 'cancelled'\n  }\n  return undefined\n}\n\nfunction calculateDelta(finalAmount, previousAmount) {\n  if (previousAmount) {\n    var finalValue = new BigNumber(finalAmount.value)\n    var previousValue = new BigNumber(previousAmount.value)\n    return finalValue.minus(previousValue).abs().toString()\n  }\n  return '0'\n}\n\nfunction parseChangeAmount(node, type) {\n  var status = parseOrderStatus(node)\n\n  if (status === 'cancelled') {\n    // Canceled orders do not have PreviousFields; FinalFields\n    // have positive values\n    return utils.parseCurrencyAmount(node.finalFields[type])\n  } else if (status === 'created') {\n    return utils.parseCurrencyAmount(node.newFields[type])\n  }\n  var finalAmount = utils.parseCurrencyAmount(node.finalFields[type])\n  var previousAmount = utils.parseCurrencyAmount(node.previousFields[type])\n  var value = calculateDelta(finalAmount, previousAmount)\n  return _.assign({}, finalAmount, {value: value})\n}\n\nfunction parseOrderChange(node) {\n  var orderChange = convertOrderChange({\n    taker_pays: parseChangeAmount(node, 'TakerPays'),\n    taker_gets: parseChangeAmount(node, 'TakerGets'),\n    sell: (node.finalFields.Flags & lsfSell) !== 0,\n    sequence: node.finalFields.Sequence || node.newFields.Sequence,\n    status: parseOrderStatus(node),\n    quality: getQuality(node),\n    expiration: getExpirationTime(node)\n  })\n\n  Object.defineProperty(orderChange, 'account', {\n    value: node.finalFields.Account || node.newFields.Account\n  })\n\n  return orderChange\n}\n\nfunction groupByAddress(orderChanges) {\n  return _.groupBy(orderChanges, function(change) {\n    return change.account\n  })\n}\n\n/**\n * Computes the complete list of every Offer that changed in the ledger\n * as a result of the given transaction.\n * Returns changes grouped by Ripple account.\n *\n *  @param {Object} metadata - Transaction metadata as return by ripple-lib\n *  @returns {Object} - Orderbook changes grouped by Ripple account\n *\n */\nexports.parseOrderbookChanges = function parseOrderbookChanges(metadata) {\n  var nodes = utils.normalizeNodes(metadata)\n\n  var orderChanges = _.map(_.filter(nodes, function(node) {\n    return node.entryType === 'Offer'\n  }), parseOrderChange)\n\n  return groupByAddress(orderChanges)\n}\n"]},"metadata":{},"sourceType":"script"}