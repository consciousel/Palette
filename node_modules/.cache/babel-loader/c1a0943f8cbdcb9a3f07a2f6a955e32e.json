{"ast":null,"code":"var backslash = require('backslash');\n\nmodule.exports = {\n  validate: validate,\n  parse: parse\n};\n/**\n * Validates a json string.\n * Errors are returned\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {String} error. undefined if no error\n */\n\nfunction validate(jsonString, allowDuplicatedKeys) {\n  var error;\n  allowDuplicatedKeys = allowDuplicatedKeys || false;\n\n  if (typeof jsonString !== 'string') {\n    error = 'Input must be a string';\n  } else {\n    try {\n      // Try to find a value starting from index 0\n      _findValue(jsonString, 0, allowDuplicatedKeys, false);\n    } catch (e) {\n      error = e.message;\n    }\n  }\n\n  return error;\n}\n/**\n * Parses a json. Errors are thrown if any\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {Object}\n */\n\n\nfunction parse(jsonString, allowDuplicatedKeys) {\n  if (typeof jsonString !== 'string') {\n    throw new Error('Input must be a string');\n  }\n\n  allowDuplicatedKeys = allowDuplicatedKeys || false; // Try to find a value starting from index 0\n\n  var value = _findValue(jsonString, 0, allowDuplicatedKeys, true);\n\n  return value.value;\n}\n/**\n * Find the comma separator, ], } or end of file\n * @param {String} str - original json string\n * @param {Number} startInd - starting index\n * @returns {{start: Number, end: Number, value: String}} value: the separator found\n * @private\n */\n\n\nfunction _findSeparator(str, startInd) {\n  var len = str.length;\n  var sepStartInd = startInd;\n  var sepEndInd;\n\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n\n    if (ch === ',') {\n      sepEndInd = i;\n      break;\n    } else if (ch === ']' || ch === '}') {\n      sepEndInd = i - 1;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting end of expression or separator');\n    }\n  }\n\n  var value;\n\n  if (sepEndInd === undefined) {\n    sepEndInd = len;\n    value = str[sepEndInd];\n  } else {\n    value = str[sepEndInd];\n    sepEndInd++;\n  }\n\n  return {\n    start: sepStartInd,\n    end: sepEndInd,\n    value: value\n  };\n}\n/**\n * Find the semi-colon separator ':'\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number}}\n * @private\n */\n\n\nfunction _findSemiColonSeparator(str, startInd) {\n  var len = str.length;\n  var semiColStartInd = startInd;\n  var semiColEndInd;\n\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n\n    if (ch === ':') {\n      semiColEndInd = i;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting \\':\\'');\n    }\n  }\n\n  if (semiColEndInd === undefined) {\n    throw _syntaxError(str, i, 'expecting \\':\\'');\n  }\n\n  semiColEndInd++;\n  return {\n    start: semiColStartInd,\n    end: semiColEndInd\n  };\n}\n/**\n * Find a value it can be number, array, object, strings or boolean\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys - allow duplicated keys in objects or not\n * @returns {{value: *, start: Number, end: Number}}\n * @private\n */\n\n\nfunction _findValue(str, startInd, allowDuplicatedKeys, parse) {\n  var len = str.length;\n  var valueStartInd;\n  var valueEndInd;\n  var isArray = false;\n  var isObject = false;\n  var isString = false;\n  var isNumber = false;\n  var dotFound = false;\n  var whiteSpaceInNumber = false;\n  var value;\n\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n\n    if (valueStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch === '[') {\n          isArray = true;\n        } else if (ch === '{') {\n          isObject = true;\n        } else if (ch === '\"') {\n          isString = true;\n        } else if (_isTrueFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = true;\n          break;\n        } else if (_isFalseFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 4;\n          valueEndInd = i;\n          value = false;\n          break;\n        } else if (_isNullFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = null;\n          break;\n        } else if (_isNumber(ch)) {\n          isNumber = true;\n        } else if (ch === '-') {\n          isNumber = true;\n        } else {\n          throw _syntaxError(str, i, '');\n        }\n\n        valueStartInd = i;\n      }\n    } else {\n      if (isArray) {\n        var arr = _findArray(str, i, allowDuplicatedKeys, parse);\n\n        valueEndInd = arr.end;\n        value = arr.value;\n        break;\n      } else if (isObject) {\n        var obj = _findObject(str, i, allowDuplicatedKeys, parse);\n\n        valueEndInd = obj.end;\n        value = obj.value;\n        break;\n      } else if (isString && ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        valueEndInd = i;\n        value = backslash(str.substring(valueStartInd + 1, valueEndInd));\n        break;\n      } else if (isNumber) {\n        if (_isWhiteSpace(ch)) {\n          whiteSpaceInNumber = true;\n        } else if (ch === ',' || ch === ']' || ch === '}') {\n          value = parseFloat(str.substring(valueStartInd, valueEndInd), 10);\n          valueEndInd = i - 1;\n          break;\n        } else if (_isNumber(ch) && !whiteSpaceInNumber) {\n          continue;\n        } else if (ch === '.' && !dotFound && !whiteSpaceInNumber) {\n          dotFound = true;\n        } else {\n          throw _syntaxError(str, i, 'expecting number');\n        }\n      }\n    }\n  }\n\n  if (valueEndInd === undefined) {\n    if (isNumber) {\n      value = parseFloat(str.substring(valueStartInd, i), 10);\n      valueEndInd = i - 1;\n    } else {\n      throw _syntaxError(str, i, 'unclosed statement');\n    }\n  }\n\n  valueEndInd++;\n  return {\n    value: value,\n    start: valueStartInd,\n    end: valueEndInd\n  };\n}\n/**\n * Find a key in an object\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: String}}\n * @private\n */\n\n\nfunction _findKey(str, startInd) {\n  var len = str.length;\n  var keyStartInd;\n  var keyEndInd;\n\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n\n    if (keyStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch !== '\"') {\n          throw _syntaxError(str, i, 'expecting String');\n        }\n\n        keyStartInd = i;\n      }\n    } else {\n      if (ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        keyEndInd = i;\n        break;\n      }\n    }\n  }\n\n  if (keyEndInd === undefined) {\n    throw _syntaxError(str, len, 'expecting String');\n  }\n\n  var value = backslash(str.substring(keyStartInd + 1, keyEndInd));\n\n  if (value === '') {\n    throw _syntaxError(str, keyStartInd, 'empty string');\n  }\n\n  keyEndInd++;\n  return {\n    start: keyStartInd,\n    end: keyEndInd,\n    value: value\n  };\n}\n/**\n * Find an object by identifying the key, ':' separator and value\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys\n * @returns {{start: Number, end: Number, value: Object}}\n * @private\n */\n\n\nfunction _findObject(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var obj = {};\n  var keys = [];\n  var values = [];\n  var j = startInd;\n\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n\n  if (str[j] === '}') {\n    return {\n      start: startInd,\n      end: j,\n      value: obj\n    };\n  }\n\n  while (sepValue === ',') {\n    var key = _findKey(str, i);\n\n    var semi = _findSemiColonSeparator(str, key.end);\n\n    var value = _findValue(str, semi.end, allowDuplicatedKeys, parse);\n\n    var sepIndex = _findSeparator(str, value.end);\n\n    if (!allowDuplicatedKeys) {\n      if (keys.indexOf(key.value) !== -1) {\n        key.value = key.value + '1'; // throw _syntaxError(str, key.end, 'duplicated keys \"' + key.value + '\"');\n      }\n    }\n\n    keys.push(key.value);\n    values.push(value.value);\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n\n  if (parse) {\n    var indx = 0;\n\n    for (indx = 0; indx < keys.length; indx++) {\n      obj[keys[indx]] = values[indx];\n    }\n  }\n\n  return {\n    start: startInd,\n    end: i,\n    value: obj\n  };\n}\n/**\n * Going backward from an index, determine if there are even number\n * of consecutive backslashes in the string\n * @param {String} str - original json string\n * @param {Number} endInd\n * @returns {Boolean}\n * @private\n */\n\n\nfunction _hasEvenNumberOfBackSlash(str, endInd) {\n  var i = endInd;\n  var count = 0;\n\n  while (i > -1 && str[i] === '\\\\') {\n    count++;\n    i--;\n  }\n\n  return count % 2 === 0;\n}\n/**\n * Find an array by identifying values separated by ',' separator\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: Array}}\n * @private\n */\n\n\nfunction _findArray(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var arr = [];\n  var j = startInd;\n\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n\n  if (str[j] === ']') {\n    return {\n      start: startInd,\n      end: j,\n      value: arr\n    };\n  }\n\n  while (sepValue === ',') {\n    var value = _findValue(str, i, allowDuplicatedKeys, parse);\n\n    var sepIndex = _findSeparator(str, value.end);\n\n    if (parse) {\n      arr.push(value.value);\n    }\n\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n\n  return {\n    start: startInd,\n    end: i,\n    value: arr\n  };\n}\n/**\n * Determine if the string is 'true' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\n\n\nfunction _isTrueFromIndex(str, ind) {\n  return str.substr(ind, 4) === 'true';\n}\n/**\n * Determine if the string is 'false' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\n\n\nfunction _isFalseFromIndex(str, ind) {\n  return str.substr(ind, 5) === 'false';\n}\n/**\n * Determine if the string is 'null' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\n\n\nfunction _isNullFromIndex(str, ind) {\n  return str.substr(ind, 4) === 'null';\n}\n\nvar white = new RegExp(/^\\s$/);\n/**\n * Determine if this character is a white space\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\n\nfunction _isWhiteSpace(ch) {\n  return white.test(ch);\n}\n\nvar numberReg = new RegExp(/^\\d$/);\n/**\n * Determine if this character is a numeric character\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\n\nfunction _isNumber(ch) {\n  return numberReg.test(ch);\n}\n/**\n * Generate syntax error\n * @param {String} str - original json string\n * @param {Number} index - index in which the error was detected\n * @param {String} reason\n * @returns {Error}\n * @private\n */\n\n\nfunction _syntaxError(str, index, reason) {\n  var regionLen = 10;\n  var regionStr;\n\n  if (str.length < index + regionLen) {\n    regionStr = str.substr(_normalizeNegativeNumber(str.length - regionLen), str.length);\n  } else if (index - regionLen / 2 < 0) {\n    regionStr = str.substr(0, regionLen);\n  } else {\n    regionStr = str.substr(_normalizeNegativeNumber(index - regionLen / 2), regionLen);\n  }\n\n  var message;\n\n  if (reason) {\n    message = 'Syntax error: ' + reason + ' near ' + regionStr;\n  } else {\n    message = 'Syntax error near ' + regionStr;\n  }\n\n  return new Error(message);\n}\n/**\n * Return 0 if number is negative, the original number otherwise\n * @param {Number} num\n * @returns {Number}\n * @private\n */\n\n\nfunction _normalizeNegativeNumber(num) {\n  return num < 0 ? 0 : num;\n}","map":{"version":3,"sources":["C:/Users/masho/OneDrive/Desktop/Blockchain/Biconomy/Projects/NFT_minter/node_modules/json-duplicate-key-handle/index.js"],"names":["backslash","require","module","exports","validate","parse","jsonString","allowDuplicatedKeys","error","_findValue","e","message","Error","value","_findSeparator","str","startInd","len","length","sepStartInd","sepEndInd","i","ch","_isWhiteSpace","_syntaxError","undefined","start","end","_findSemiColonSeparator","semiColStartInd","semiColEndInd","valueStartInd","valueEndInd","isArray","isObject","isString","isNumber","dotFound","whiteSpaceInNumber","_isTrueFromIndex","_isFalseFromIndex","_isNullFromIndex","_isNumber","arr","_findArray","obj","_findObject","_hasEvenNumberOfBackSlash","substring","parseFloat","_findKey","keyStartInd","keyEndInd","sepValue","keys","values","j","key","semi","sepIndex","indexOf","push","indx","endInd","count","ind","substr","white","RegExp","test","numberReg","index","reason","regionLen","regionStr","_normalizeNegativeNumber","num"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAvB;;AACAC,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,QAAQ,EAAEA,QADK;AAEfC,EAAAA,KAAK,EAAEA;AAFQ,CAAjB;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,QAAT,CAAkBE,UAAlB,EAA8BC,mBAA9B,EAAmD;AACjD,MAAIC,KAAJ;AACAD,EAAAA,mBAAmB,GAAGA,mBAAmB,IAAI,KAA7C;;AACA,MAAI,OAAOD,UAAP,KAAsB,QAA1B,EAAoC;AAClCE,IAAAA,KAAK,GAAG,wBAAR;AACD,GAFD,MAEO;AACL,QAAI;AACF;AACAC,MAAAA,UAAU,CAACH,UAAD,EAAa,CAAb,EAAgBC,mBAAhB,EAAqC,KAArC,CAAV;AACD,KAHD,CAGE,OAAMG,CAAN,EAAS;AACTF,MAAAA,KAAK,GAAGE,CAAC,CAACC,OAAV;AACD;AACF;;AACD,SAAOH,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASH,KAAT,CAAeC,UAAf,EAA2BC,mBAA3B,EAAgD;AAC9C,MAAI,OAAOD,UAAP,KAAsB,QAA1B,EAAoC;AAClC,UAAM,IAAIM,KAAJ,CAAU,wBAAV,CAAN;AACD;;AAEDL,EAAAA,mBAAmB,GAAGA,mBAAmB,IAAI,KAA7C,CAL8C,CAO9C;;AACA,MAAIM,KAAK,GAAGJ,UAAU,CAACH,UAAD,EAAa,CAAb,EAAgBC,mBAAhB,EAAqC,IAArC,CAAtB;;AACA,SAAOM,KAAK,CAACA,KAAb;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,cAAT,CAAwBC,GAAxB,EAA6BC,QAA7B,EAAuC;AACrC,MAAIC,GAAG,GAAGF,GAAG,CAACG,MAAd;AACA,MAAIC,WAAW,GAAGH,QAAlB;AACA,MAAII,SAAJ;;AACA,OAAK,IAAIC,CAAC,GAAGL,QAAb,EAAuBK,CAAC,GAAGJ,GAA3B,EAAgCI,CAAC,EAAjC,EAAqC;AACnC,QAAIC,EAAE,GAAGP,GAAG,CAACM,CAAD,CAAZ;;AACA,QAAIC,EAAE,KAAK,GAAX,EAAgB;AACdF,MAAAA,SAAS,GAAGC,CAAZ;AACA;AACD,KAHD,MAGO,IAAKC,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAA1B,EAA+B;AACpCF,MAAAA,SAAS,GAAGC,CAAC,GAAG,CAAhB;AACA;AACD,KAHM,MAGA,IAAI,CAACE,aAAa,CAACD,EAAD,CAAlB,EAAwB;AAC7B,YAAME,YAAY,CAACT,GAAD,EAAMM,CAAN,EAAS,0CAAT,CAAlB;AACD;AACF;;AAED,MAAIR,KAAJ;;AACA,MAAIO,SAAS,KAAKK,SAAlB,EAA6B;AAC3BL,IAAAA,SAAS,GAAGH,GAAZ;AACAJ,IAAAA,KAAK,GAAGE,GAAG,CAACK,SAAD,CAAX;AACD,GAHD,MAGO;AACLP,IAAAA,KAAK,GAAGE,GAAG,CAACK,SAAD,CAAX;AACAA,IAAAA,SAAS;AACV;;AACD,SAAO;AACLM,IAAAA,KAAK,EAAEP,WADF;AAELQ,IAAAA,GAAG,EAAEP,SAFA;AAGLP,IAAAA,KAAK,EAAEA;AAHF,GAAP;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASe,uBAAT,CAAiCb,GAAjC,EAAsCC,QAAtC,EAAgD;AAC9C,MAAIC,GAAG,GAAGF,GAAG,CAACG,MAAd;AACA,MAAIW,eAAe,GAAGb,QAAtB;AACA,MAAIc,aAAJ;;AACA,OAAK,IAAIT,CAAC,GAAGL,QAAb,EAAuBK,CAAC,GAAGJ,GAA3B,EAAgCI,CAAC,EAAjC,EAAqC;AACnC,QAAIC,EAAE,GAAGP,GAAG,CAACM,CAAD,CAAZ;;AACA,QAAIC,EAAE,KAAK,GAAX,EAAgB;AACdQ,MAAAA,aAAa,GAAGT,CAAhB;AACA;AACD,KAHD,MAGO,IAAI,CAACE,aAAa,CAACD,EAAD,CAAlB,EAAwB;AAC7B,YAAME,YAAY,CAACT,GAAD,EAAMM,CAAN,EAAS,iBAAT,CAAlB;AACD;AACF;;AACD,MAAIS,aAAa,KAAKL,SAAtB,EAAiC;AAC/B,UAAMD,YAAY,CAACT,GAAD,EAAMM,CAAN,EAAS,iBAAT,CAAlB;AACD;;AACDS,EAAAA,aAAa;AACb,SAAO;AACLJ,IAAAA,KAAK,EAAEG,eADF;AAELF,IAAAA,GAAG,EAAEG;AAFA,GAAP;AAID;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASrB,UAAT,CAAoBM,GAApB,EAAyBC,QAAzB,EAAmCT,mBAAnC,EAAwDF,KAAxD,EAA+D;AAC7D,MAAIY,GAAG,GAAGF,GAAG,CAACG,MAAd;AACA,MAAIa,aAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,OAAO,GAAG,KAAd;AACA,MAAIC,QAAQ,GAAG,KAAf;AACA,MAAIC,QAAQ,GAAG,KAAf;AACA,MAAIC,QAAQ,GAAG,KAAf;AACA,MAAIC,QAAQ,GAAG,KAAf;AACA,MAAIC,kBAAkB,GAAG,KAAzB;AACA,MAAIzB,KAAJ;;AAEA,OAAK,IAAIQ,CAAC,GAAGL,QAAb,EAAuBK,CAAC,GAAGJ,GAA3B,EAAgCI,CAAC,EAAjC,EAAqC;AAEnC,QAAIC,EAAE,GAAGP,GAAG,CAACM,CAAD,CAAZ;;AACA,QAAIU,aAAa,KAAKN,SAAtB,EAAiC;AAC/B,UAAI,CAACF,aAAa,CAACD,EAAD,CAAlB,EAAwB;AACtB,YAAIA,EAAE,KAAK,GAAX,EAAgB;AACdW,UAAAA,OAAO,GAAG,IAAV;AACD,SAFD,MAEO,IAAIX,EAAE,KAAK,GAAX,EAAgB;AACrBY,UAAAA,QAAQ,GAAG,IAAX;AACD,SAFM,MAEA,IAAIZ,EAAE,KAAK,GAAX,EAAgB;AACrBa,UAAAA,QAAQ,GAAG,IAAX;AACD,SAFM,MAEA,IAAII,gBAAgB,CAACxB,GAAD,EAAMM,CAAN,CAApB,EAA8B;AACnCU,UAAAA,aAAa,GAAGV,CAAhB;AACAA,UAAAA,CAAC,GAAGA,CAAC,GAAG,CAAR;AACAW,UAAAA,WAAW,GAAGX,CAAd;AACAR,UAAAA,KAAK,GAAG,IAAR;AACA;AACD,SANM,MAMA,IAAI2B,iBAAiB,CAACzB,GAAD,EAAMM,CAAN,CAArB,EAA+B;AACpCU,UAAAA,aAAa,GAAGV,CAAhB;AACAA,UAAAA,CAAC,GAAGA,CAAC,GAAG,CAAR;AACAW,UAAAA,WAAW,GAAGX,CAAd;AACAR,UAAAA,KAAK,GAAG,KAAR;AACA;AACD,SANM,MAMA,IAAI4B,gBAAgB,CAAC1B,GAAD,EAAMM,CAAN,CAApB,EAA8B;AACnCU,UAAAA,aAAa,GAAGV,CAAhB;AACAA,UAAAA,CAAC,GAAGA,CAAC,GAAG,CAAR;AACAW,UAAAA,WAAW,GAAGX,CAAd;AACAR,UAAAA,KAAK,GAAG,IAAR;AACA;AACD,SANM,MAMA,IAAI6B,SAAS,CAACpB,EAAD,CAAb,EAAmB;AACxBc,UAAAA,QAAQ,GAAG,IAAX;AACD,SAFM,MAEA,IAAId,EAAE,KAAK,GAAX,EAAgB;AACrBc,UAAAA,QAAQ,GAAG,IAAX;AACD,SAFM,MAEA;AACL,gBAAMZ,YAAY,CAACT,GAAD,EAAMM,CAAN,EAAS,EAAT,CAAlB;AACD;;AACDU,QAAAA,aAAa,GAAGV,CAAhB;AACD;AACF,KAnCD,MAmCO;AACL,UAAIY,OAAJ,EAAa;AACX,YAAIU,GAAG,GAAGC,UAAU,CAAC7B,GAAD,EAAMM,CAAN,EAASd,mBAAT,EAA8BF,KAA9B,CAApB;;AACA2B,QAAAA,WAAW,GAAGW,GAAG,CAAChB,GAAlB;AACAd,QAAAA,KAAK,GAAG8B,GAAG,CAAC9B,KAAZ;AACA;AACD,OALD,MAKO,IAAIqB,QAAJ,EAAc;AACnB,YAAIW,GAAG,GAAGC,WAAW,CAAC/B,GAAD,EAAMM,CAAN,EAASd,mBAAT,EAA8BF,KAA9B,CAArB;;AACA2B,QAAAA,WAAW,GAAGa,GAAG,CAAClB,GAAlB;AACAd,QAAAA,KAAK,GAAGgC,GAAG,CAAChC,KAAZ;AACA;AACD,OALM,MAKA,IAAIsB,QAAQ,IAAIb,EAAE,KAAK,GAAnB,IAA0ByB,yBAAyB,CAAChC,GAAD,EAAMM,CAAC,GAAG,CAAV,CAAvD,EAAqE;AAC1EW,QAAAA,WAAW,GAAGX,CAAd;AACAR,QAAAA,KAAK,GAAGb,SAAS,CAACe,GAAG,CAACiC,SAAJ,CAAcjB,aAAa,GAAG,CAA9B,EAAiCC,WAAjC,CAAD,CAAjB;AACA;AACD,OAJM,MAIA,IAAII,QAAJ,EAAc;AACnB,YAAGb,aAAa,CAACD,EAAD,CAAhB,EAAsB;AACpBgB,UAAAA,kBAAkB,GAAG,IAArB;AACD,SAFD,MAEO,IAAIhB,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAArB,IAA4BA,EAAE,KAAK,GAAvC,EAA4C;AACjDT,UAAAA,KAAK,GAAGoC,UAAU,CAAClC,GAAG,CAACiC,SAAJ,CAAcjB,aAAd,EAA6BC,WAA7B,CAAD,EAA4C,EAA5C,CAAlB;AACAA,UAAAA,WAAW,GAAGX,CAAC,GAAG,CAAlB;AACA;AACD,SAJM,MAIA,IAAIqB,SAAS,CAACpB,EAAD,CAAT,IAAiB,CAACgB,kBAAtB,EAA0C;AAC/C;AACD,SAFM,MAEA,IAAIhB,EAAE,KAAK,GAAP,IAAc,CAACe,QAAf,IAA2B,CAACC,kBAAhC,EAAoD;AACzDD,UAAAA,QAAQ,GAAG,IAAX;AACD,SAFM,MAEA;AACL,gBAAMb,YAAY,CAACT,GAAD,EAAMM,CAAN,EAAS,kBAAT,CAAlB;AACD;AACF;AACF;AACF;;AAED,MAAIW,WAAW,KAAKP,SAApB,EAA+B;AAC7B,QAAIW,QAAJ,EAAc;AACZvB,MAAAA,KAAK,GAAGoC,UAAU,CAAClC,GAAG,CAACiC,SAAJ,CAAcjB,aAAd,EAA6BV,CAA7B,CAAD,EAAkC,EAAlC,CAAlB;AACAW,MAAAA,WAAW,GAAGX,CAAC,GAAG,CAAlB;AACD,KAHD,MAGO;AACL,YAAMG,YAAY,CAACT,GAAD,EAAMM,CAAN,EAAS,oBAAT,CAAlB;AACD;AACF;;AACDW,EAAAA,WAAW;AACX,SAAO;AACLnB,IAAAA,KAAK,EAAEA,KADF;AAELa,IAAAA,KAAK,EAAEK,aAFF;AAGLJ,IAAAA,GAAG,EAAEK;AAHA,GAAP;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASkB,QAAT,CAAkBnC,GAAlB,EAAuBC,QAAvB,EAAiC;AAC/B,MAAIC,GAAG,GAAGF,GAAG,CAACG,MAAd;AACA,MAAIiC,WAAJ;AACA,MAAIC,SAAJ;;AACA,OAAK,IAAI/B,CAAC,GAAGL,QAAb,EAAuBK,CAAC,GAAGJ,GAA3B,EAAgCI,CAAC,EAAjC,EAAqC;AACnC,QAAIC,EAAE,GAAGP,GAAG,CAACM,CAAD,CAAZ;;AACA,QAAI8B,WAAW,KAAK1B,SAApB,EAA+B;AAC7B,UAAI,CAACF,aAAa,CAACD,EAAD,CAAlB,EAAwB;AACtB,YAAIA,EAAE,KAAK,GAAX,EAAgB;AACd,gBAAME,YAAY,CAACT,GAAD,EAAMM,CAAN,EAAS,kBAAT,CAAlB;AACD;;AACD8B,QAAAA,WAAW,GAAG9B,CAAd;AACD;AACF,KAPD,MAOO;AACL,UAAIC,EAAE,KAAK,GAAP,IAAcyB,yBAAyB,CAAChC,GAAD,EAAMM,CAAC,GAAG,CAAV,CAA3C,EAAyD;AACvD+B,QAAAA,SAAS,GAAG/B,CAAZ;AACA;AACD;AACF;AACF;;AAED,MAAI+B,SAAS,KAAK3B,SAAlB,EAA6B;AAC3B,UAAMD,YAAY,CAACT,GAAD,EAAME,GAAN,EAAW,kBAAX,CAAlB;AACD;;AAED,MAAIJ,KAAK,GAAGb,SAAS,CAACe,GAAG,CAACiC,SAAJ,CAAcG,WAAW,GAAG,CAA5B,EAA+BC,SAA/B,CAAD,CAArB;;AACA,MAAIvC,KAAK,KAAK,EAAd,EAAkB;AAChB,UAAMW,YAAY,CAACT,GAAD,EAAMoC,WAAN,EAAmB,cAAnB,CAAlB;AACD;;AACDC,EAAAA,SAAS;AACT,SAAO;AACL1B,IAAAA,KAAK,EAAEyB,WADF;AAELxB,IAAAA,GAAG,EAAEyB,SAFA;AAGLvC,IAAAA,KAAK,EAAEA;AAHF,GAAP;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiC,WAAT,CAAqB/B,GAArB,EAA0BC,QAA1B,EAAoCT,mBAApC,EAAyDF,KAAzD,EAAgE;AAC9D,MAAIgB,CAAC,GAAGL,QAAR;AACA,MAAIqC,QAAQ,GAAG,GAAf;AACA,MAAIR,GAAG,GAAG,EAAV;AACA,MAAIS,IAAI,GAAG,EAAX;AACA,MAAIC,MAAM,GAAG,EAAb;AAEA,MAAIC,CAAC,GAAGxC,QAAR;;AACA,SAAOO,aAAa,CAACR,GAAG,CAACyC,CAAD,CAAJ,CAApB,EAA8B;AAC5BA,IAAAA,CAAC;AACF;;AAED,MAAIzC,GAAG,CAACyC,CAAD,CAAH,KAAW,GAAf,EAAoB;AAClB,WAAO;AACL9B,MAAAA,KAAK,EAAEV,QADF;AAELW,MAAAA,GAAG,EAAE6B,CAFA;AAGL3C,MAAAA,KAAK,EAAEgC;AAHF,KAAP;AAKD;;AAED,SAAOQ,QAAQ,KAAK,GAApB,EAAyB;AACvB,QAAII,GAAG,GAAGP,QAAQ,CAACnC,GAAD,EAAMM,CAAN,CAAlB;;AACA,QAAIqC,IAAI,GAAG9B,uBAAuB,CAACb,GAAD,EAAM0C,GAAG,CAAC9B,GAAV,CAAlC;;AACA,QAAId,KAAK,GAAGJ,UAAU,CAACM,GAAD,EAAM2C,IAAI,CAAC/B,GAAX,EAAgBpB,mBAAhB,EAAqCF,KAArC,CAAtB;;AACA,QAAIsD,QAAQ,GAAG7C,cAAc,CAACC,GAAD,EAAMF,KAAK,CAACc,GAAZ,CAA7B;;AAEA,QAAI,CAACpB,mBAAL,EAA0B;AACxB,UAAG+C,IAAI,CAACM,OAAL,CAAaH,GAAG,CAAC5C,KAAjB,MAA4B,CAAC,CAAhC,EAAmC;AACjC4C,QAAAA,GAAG,CAAC5C,KAAJ,GAAY4C,GAAG,CAAC5C,KAAJ,GAAY,GAAxB,CADiC,CAEjC;AACD;AACF;;AACDyC,IAAAA,IAAI,CAACO,IAAL,CAAUJ,GAAG,CAAC5C,KAAd;AACA0C,IAAAA,MAAM,CAACM,IAAP,CAAYhD,KAAK,CAACA,KAAlB;AACAQ,IAAAA,CAAC,GAAGsC,QAAQ,CAAChC,GAAb;AACA0B,IAAAA,QAAQ,GAAGM,QAAQ,CAAC9C,KAApB;AACD;;AAED,MAAIR,KAAJ,EAAW;AACT,QAAIyD,IAAI,GAAG,CAAX;;AACA,SAAIA,IAAI,GAAG,CAAX,EAAcA,IAAI,GAAGR,IAAI,CAACpC,MAA1B,EAAkC4C,IAAI,EAAtC,EAA0C;AACxCjB,MAAAA,GAAG,CAACS,IAAI,CAACQ,IAAD,CAAL,CAAH,GAAkBP,MAAM,CAACO,IAAD,CAAxB;AACD;AACF;;AAED,SAAO;AACLpC,IAAAA,KAAK,EAAEV,QADF;AAELW,IAAAA,GAAG,EAAEN,CAFA;AAGLR,IAAAA,KAAK,EAAEgC;AAHF,GAAP;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,yBAAT,CAAmChC,GAAnC,EAAwCgD,MAAxC,EAAgD;AAC9C,MAAI1C,CAAC,GAAG0C,MAAR;AACA,MAAIC,KAAK,GAAG,CAAZ;;AACA,SAAM3C,CAAC,GAAG,CAAC,CAAL,IAAUN,GAAG,CAACM,CAAD,CAAH,KAAW,IAA3B,EAAiC;AAC/B2C,IAAAA,KAAK;AACL3C,IAAAA,CAAC;AACF;;AACD,SAAQ2C,KAAK,GAAG,CAAT,KAAgB,CAAvB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASpB,UAAT,CAAoB7B,GAApB,EAAyBC,QAAzB,EAAmCT,mBAAnC,EAAwDF,KAAxD,EAA+D;AAC7D,MAAIgB,CAAC,GAAGL,QAAR;AACA,MAAIqC,QAAQ,GAAG,GAAf;AACA,MAAIV,GAAG,GAAG,EAAV;AAEA,MAAIa,CAAC,GAAGxC,QAAR;;AACA,SAAOO,aAAa,CAACR,GAAG,CAACyC,CAAD,CAAJ,CAApB,EAA8B;AAC5BA,IAAAA,CAAC;AACF;;AAED,MAAIzC,GAAG,CAACyC,CAAD,CAAH,KAAW,GAAf,EAAoB;AAClB,WAAO;AACL9B,MAAAA,KAAK,EAAEV,QADF;AAELW,MAAAA,GAAG,EAAE6B,CAFA;AAGL3C,MAAAA,KAAK,EAAE8B;AAHF,KAAP;AAKD;;AAED,SAAOU,QAAQ,KAAK,GAApB,EAAyB;AACvB,QAAIxC,KAAK,GAAGJ,UAAU,CAACM,GAAD,EAAMM,CAAN,EAASd,mBAAT,EAA8BF,KAA9B,CAAtB;;AACA,QAAIsD,QAAQ,GAAG7C,cAAc,CAACC,GAAD,EAAMF,KAAK,CAACc,GAAZ,CAA7B;;AAEA,QAAItB,KAAJ,EAAW;AACTsC,MAAAA,GAAG,CAACkB,IAAJ,CAAShD,KAAK,CAACA,KAAf;AACD;;AACDQ,IAAAA,CAAC,GAAGsC,QAAQ,CAAChC,GAAb;AACA0B,IAAAA,QAAQ,GAAGM,QAAQ,CAAC9C,KAApB;AACD;;AACD,SAAO;AACLa,IAAAA,KAAK,EAAEV,QADF;AAELW,IAAAA,GAAG,EAAEN,CAFA;AAGLR,IAAAA,KAAK,EAAE8B;AAHF,GAAP;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASJ,gBAAT,CAA0BxB,GAA1B,EAA+BkD,GAA/B,EAAoC;AAClC,SAAQlD,GAAG,CAACmD,MAAJ,CAAWD,GAAX,EAAgB,CAAhB,MAAuB,MAA/B;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASzB,iBAAT,CAA2BzB,GAA3B,EAAgCkD,GAAhC,EAAqC;AACnC,SAAQlD,GAAG,CAACmD,MAAJ,CAAWD,GAAX,EAAgB,CAAhB,MAAuB,OAA/B;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASxB,gBAAT,CAA0B1B,GAA1B,EAA+BkD,GAA/B,EAAoC;AAClC,SAAQlD,GAAG,CAACmD,MAAJ,CAAWD,GAAX,EAAgB,CAAhB,MAAuB,MAA/B;AACD;;AAED,IAAIE,KAAK,GAAG,IAAIC,MAAJ,CAAW,MAAX,CAAZ;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAS7C,aAAT,CAAuBD,EAAvB,EAA0B;AACxB,SAAO6C,KAAK,CAACE,IAAN,CAAW/C,EAAX,CAAP;AACD;;AAED,IAAIgD,SAAS,GAAG,IAAIF,MAAJ,CAAW,MAAX,CAAhB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAS1B,SAAT,CAAmBpB,EAAnB,EAAuB;AACrB,SAAOgD,SAAS,CAACD,IAAV,CAAe/C,EAAf,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,YAAT,CAAsBT,GAAtB,EAA2BwD,KAA3B,EAAkCC,MAAlC,EAA0C;AACxC,MAAIC,SAAS,GAAG,EAAhB;AAEA,MAAIC,SAAJ;;AACA,MAAI3D,GAAG,CAACG,MAAJ,GAAaqD,KAAK,GAAGE,SAAzB,EAAoC;AAClCC,IAAAA,SAAS,GAAG3D,GAAG,CAACmD,MAAJ,CAAWS,wBAAwB,CAAC5D,GAAG,CAACG,MAAJ,GAAauD,SAAd,CAAnC,EAA6D1D,GAAG,CAACG,MAAjE,CAAZ;AACD,GAFD,MAEO,IAAIqD,KAAK,GAAIE,SAAS,GAAC,CAAnB,GAAwB,CAA5B,EAA+B;AACpCC,IAAAA,SAAS,GAAG3D,GAAG,CAACmD,MAAJ,CAAW,CAAX,EAAcO,SAAd,CAAZ;AACD,GAFM,MAEA;AACLC,IAAAA,SAAS,GAAG3D,GAAG,CAACmD,MAAJ,CAAWS,wBAAwB,CAACJ,KAAK,GAAIE,SAAS,GAAC,CAApB,CAAnC,EAA4DA,SAA5D,CAAZ;AACD;;AAED,MAAI9D,OAAJ;;AACA,MAAI6D,MAAJ,EAAY;AACV7D,IAAAA,OAAO,GAAG,mBAAmB6D,MAAnB,GAA4B,QAA5B,GAAuCE,SAAjD;AACD,GAFD,MAEO;AACL/D,IAAAA,OAAO,GAAG,uBAAuB+D,SAAjC;AACD;;AACD,SAAO,IAAI9D,KAAJ,CAAUD,OAAV,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgE,wBAAT,CAAkCC,GAAlC,EAAuC;AACrC,SAAQA,GAAG,GAAG,CAAP,GAAY,CAAZ,GAAgBA,GAAvB;AACD","sourcesContent":["var backslash = require('backslash');\nmodule.exports = {\n  validate: validate,\n  parse: parse\n};\n\n/**\n * Validates a json string.\n * Errors are returned\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {String} error. undefined if no error\n */\nfunction validate(jsonString, allowDuplicatedKeys) {\n  var error;\n  allowDuplicatedKeys = allowDuplicatedKeys || false;\n  if (typeof jsonString !== 'string') {\n    error = 'Input must be a string';\n  } else {\n    try {\n      // Try to find a value starting from index 0\n      _findValue(jsonString, 0, allowDuplicatedKeys, false);\n    } catch(e) {\n      error = e.message;\n    }\n  }\n  return error;\n}\n\n/**\n * Parses a json. Errors are thrown if any\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {Object}\n */\nfunction parse(jsonString, allowDuplicatedKeys) {\n  if (typeof jsonString !== 'string') {\n    throw new Error('Input must be a string');\n  }\n\n  allowDuplicatedKeys = allowDuplicatedKeys || false;\n\n  // Try to find a value starting from index 0\n  var value = _findValue(jsonString, 0, allowDuplicatedKeys, true);\n  return value.value;\n}\n\n/**\n * Find the comma separator, ], } or end of file\n * @param {String} str - original json string\n * @param {Number} startInd - starting index\n * @returns {{start: Number, end: Number, value: String}} value: the separator found\n * @private\n */\nfunction _findSeparator(str, startInd) {\n  var len = str.length;\n  var sepStartInd = startInd;\n  var sepEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (ch === ',') {\n      sepEndInd = i;\n      break;\n    } else if ( ch === ']' || ch === '}') {\n      sepEndInd = i - 1;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting end of expression or separator');\n    }\n  }\n\n  var value;\n  if (sepEndInd === undefined) {\n    sepEndInd = len;\n    value = str[sepEndInd];\n  } else {\n    value = str[sepEndInd];\n    sepEndInd++;\n  }\n  return {\n    start: sepStartInd,\n    end: sepEndInd,\n    value: value\n  };\n}\n\n/**\n * Find the semi-colon separator ':'\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number}}\n * @private\n */\nfunction _findSemiColonSeparator(str, startInd) {\n  var len = str.length;\n  var semiColStartInd = startInd;\n  var semiColEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (ch === ':') {\n      semiColEndInd = i;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting \\':\\'');\n    }\n  }\n  if (semiColEndInd === undefined) {\n    throw _syntaxError(str, i, 'expecting \\':\\'');\n  }\n  semiColEndInd++;\n  return {\n    start: semiColStartInd,\n    end: semiColEndInd\n  };\n}\n\n/**\n * Find a value it can be number, array, object, strings or boolean\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys - allow duplicated keys in objects or not\n * @returns {{value: *, start: Number, end: Number}}\n * @private\n */\nfunction _findValue(str, startInd, allowDuplicatedKeys, parse) {\n  var len = str.length;\n  var valueStartInd;\n  var valueEndInd;\n  var isArray = false;\n  var isObject = false;\n  var isString = false;\n  var isNumber = false;\n  var dotFound = false;\n  var whiteSpaceInNumber = false;\n  var value;\n\n  for (var i = startInd; i < len; i++) {\n\n    var ch = str[i];\n    if (valueStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch === '[') {\n          isArray = true;\n        } else if (ch === '{') {\n          isObject = true;\n        } else if (ch === '\"') {\n          isString = true;\n        } else if (_isTrueFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = true;\n          break;\n        } else if (_isFalseFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 4;\n          valueEndInd = i;\n          value = false;\n          break;\n        } else if (_isNullFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = null;\n          break;\n        } else if (_isNumber(ch)) {\n          isNumber = true;\n        } else if (ch === '-') {\n          isNumber = true;\n        } else {\n          throw _syntaxError(str, i, '');\n        }\n        valueStartInd = i;\n      }\n    } else {\n      if (isArray) {\n        var arr = _findArray(str, i, allowDuplicatedKeys, parse);\n        valueEndInd = arr.end;\n        value = arr.value;\n        break;\n      } else if (isObject) {\n        var obj = _findObject(str, i, allowDuplicatedKeys, parse);\n        valueEndInd = obj.end;\n        value = obj.value;\n        break;\n      } else if (isString && ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        valueEndInd = i;\n        value = backslash(str.substring(valueStartInd + 1, valueEndInd));\n        break;\n      } else if (isNumber) {\n        if(_isWhiteSpace(ch)) {\n          whiteSpaceInNumber = true;\n        } else if (ch === ',' || ch === ']' || ch === '}') {\n          value = parseFloat(str.substring(valueStartInd, valueEndInd), 10);\n          valueEndInd = i - 1;\n          break;\n        } else if (_isNumber(ch) && !whiteSpaceInNumber) {\n          continue;\n        } else if (ch === '.' && !dotFound && !whiteSpaceInNumber) {\n          dotFound = true;\n        } else {\n          throw _syntaxError(str, i, 'expecting number');\n        }\n      }\n    }\n  }\n\n  if (valueEndInd === undefined) {\n    if (isNumber) {\n      value = parseFloat(str.substring(valueStartInd, i), 10);\n      valueEndInd = i - 1;\n    } else {\n      throw _syntaxError(str, i, 'unclosed statement');\n    }\n  }\n  valueEndInd++;\n  return {\n    value: value,\n    start: valueStartInd,\n    end: valueEndInd\n  };\n}\n\n/**\n * Find a key in an object\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: String}}\n * @private\n */\nfunction _findKey(str, startInd) {\n  var len = str.length;\n  var keyStartInd;\n  var keyEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (keyStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch !== '\"') {\n          throw _syntaxError(str, i, 'expecting String');\n        }\n        keyStartInd = i;\n      }\n    } else {\n      if (ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        keyEndInd = i;\n        break;\n      }\n    }\n  }\n\n  if (keyEndInd === undefined) {\n    throw _syntaxError(str, len, 'expecting String');\n  }\n\n  var value = backslash(str.substring(keyStartInd + 1, keyEndInd));\n  if (value === '') {\n    throw _syntaxError(str, keyStartInd, 'empty string');\n  }\n  keyEndInd++;\n  return {\n    start: keyStartInd,\n    end: keyEndInd,\n    value: value\n  };\n}\n\n/**\n * Find an object by identifying the key, ':' separator and value\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys\n * @returns {{start: Number, end: Number, value: Object}}\n * @private\n */\nfunction _findObject(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var obj = {};\n  var keys = [];\n  var values = [];\n\n  var j = startInd;\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n\n  if (str[j] === '}') {\n    return {\n      start: startInd,\n      end: j,\n      value: obj\n    };\n  }\n\n  while (sepValue === ',') {\n    var key = _findKey(str, i);\n    var semi = _findSemiColonSeparator(str, key.end);\n    var value = _findValue(str, semi.end, allowDuplicatedKeys, parse);\n    var sepIndex = _findSeparator(str, value.end);\n\n    if (!allowDuplicatedKeys) {\n      if(keys.indexOf(key.value) !== -1) {\n        key.value = key.value + '1';\n        // throw _syntaxError(str, key.end, 'duplicated keys \"' + key.value + '\"');\n      }\n    }\n    keys.push(key.value);\n    values.push(value.value);\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n\n  if (parse) {\n    var indx = 0;\n    for(indx = 0; indx < keys.length; indx++) {\n      obj[keys[indx]] = values[indx];\n    }\n  }\n\n  return {\n    start: startInd,\n    end: i,\n    value: obj\n  };\n}\n\n/**\n * Going backward from an index, determine if there are even number\n * of consecutive backslashes in the string\n * @param {String} str - original json string\n * @param {Number} endInd\n * @returns {Boolean}\n * @private\n */\nfunction _hasEvenNumberOfBackSlash(str, endInd) {\n  var i = endInd;\n  var count = 0;\n  while(i > -1 && str[i] === '\\\\') {\n    count++;\n    i--;\n  }\n  return (count % 2) === 0;\n}\n\n/**\n * Find an array by identifying values separated by ',' separator\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: Array}}\n * @private\n */\nfunction _findArray(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var arr = [];\n\n  var j = startInd;\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n\n  if (str[j] === ']') {\n    return {\n      start: startInd,\n      end: j,\n      value: arr\n    };\n  }\n\n  while (sepValue === ',') {\n    var value = _findValue(str, i, allowDuplicatedKeys, parse);\n    var sepIndex = _findSeparator(str, value.end);\n\n    if (parse) {\n      arr.push(value.value);\n    }\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n  return {\n    start: startInd,\n    end: i,\n    value: arr\n  };\n}\n\n/**\n * Determine if the string is 'true' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isTrueFromIndex(str, ind) {\n  return (str.substr(ind, 4) === 'true');\n}\n\n/**\n * Determine if the string is 'false' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isFalseFromIndex(str, ind) {\n  return (str.substr(ind, 5) === 'false');\n}\n\n/**\n * Determine if the string is 'null' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isNullFromIndex(str, ind) {\n  return (str.substr(ind, 4) === 'null');\n}\n\nvar white = new RegExp(/^\\s$/);\n/**\n * Determine if this character is a white space\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\nfunction _isWhiteSpace(ch){\n  return white.test(ch);\n}\n\nvar numberReg = new RegExp(/^\\d$/);\n/**\n * Determine if this character is a numeric character\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\nfunction _isNumber(ch) {\n  return numberReg.test(ch);\n}\n\n/**\n * Generate syntax error\n * @param {String} str - original json string\n * @param {Number} index - index in which the error was detected\n * @param {String} reason\n * @returns {Error}\n * @private\n */\nfunction _syntaxError(str, index, reason) {\n  var regionLen = 10;\n\n  var regionStr;\n  if (str.length < index + regionLen) {\n    regionStr = str.substr(_normalizeNegativeNumber(str.length - regionLen), str.length);\n  } else if (index - (regionLen/2) < 0) {\n    regionStr = str.substr(0, regionLen);\n  } else {\n    regionStr = str.substr(_normalizeNegativeNumber(index - (regionLen/2)), regionLen);\n  }\n\n  var message;\n  if (reason) {\n    message = 'Syntax error: ' + reason + ' near ' + regionStr;\n  } else {\n    message = 'Syntax error near ' + regionStr;\n  }\n  return new Error(message);\n}\n\n/**\n * Return 0 if number is negative, the original number otherwise\n * @param {Number} num\n * @returns {Number}\n * @private\n */\nfunction _normalizeNegativeNumber(num) {\n  return (num < 0) ? 0 : num;\n}"]},"metadata":{},"sourceType":"script"}