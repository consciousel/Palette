{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OptionValueBinaryCodec = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst typesystem_1 = require(\"../typesystem\");\n/**\n * Encodes and decodes \"OptionValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\n\n\nclass OptionValueBinaryCodec {\n  constructor(binaryCodec) {\n    this.binaryCodec = binaryCodec;\n  }\n\n  decodeNested(buffer, type) {\n    if (buffer[0] == 0x00) {\n      return [typesystem_1.OptionValue.newMissingType(type), 1];\n    }\n\n    if (buffer[0] != 0x01) {\n      throw new errors.ErrCodec(\"invalid buffer for optional value\");\n    }\n\n    let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer.slice(1), type);\n    return [typesystem_1.OptionValue.newProvided(decoded), decodedLength + 1];\n  }\n\n  decodeTopLevel(buffer, type) {\n    if (buffer.length == 0) {\n      return new typesystem_1.OptionValue(type);\n    }\n\n    if (buffer[0] != 0x01) {\n      throw new errors.ErrCodec(\"invalid buffer for optional value\");\n    }\n\n    let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer.slice(1), type);\n    return new typesystem_1.OptionValue(type, decoded);\n  }\n\n  encodeNested(optionValue) {\n    if (optionValue.isSet()) {\n      return Buffer.concat([Buffer.from([1]), this.binaryCodec.encodeNested(optionValue.getTypedValue())]);\n    }\n\n    return Buffer.from([0]);\n  }\n\n  encodeTopLevel(optionValue) {\n    if (optionValue.isSet()) {\n      return Buffer.concat([Buffer.from([1]), this.binaryCodec.encodeNested(optionValue.getTypedValue())]);\n    }\n\n    return Buffer.from([]);\n  }\n\n}\n\nexports.OptionValueBinaryCodec = OptionValueBinaryCodec;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;AAGA;;;;;;AAIA,MAAaA,sBAAb,CAAmC;AAG/BC,cAAYC,WAAZ,EAAoC;AAChC,SAAKA,WAAL,GAAmBA,WAAnB;AACH;;AAEDC,cAAY,CAACC,MAAD,EAAiBC,IAAjB,EAA2B;AACnC,QAAID,MAAM,CAAC,CAAD,CAAN,IAAa,IAAjB,EAAuB;AACnB,aAAO,CAACE,yBAAYC,cAAZ,CAA2BF,IAA3B,CAAD,EAAmC,CAAnC,CAAP;AACH;;AAED,QAAID,MAAM,CAAC,CAAD,CAAN,IAAa,IAAjB,EAAuB;AACnB,YAAM,IAAII,MAAM,CAACC,QAAX,CAAoB,mCAApB,CAAN;AACH;;AAED,QAAI,CAACC,OAAD,EAAUC,aAAV,IAA2B,KAAKT,WAAL,CAAiBC,YAAjB,CAA8BC,MAAM,CAACQ,KAAP,CAAa,CAAb,CAA9B,EAA+CP,IAA/C,CAA/B;AACA,WAAO,CAACC,yBAAYO,WAAZ,CAAwBH,OAAxB,CAAD,EAAmCC,aAAa,GAAG,CAAnD,CAAP;AACH;;AAEDG,gBAAc,CAACV,MAAD,EAAiBC,IAAjB,EAA2B;AACrC,QAAID,MAAM,CAACW,MAAP,IAAiB,CAArB,EAAwB;AACpB,aAAO,IAAIT,wBAAJ,CAAgBD,IAAhB,CAAP;AACH;;AAED,QAAID,MAAM,CAAC,CAAD,CAAN,IAAa,IAAjB,EAAuB;AACnB,YAAM,IAAII,MAAM,CAACC,QAAX,CAAoB,mCAApB,CAAN;AACH;;AAED,QAAI,CAACC,OAAD,EAAUC,aAAV,IAA2B,KAAKT,WAAL,CAAiBC,YAAjB,CAA8BC,MAAM,CAACQ,KAAP,CAAa,CAAb,CAA9B,EAA+CP,IAA/C,CAA/B;AACA,WAAO,IAAIC,wBAAJ,CAAgBD,IAAhB,EAAsBK,OAAtB,CAAP;AACH;;AAEDM,cAAY,CAACC,WAAD,EAAyB;AACjC,QAAIA,WAAW,CAACC,KAAZ,EAAJ,EAAyB;AACrB,aAAOC,MAAM,CAACC,MAAP,CAAc,CAACD,MAAM,CAACE,IAAP,CAAY,CAAC,CAAD,CAAZ,CAAD,EAAmB,KAAKnB,WAAL,CAAiBc,YAAjB,CAA8BC,WAAW,CAACK,aAAZ,EAA9B,CAAnB,CAAd,CAAP;AACH;;AAED,WAAOH,MAAM,CAACE,IAAP,CAAY,CAAC,CAAD,CAAZ,CAAP;AACH;;AAEDE,gBAAc,CAACN,WAAD,EAAyB;AACnC,QAAIA,WAAW,CAACC,KAAZ,EAAJ,EAAyB;AACrB,aAAOC,MAAM,CAACC,MAAP,CAAc,CAACD,MAAM,CAACE,IAAP,CAAY,CAAC,CAAD,CAAZ,CAAD,EAAmB,KAAKnB,WAAL,CAAiBc,YAAjB,CAA8BC,WAAW,CAACK,aAAZ,EAA9B,CAAnB,CAAd,CAAP;AACH;;AAED,WAAOH,MAAM,CAACE,IAAP,CAAY,EAAZ,CAAP;AACH;;AA/C8B;;AAAnCG","names":["OptionValueBinaryCodec","constructor","binaryCodec","decodeNested","buffer","type","typesystem_1","newMissingType","errors","ErrCodec","decoded","decodedLength","slice","newProvided","decodeTopLevel","length","encodeNested","optionValue","isSet","Buffer","concat","from","getTypedValue","encodeTopLevel","exports"],"sourceRoot":"","sources":["../../../src/smartcontracts/codec/option.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}