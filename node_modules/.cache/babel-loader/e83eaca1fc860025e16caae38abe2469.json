{"ast":null,"code":"import { AbiCoder, formatSignature as _formatSignature } from '@vechain/ethers/utils/abi-coder';\nimport { keccak256 } from './cry/keccak';\n\nclass Coder extends AbiCoder {\n  constructor() {\n    super((type, value) => {\n      if (type.match(/^u?int/) && !Array.isArray(value) && typeof value !== 'object' || value._ethersType === 'BigNumber') {\n        return value.toString();\n      }\n\n      return value;\n    });\n  }\n\n  encode(types, values) {\n    try {\n      return super.encode(types, values);\n    } catch (err) {\n      if (err.reason) {\n        throw new Error(err.reason);\n      }\n\n      throw err;\n    }\n  }\n\n  decode(types, data) {\n    try {\n      return super.decode(types, data);\n    } catch (err) {\n      if (err.reason) {\n        throw new Error(err.reason);\n      }\n\n      throw err;\n    }\n  }\n\n}\n\nconst coder = new Coder();\n\nfunction formatSignature(fragment) {\n  try {\n    return _formatSignature(fragment);\n  } catch (err) {\n    if (err.reason) {\n      throw new Error(err.reason);\n    }\n\n    throw err;\n  }\n}\n/** encode/decode parameters of contract function call, event log, according to ABI JSON */\n\n\nexport var abi;\n\n(function (abi) {\n  /**\n   * encode single parameter\n   * @param type type of the parameter\n   * @param value value of the parameter\n   * @returns encoded value in hex string\n   */\n  function encodeParameter(type, value) {\n    return coder.encode([type], [value]);\n  }\n\n  abi.encodeParameter = encodeParameter;\n  /**\n   * decode single parameter\n   * @param type type of the parameter\n   * @param data encoded parameter in hex string\n   * @returns decoded value\n   */\n\n  function decodeParameter(type, data) {\n    return coder.decode([type], data)[0];\n  }\n\n  abi.decodeParameter = decodeParameter;\n  /**\n   * encode a group of parameters\n   * @param types type array\n   * @param values value array\n   * @returns encoded values in hex string\n   */\n\n  function encodeParameters(types, values) {\n    return coder.encode(types, values);\n  }\n\n  abi.encodeParameters = encodeParameters;\n  /**\n   * decode a group of parameters\n   * @param types type array\n   * @param data encoded values in hex string\n   * @returns decoded object\n   */\n\n  function decodeParameters(types, data) {\n    const result = coder.decode(types, data);\n    const decoded = {};\n    types.forEach((t, i) => {\n      decoded[i] = result[i];\n\n      if (t.name) {\n        decoded[t.name] = result[i];\n      }\n    });\n    return decoded;\n  }\n\n  abi.decodeParameters = decodeParameters;\n  /** for contract function */\n\n  class Function {\n    /**\n     * create a function object\n     * @param definition abi definition of the function\n     */\n    constructor(definition) {\n      this.definition = definition;\n      this.canonicalName = formatSignature(definition);\n      this.signature = '0x' + keccak256(this.canonicalName).slice(0, 4).toString('hex');\n    }\n    /**\n     * encode input parameters into call data\n     * @param args arguments for the function\n     */\n\n\n    encode() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.signature + encodeParameters(this.definition.inputs, args).slice(2);\n    }\n    /**\n     * decode output data\n     * @param outputData output data to decode\n     */\n\n\n    decode(outputData) {\n      return decodeParameters(this.definition.outputs, outputData);\n    }\n\n  }\n\n  abi.Function = Function;\n  /** for contract event */\n\n  class Event {\n    /** for contract event */\n    constructor(definition) {\n      this.definition = definition;\n      this.canonicalName = formatSignature(definition);\n      this.signature = '0x' + keccak256(this.canonicalName).toString('hex');\n    }\n    /**\n     * encode an object of indexed keys into topics.\n     * @param indexed an object contains indexed keys\n     */\n\n\n    encode(indexed) {\n      const topics = [];\n\n      if (!this.definition.anonymous) {\n        topics.push(this.signature);\n      }\n\n      for (const input of this.definition.inputs) {\n        if (!input.indexed) {\n          continue;\n        }\n\n        const value = indexed[input.name];\n\n        if (value === undefined || value === null) {\n          topics.push(null);\n        } else {\n          let topic;\n\n          if (isDynamicType(input.type)) {\n            if (input.type === 'string') {\n              topic = '0x' + keccak256(value).toString('hex');\n            } else {\n              if (typeof value === 'string' && /^0x[0-9a-f]+$/i.test(value) && value.length % 2 === 0) {\n                topic = '0x' + keccak256(Buffer.from(value.slice(2), 'hex')).toString('hex');\n              } else {\n                throw new Error(`invalid ${input.type} value`);\n              }\n            }\n          } else {\n            topic = encodeParameter(input.type, value);\n          }\n\n          topics.push(topic);\n        }\n      }\n\n      return topics;\n    }\n    /**\n     * decode event log\n     * @param data data in event output\n     * @param topics topics in event\n     */\n\n\n    decode(data, topics) {\n      if (!this.definition.anonymous) {\n        topics = topics.slice(1);\n      }\n\n      if (this.definition.inputs.filter(t => t.indexed).length !== topics.length) {\n        throw new Error('invalid topics count');\n      }\n\n      const decodedNonIndexed = coder.decode(this.definition.inputs.filter(t => !t.indexed).map(t => t.type), data);\n      const decoded = {};\n      this.definition.inputs.forEach((t, i) => {\n        if (t.indexed) {\n          const topic = topics.shift();\n          decoded[i] = isDynamicType(t.type) ? topic : decodeParameter(t.type, topic);\n        } else {\n          decoded[i] = decodedNonIndexed.shift();\n        }\n\n        if (t.name) {\n          decoded[t.name] = decoded[i];\n        }\n      });\n      return decoded;\n    }\n\n  }\n\n  abi.Event = Event;\n\n  function isDynamicType(type) {\n    return type === 'bytes' || type === 'string' || type.endsWith('[]');\n  }\n})(abi || (abi = {}));","map":{"version":3,"mappings":"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","names":["AbiCoder","formatSignature","_formatSignature","keccak256","Coder","constructor","type","value","match","Array","isArray","_ethersType","toString","encode","types","values","err","reason","Error","decode","data","coder","fragment","abi","encodeParameter","decodeParameter","encodeParameters","decodeParameters","result","decoded","forEach","t","i","name","Function","definition","canonicalName","signature","slice","args","inputs","outputData","outputs","Event","indexed","topics","anonymous","push","input","undefined","topic","isDynamicType","test","length","Buffer","from","filter","decodedNonIndexed","map","shift","endsWith"],"sourceRoot":"","sources":["../src/abi.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}