{"ast":null,"code":"const SIGN_RAW_TX_INS = 0x04;\nconst SIGN_HASH_TX_INS = 0x07;\nconst SIGN_MESSAGE_INS = 0x06;\nconst ACTIVE_SIGNERS = [SIGN_RAW_TX_INS, SIGN_HASH_TX_INS, SIGN_MESSAGE_INS];\nexport default class Elrond {\n  constructor(transport) {\n    let scrambleKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"eGLD\";\n    this.transport = void 0;\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getAddress\", \"setAddress\", \"signTransaction\", \"signMessage\", \"getAppConfiguration\"], scrambleKey);\n  }\n\n  async getAddress(account, index, display) {\n    const cla = 0xed;\n    const ins = 0x03;\n    const p1 = display ? 0x01 : 0x00;\n    const p2 = 0x00;\n    const data = Buffer.alloc(8);\n    data.writeInt32BE(account, 0);\n    data.writeUInt32BE(index, 4);\n    const response = await this.transport.send(cla, ins, p1, p2, data);\n    const addressLength = response[0];\n    const address = response.slice(1, 1 + addressLength).toString(\"ascii\");\n    return {\n      address\n    };\n  }\n\n  async setAddress(account, index, display) {\n    const cla = 0xed;\n    const ins = 0x05;\n    const p1 = display ? 0x01 : 0x00;\n    const p2 = 0x00;\n    const data = Buffer.alloc(8);\n    data.writeInt32BE(account, 0);\n    data.writeUInt32BE(index, 4);\n    return await this.transport.send(cla, ins, p1, p2, data);\n  }\n\n  async signTransaction(rawTx, usingHash) {\n    return usingHash ? this.sign(rawTx, SIGN_HASH_TX_INS) : this.sign(rawTx, SIGN_RAW_TX_INS);\n  }\n\n  async signMessage(message) {\n    return this.sign(message, SIGN_MESSAGE_INS);\n  }\n\n  async getAppConfiguration() {\n    const response = await this.transport.send(0xed, 0x02, 0x00, 0x00);\n    return {\n      contractData: response[0],\n      accountIndex: response[1],\n      addressIndex: response[2],\n      version: `${response[3]}.${response[4]}.${response[5]}`\n    };\n  }\n\n  async sign(message, type) {\n    if (!ACTIVE_SIGNERS.includes(type)) {\n      throw new Error(`invalid sign instruction called: ${type}`);\n    }\n\n    const curveMask = 0x80;\n    const apdus = [];\n    let offset = 0;\n\n    while (offset !== message.length) {\n      const isFirst = offset === 0;\n      const maxChunkSize = 150;\n      const hasMore = offset + maxChunkSize < message.length;\n      const chunkSize = hasMore ? maxChunkSize : message.length - offset;\n      const apdu = {\n        cla: 0xed,\n        ins: type,\n        p1: isFirst ? 0x00 : 0x80,\n        p2: curveMask,\n        data: Buffer.alloc(chunkSize)\n      };\n      message.copy(apdu.data, 0, offset, offset + chunkSize);\n      apdus.push(apdu);\n      offset += chunkSize;\n    }\n\n    let response = Buffer.alloc(0);\n\n    for (let apdu of apdus) {\n      response = await this.transport.send(apdu.cla, apdu.ins, apdu.p1, apdu.p2, apdu.data);\n    }\n\n    if (response.length !== 67 || response[0] !== 64) {\n      throw new Error(\"invalid signature received from ledger device\");\n    }\n\n    return response.slice(1, response.length - 2).toString(\"hex\");\n  }\n\n}","map":{"version":3,"mappings":"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","names":["SIGN_RAW_TX_INS","SIGN_HASH_TX_INS","SIGN_MESSAGE_INS","ACTIVE_SIGNERS","Elrond","constructor","transport","scrambleKey","decorateAppAPIMethods","getAddress","account","index","display","cla","ins","p1","p2","data","Buffer","alloc","writeInt32BE","writeUInt32BE","response","send","addressLength","address","slice","toString","setAddress","signTransaction","rawTx","usingHash","sign","signMessage","message","getAppConfiguration","contractData","accountIndex","addressIndex","version","type","includes","Error","curveMask","apdus","offset","length","isFirst","maxChunkSize","hasMore","chunkSize","apdu","copy","push"],"sources":["../src/Elrond.js"],"sourcesContent":["//@flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\n\nconst SIGN_RAW_TX_INS = 0x04;\nconst SIGN_HASH_TX_INS = 0x07;\nconst SIGN_MESSAGE_INS = 0x06;\n\nconst ACTIVE_SIGNERS = [\n    SIGN_RAW_TX_INS,\n    SIGN_HASH_TX_INS,\n    SIGN_MESSAGE_INS\n];\n\nexport default class Elrond {\n    transport: Transport<*>;\n\n    constructor(transport: Transport<*>, scrambleKey: string = \"eGLD\") {\n        this.transport = transport;\n        transport.decorateAppAPIMethods(\n            this,\n            [\"getAddress\", \"setAddress\", \"signTransaction\", \"signMessage\", \"getAppConfiguration\"],\n            scrambleKey\n        );\n    }\n\n    async getAddress(\n        account: number,\n        index: number,\n        display?: boolean,\n    ): Promise<{\n        publicKey: string,\n        address: string,\n        chainCode?: string,\n    }> {\n        const cla = 0xed;\n        const ins = 0x03;\n        const p1 = display ? 0x01 : 0x00;\n        const p2 = 0x00;\n        const data = Buffer.alloc(8);\n\n        data.writeInt32BE(account, 0);\n        data.writeUInt32BE(index, 4);\n\n        const response = await this.transport.send(cla, ins, p1, p2, data);\n\n        const addressLength = response[0];\n        const address = response.slice(1, 1 + addressLength).toString(\"ascii\");\n\n        return {address};\n    }\n\n    async setAddress(\n        account: number,\n        index: number,\n        display?: boolean,\n    ) {\n        const cla = 0xed;\n        const ins = 0x05;\n        const p1 = display ? 0x01 : 0x00;\n        const p2 = 0x00;\n        const data = Buffer.alloc(8);\n\n        data.writeInt32BE(account, 0);\n        data.writeUInt32BE(index, 4);\n\n        return await this.transport.send(cla, ins, p1, p2, data);\n    }\n\n    async signTransaction(\n        rawTx: Buffer,\n        usingHash: boolean,\n    ): Promise<string> {\n        return usingHash ? this.sign(rawTx, SIGN_HASH_TX_INS) :\n          this.sign(rawTx, SIGN_RAW_TX_INS);\n    }\n\n    async signMessage(message: Buffer): Promise<string> {\n        return this.sign(message, SIGN_MESSAGE_INS);\n    }\n\n    async getAppConfiguration(): Promise<{\n        version: string,\n    }> {\n        const response = await this.transport.send(0xed, 0x02, 0x00, 0x00);\n        return {\n            contractData: response[0],\n            accountIndex: response[1],\n            addressIndex: response[2],\n            version: `${response[3]}.${response[4]}.${response[5]}`\n        }\n    }\n\n    async sign(message: Buffer, type: number): Promise<string> {\n        if ( !ACTIVE_SIGNERS.includes(type) ) {\n            throw new Error(`invalid sign instruction called: ${type}`);\n        }\n\n        const curveMask = 0x80;\n\n        const apdus = [];\n        let offset = 0;\n\n        while (offset !== message.length) {\n            const isFirst = offset === 0;\n            const maxChunkSize = 150;\n\n            const hasMore = offset + maxChunkSize < message.length;\n            const chunkSize = hasMore ? maxChunkSize : message.length - offset;\n\n            const apdu = {\n                cla: 0xed,\n                ins: type,\n                p1: isFirst ? 0x00 : 0x80,\n                p2: curveMask,\n                data: Buffer.alloc(chunkSize),\n            };\n\n            message.copy(apdu.data, 0, offset, offset + chunkSize);\n\n            apdus.push(apdu);\n            offset += chunkSize;\n        }\n\n        let response = Buffer.alloc(0);\n        for (let apdu of apdus) {\n            response = await this.transport.send(\n              apdu.cla,\n              apdu.ins,\n              apdu.p1,\n              apdu.p2,\n              apdu.data\n            );\n        }\n\n        if (response.length !== 67 || response[0] !== 64) {\n            throw new Error(\"invalid signature received from ledger device\")\n        }\n\n        return response.slice(1, response.length - 2).toString(\"hex\");\n    }\n}\n"]},"metadata":{},"sourceType":"module"}