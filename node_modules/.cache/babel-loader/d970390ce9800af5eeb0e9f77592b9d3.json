{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = __importStar(require(\"lodash\"));\n\nconst utils = __importStar(require(\"./utils\"));\n\nconst validate = utils.common.validate;\nconst paymentFlags = utils.common.txFlags.Payment;\nconst ValidationError = utils.common.errors.ValidationError;\n\nconst common_1 = require(\"../common\");\n\nconst utils_1 = require(\"./utils\");\n\nfunction isMaxAdjustment(source) {\n  return source.maxAmount != null;\n}\n\nfunction isMinAdjustment(destination) {\n  return destination.minAmount != null;\n}\n\nfunction isXRPToXRPPayment(payment) {\n  const {\n    source,\n    destination\n  } = payment;\n  const sourceCurrency = isMaxAdjustment(source) ? source.maxAmount.currency : source.amount.currency;\n  const destinationCurrency = isMinAdjustment(destination) ? destination.minAmount.currency : destination.amount.currency;\n  return (sourceCurrency === 'XRP' || sourceCurrency === 'drops') && (destinationCurrency === 'XRP' || destinationCurrency === 'drops');\n}\n\nfunction isIOUWithoutCounterparty(amount) {\n  return amount && amount.currency !== 'XRP' && amount.currency !== 'drops' && amount.counterparty == null;\n}\n\nfunction applyAnyCounterpartyEncoding(payment) {\n  [payment.source, payment.destination].forEach(adjustment => {\n    ['amount', 'minAmount', 'maxAmount'].forEach(key => {\n      if (isIOUWithoutCounterparty(adjustment[key])) {\n        adjustment[key].counterparty = adjustment.address;\n      }\n    });\n  });\n}\n\nfunction createMaximalAmount(amount) {\n  const maxXRPValue = '100000000000';\n  const maxIOUValue = '999999999999999900000000000000000000000000000000000000000000000000000000000000000000000000000000';\n  let maxValue;\n\n  if (amount.currency === 'XRP') {\n    maxValue = maxXRPValue;\n  } else if (amount.currency === 'drops') {\n    maxValue = common_1.xrpToDrops(maxXRPValue);\n  } else {\n    maxValue = maxIOUValue;\n  }\n\n  return Object.assign({}, amount, {\n    value: maxValue\n  });\n}\n\nfunction validateAndNormalizeAddress(address, expectedTag) {\n  const classicAddress = utils_1.getClassicAccountAndTag(address, expectedTag);\n  classicAddress.tag = classicAddress.tag === false ? undefined : classicAddress.tag;\n  return classicAddress;\n}\n\nfunction createPaymentTransaction(address, paymentArgument) {\n  const payment = _.cloneDeep(paymentArgument);\n\n  applyAnyCounterpartyEncoding(payment);\n  const sourceAddressAndTag = validateAndNormalizeAddress(payment.source.address, payment.source.tag);\n  const addressToVerifyAgainst = validateAndNormalizeAddress(address, undefined);\n\n  if (addressToVerifyAgainst.classicAccount !== sourceAddressAndTag.classicAccount) {\n    throw new ValidationError('address must match payment.source.address');\n  }\n\n  if (addressToVerifyAgainst.tag != null && sourceAddressAndTag.tag != null && addressToVerifyAgainst.tag !== sourceAddressAndTag.tag) {\n    throw new ValidationError('address includes a tag that does not match payment.source.tag');\n  }\n\n  const destinationAddressAndTag = validateAndNormalizeAddress(payment.destination.address, payment.destination.tag);\n\n  if (isMaxAdjustment(payment.source) && isMinAdjustment(payment.destination) || !isMaxAdjustment(payment.source) && !isMinAdjustment(payment.destination)) {\n    throw new ValidationError('payment must specify either (source.maxAmount ' + 'and destination.amount) or (source.amount and destination.minAmount)');\n  }\n\n  const destinationAmount = isMinAdjustment(payment.destination) ? payment.destination.minAmount : payment.destination.amount;\n  const sourceAmount = isMaxAdjustment(payment.source) ? payment.source.maxAmount : payment.source.amount;\n  const amount = isMinAdjustment(payment.destination) && !isXRPToXRPPayment(payment) ? createMaximalAmount(destinationAmount) : destinationAmount;\n  const txJSON = {\n    TransactionType: 'Payment',\n    Account: sourceAddressAndTag.classicAccount,\n    Destination: destinationAddressAndTag.classicAccount,\n    Amount: common_1.toRippledAmount(amount),\n    Flags: 0\n  };\n\n  if (payment.invoiceID != null) {\n    txJSON.InvoiceID = payment.invoiceID;\n  }\n\n  if (sourceAddressAndTag.tag != null) {\n    txJSON.SourceTag = sourceAddressAndTag.tag;\n  }\n\n  if (destinationAddressAndTag.tag != null) {\n    txJSON.DestinationTag = destinationAddressAndTag.tag;\n  }\n\n  if (payment.memos != null) {\n    txJSON.Memos = payment.memos.map(utils.convertMemo);\n  }\n\n  if (payment.noDirectRipple === true) {\n    txJSON.Flags |= paymentFlags.NoRippleDirect;\n  }\n\n  if (payment.limitQuality === true) {\n    txJSON.Flags |= paymentFlags.LimitQuality;\n  }\n\n  if (!isXRPToXRPPayment(payment)) {\n    if (payment.allowPartialPayment || isMinAdjustment(payment.destination)) {\n      txJSON.Flags |= paymentFlags.PartialPayment;\n    }\n\n    txJSON.SendMax = common_1.toRippledAmount(sourceAmount);\n\n    if (isMinAdjustment(payment.destination)) {\n      txJSON.DeliverMin = common_1.toRippledAmount(destinationAmount);\n    }\n\n    if (payment.paths != null) {\n      txJSON.Paths = JSON.parse(payment.paths);\n    }\n  } else if (payment.allowPartialPayment === true) {\n    throw new ValidationError('XRP to XRP payments cannot be partial payments');\n  }\n\n  return txJSON;\n}\n\nfunction preparePayment(address, payment) {\n  let instructions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  try {\n    validate.preparePayment({\n      address,\n      payment,\n      instructions\n    });\n    const txJSON = createPaymentTransaction(address, payment);\n    return utils.prepareTransaction(txJSON, this, instructions);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\nexports.default = preparePayment;","map":{"version":3,"mappings":"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","names":["validate","utils","common","paymentFlags","txFlags","Payment","ValidationError","errors","isMaxAdjustment","source","maxAmount","isMinAdjustment","destination","minAmount","isXRPToXRPPayment","payment","sourceCurrency","currency","amount","destinationCurrency","isIOUWithoutCounterparty","counterparty","applyAnyCounterpartyEncoding","forEach","adjustment","key","address","createMaximalAmount","maxXRPValue","maxIOUValue","maxValue","common_1","Object","assign","value","validateAndNormalizeAddress","expectedTag","classicAddress","utils_1","tag","undefined","createPaymentTransaction","paymentArgument","_","cloneDeep","sourceAddressAndTag","addressToVerifyAgainst","classicAccount","destinationAddressAndTag","destinationAmount","sourceAmount","txJSON","TransactionType","Account","Destination","Amount","Flags","invoiceID","InvoiceID","SourceTag","DestinationTag","memos","Memos","map","convertMemo","noDirectRipple","NoRippleDirect","limitQuality","LimitQuality","allowPartialPayment","PartialPayment","SendMax","DeliverMin","paths","Paths","JSON","parse","preparePayment","instructions","prepareTransaction","e","Promise","reject","exports"],"sourceRoot":"","sources":["../../../src/transaction/payment.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}