{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar storage_1 = require(\"./storage\");\n\nvar TransformationType;\n\n(function (TransformationType) {\n  TransformationType[TransformationType[\"PLAIN_TO_CLASS\"] = 0] = \"PLAIN_TO_CLASS\";\n  TransformationType[TransformationType[\"CLASS_TO_PLAIN\"] = 1] = \"CLASS_TO_PLAIN\";\n  TransformationType[TransformationType[\"CLASS_TO_CLASS\"] = 2] = \"CLASS_TO_CLASS\";\n})(TransformationType = exports.TransformationType || (exports.TransformationType = {}));\n\nvar TransformOperationExecutor =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function TransformOperationExecutor(transformationType, options) {\n    this.transformationType = transformationType;\n    this.options = options; // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    this.recursionStack = new Set();\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  TransformOperationExecutor.prototype.transform = function (source, value, targetType, arrayType, isMap, level) {\n    var _this = this;\n\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (Array.isArray(value) || value instanceof Set) {\n      var newValue_1 = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];\n      value.forEach(function (subValue, index) {\n        var subSource = source ? source[index] : undefined;\n\n        if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {\n          var realTargetType = void 0;\n\n          if (typeof targetType !== \"function\" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {\n            if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n              realTargetType = targetType.options.discriminator.subTypes.find(function (subType) {\n                return subType.name === subValue[targetType.options.discriminator.property];\n              });\n              var options = {\n                newObject: newValue_1,\n                object: subValue,\n                property: undefined\n              };\n              var newType = targetType.typeFunction(options);\n              realTargetType === undefined ? realTargetType = newType : realTargetType = realTargetType.value;\n              if (!targetType.options.keepDiscriminatorProperty) delete subValue[targetType.options.discriminator.property];\n            }\n\n            if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n              realTargetType = subValue.constructor;\n            }\n\n            if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n              subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(function (subType) {\n                return subType.value === subValue.constructor;\n              }).name;\n            }\n          } else {\n            realTargetType = targetType;\n          }\n\n          var value_1 = _this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\n\n          if (newValue_1 instanceof Set) {\n            newValue_1.add(value_1);\n          } else {\n            newValue_1.push(value_1);\n          }\n        } else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          if (newValue_1 instanceof Set) {\n            newValue_1.add(subValue);\n          } else {\n            newValue_1.push(subValue);\n          }\n        }\n      });\n      return newValue_1;\n    } else if (targetType === String && !isMap) {\n      if (value === null || value === undefined) return value;\n      return String(value);\n    } else if (targetType === Number && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Number(value);\n    } else if (targetType === Boolean && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Boolean(value);\n    } else if ((targetType === Date || value instanceof Date) && !isMap) {\n      if (value instanceof Date) {\n        return new Date(value.valueOf());\n      }\n\n      if (value === null || value === undefined) return value;\n      return new Date(value);\n    } else if (testForBuffer() && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Buffer.from(value);\n    } else if (typeof value === \"object\" && value !== null) {\n      // try to guess the type\n      if (!targetType && value.constructor !== Object\n      /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/\n      ) targetType = value.constructor;\n      if (!targetType && source) targetType = source.constructor;\n\n      if (this.options.enableCircularCheck) {\n        // add transformed type to prevent circular references\n        this.recursionStack.add(value);\n      }\n\n      var keys = this.getKeys(targetType, value);\n      var newValue = source ? source : {};\n\n      if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {\n        if (isMap) {\n          newValue = new Map();\n        } else if (targetType) {\n          newValue = new targetType();\n        } else {\n          newValue = {};\n        }\n      }\n\n      var _loop_1 = function (key) {\n        var valueKey = key,\n            newValueKey = key,\n            propertyName = key;\n\n        if (!this_1.options.ignoreDecorators && targetType) {\n          if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key);\n\n            if (exposeMetadata) {\n              propertyName = exposeMetadata.propertyName;\n              newValueKey = exposeMetadata.propertyName;\n            }\n          } else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN || this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n            var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(targetType, key);\n\n            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n              newValueKey = exposeMetadata.options.name;\n            }\n          }\n        } // get a subvalue\n\n\n        var subValue = undefined;\n\n        if (value instanceof Map) {\n          subValue = value.get(valueKey);\n        } else if (value[valueKey] instanceof Function) {\n          subValue = value[valueKey]();\n        } else {\n          subValue = value[valueKey];\n        } // determine a type\n\n\n        var type = undefined,\n            isSubValueMap = subValue instanceof Map;\n\n        if (targetType && isMap) {\n          type = targetType;\n        } else if (targetType) {\n          var metadata_1 = storage_1.defaultMetadataStorage.findTypeMetadata(targetType, propertyName);\n\n          if (metadata_1) {\n            var options = {\n              newObject: newValue,\n              object: value,\n              property: propertyName\n            };\n            var newType = metadata_1.typeFunction ? metadata_1.typeFunction(options) : metadata_1.reflectedType;\n\n            if (metadata_1.options && metadata_1.options.discriminator && metadata_1.options.discriminator.property && metadata_1.options.discriminator.subTypes) {\n              if (!(value[valueKey] instanceof Array)) {\n                if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                  type = metadata_1.options.discriminator.subTypes.find(function (subType) {\n                    if (subValue && metadata_1.options.discriminator.property in subValue) {\n                      return subType.name === subValue[metadata_1.options.discriminator.property];\n                    }\n                  });\n                  type === undefined ? type = newType : type = type.value;\n\n                  if (!metadata_1.options.keepDiscriminatorProperty) {\n                    if (subValue && metadata_1.options.discriminator.property in subValue) {\n                      delete subValue[metadata_1.options.discriminator.property];\n                    }\n                  }\n                }\n\n                if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n                  type = subValue.constructor;\n                }\n\n                if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                  subValue[metadata_1.options.discriminator.property] = metadata_1.options.discriminator.subTypes.find(function (subType) {\n                    return subType.value === subValue.constructor;\n                  }).name;\n                }\n              } else {\n                type = metadata_1;\n              }\n            } else {\n              type = newType;\n            }\n\n            isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;\n          } else if (this_1.options.targetMaps) {\n            // try to find a type in target maps\n            this_1.options.targetMaps.filter(function (map) {\n              return map.target === targetType && !!map.properties[propertyName];\n            }).forEach(function (map) {\n              return type = map.properties[propertyName];\n            });\n          } else if (this_1.options.enableImplicitConversion && this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            // if we have no registererd type via the @Type() decorator then we check if we have any\n            // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n            var reflectedType = Reflect.getMetadata(\"design:type\", targetType.prototype, propertyName);\n\n            if (reflectedType) {\n              type = reflectedType;\n            }\n          }\n        } // if value is an array try to get its custom array type\n\n\n        var arrayType_1 = Array.isArray(value[valueKey]) ? this_1.getReflectedType(targetType, propertyName) : undefined; // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n\n        var subSource = source ? source[valueKey] : undefined; // if its deserialization then type if required\n        // if we uncomment this types like string[] will not work\n        // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n        //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n        // if newValue is a source object that has method that match newKeyName then skip it\n\n        if (newValue.constructor.prototype) {\n          var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n          if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS || this_1.transformationType === TransformationType.CLASS_TO_CLASS) && (descriptor && !descriptor.set || newValue[newValueKey] instanceof Function)) //  || TransformationType === TransformationType.CLASS_TO_CLASS\n            return \"continue\";\n        }\n\n        if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {\n          var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n          var finalValue = void 0;\n\n          if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n            // Get original value\n            finalValue = value[transformKey]; // Apply custom transformation\n\n            finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType); // If nothing change, it means no custom transformation was applied, so use the subValue.\n\n            finalValue = value[transformKey] === finalValue ? subValue : finalValue; // Apply the default transformation\n\n            finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);\n          } else {\n            finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);\n            finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);\n          }\n\n          if (newValue instanceof Map) {\n            newValue.set(newValueKey, finalValue);\n          } else {\n            newValue[newValueKey] = finalValue;\n          }\n        } else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n          var finalValue = subValue;\n          finalValue = this_1.applyCustomTransformations(finalValue, targetType, key, value, this_1.transformationType);\n\n          if (newValue instanceof Map) {\n            newValue.set(newValueKey, finalValue);\n          } else {\n            newValue[newValueKey] = finalValue;\n          }\n        }\n      };\n\n      var this_1 = this; // traverse over keys\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n\n        _loop_1(key);\n      }\n\n      if (this.options.enableCircularCheck) {\n        this.recursionStack.delete(value);\n      }\n\n      return newValue;\n    } else {\n      return value;\n    }\n  };\n\n  TransformOperationExecutor.prototype.applyCustomTransformations = function (value, target, key, obj, transformationType) {\n    var _this = this;\n\n    var metadatas = storage_1.defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType); // apply versioning options\n\n    if (this.options.version !== undefined) {\n      metadatas = metadatas.filter(function (metadata) {\n        if (!metadata.options) return true;\n        return _this.checkVersion(metadata.options.since, metadata.options.until);\n      });\n    } // apply grouping options\n\n\n    if (this.options.groups && this.options.groups.length) {\n      metadatas = metadatas.filter(function (metadata) {\n        if (!metadata.options) return true;\n        return _this.checkGroups(metadata.options.groups);\n      });\n    } else {\n      metadatas = metadatas.filter(function (metadata) {\n        return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n      });\n    }\n\n    metadatas.forEach(function (metadata) {\n      value = metadata.transformFn(value, obj, transformationType);\n    });\n    return value;\n  }; // preventing circular references\n\n\n  TransformOperationExecutor.prototype.isCircular = function (object) {\n    return this.recursionStack.has(object);\n  };\n\n  TransformOperationExecutor.prototype.getReflectedType = function (target, propertyName) {\n    if (!target) return undefined;\n    var meta = storage_1.defaultMetadataStorage.findTypeMetadata(target, propertyName);\n    return meta ? meta.reflectedType : undefined;\n  };\n\n  TransformOperationExecutor.prototype.getKeys = function (target, object) {\n    var _this = this; // determine exclusion strategy\n\n\n    var strategy = storage_1.defaultMetadataStorage.getStrategy(target);\n    if (strategy === \"none\") strategy = this.options.strategy || \"exposeAll\"; // exposeAll is default strategy\n    // get all keys that need to expose\n\n    var keys = [];\n\n    if (strategy === \"exposeAll\") {\n      if (object instanceof Map) {\n        keys = Array.from(object.keys());\n      } else {\n        keys = Object.keys(object);\n      }\n    }\n\n    if (!this.options.ignoreDecorators && target) {\n      // add all exposed to list of keys\n      var exposedProperties = storage_1.defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n\n      if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n        exposedProperties = exposedProperties.map(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n\n          if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n            return exposeMetadata.options.name;\n          }\n\n          return key;\n        });\n      }\n\n      if (this.options.excludeExtraneousValues) {\n        keys = exposedProperties;\n      } else {\n        keys = keys.concat(exposedProperties);\n      } // exclude excluded properties\n\n\n      var excludedProperties_1 = storage_1.defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n\n      if (excludedProperties_1.length > 0) {\n        keys = keys.filter(function (key) {\n          return excludedProperties_1.indexOf(key) === -1;\n        });\n      } // apply versioning options\n\n\n      if (this.options.version !== undefined) {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n          return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n        });\n      } // apply grouping options\n\n\n      if (this.options.groups && this.options.groups.length) {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n          return _this.checkGroups(exposeMetadata.options.groups);\n        });\n      } else {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n          return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;\n        });\n      }\n    } // exclude prefixed properties\n\n\n    if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n      keys = keys.filter(function (key) {\n        return _this.options.excludePrefixes.every(function (prefix) {\n          return key.substr(0, prefix.length) !== prefix;\n        });\n      });\n    } // make sure we have unique keys\n\n\n    keys = keys.filter(function (key, index, self) {\n      return self.indexOf(key) === index;\n    });\n    return keys;\n  };\n\n  TransformOperationExecutor.prototype.checkVersion = function (since, until) {\n    var decision = true;\n    if (decision && since) decision = this.options.version >= since;\n    if (decision && until) decision = this.options.version < until;\n    return decision;\n  };\n\n  TransformOperationExecutor.prototype.checkGroups = function (groups) {\n    if (!groups) return true;\n    return this.options.groups.some(function (optionGroup) {\n      return groups.indexOf(optionGroup) !== -1;\n    });\n  };\n\n  return TransformOperationExecutor;\n}();\n\nexports.TransformOperationExecutor = TransformOperationExecutor;\n\nfunction instantiateArrayType(arrayType) {\n  var array = new arrayType();\n\n  if (!(array instanceof Set) && !(\"push\" in array)) {\n    return [];\n  }\n\n  return array;\n}\n\nfunction testForBuffer() {\n  try {\n    Buffer;\n    return true;\n  } catch (_a) {}\n\n  return false;\n}\n\nexports.testForBuffer = testForBuffer;","map":{"version":3,"mappings":"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","names":["TransformationType","exports","transformationType","options","Set","TransformOperationExecutor","source","value","targetType","arrayType","isMap","level","Array","isArray","newValue_1","PLAIN_TO_CLASS","instantiateArrayType","forEach","subValue","index","subSource","undefined","_this","enableCircularCheck","isCircular","realTargetType","discriminator","property","subTypes","find","subType","name","newObject","object","newType","typeFunction","keepDiscriminatorProperty","CLASS_TO_CLASS","constructor","CLASS_TO_PLAIN","value_1","transform","Map","add","push","String","Number","Boolean","Date","valueOf","testForBuffer","Buffer","from","Object","recursionStack","keys","getKeys","newValue","key","valueKey","newValueKey","propertyName","this_1","ignoreDecorators","exposeMetadata","storage_1","findExposeMetadataByCustomName","findExposeMetadata","get","Function","type","isSubValueMap","metadata_1","findTypeMetadata","reflectedType","targetMaps","filter","target","map","properties","enableImplicitConversion","Reflect","getMetadata","prototype","arrayType_1","getReflectedType","descriptor","getOwnPropertyDescriptor","set","transformKey","finalValue","applyCustomTransformations","_i","delete","obj","metadatas","findTransformMetadatas","version","metadata","checkVersion","since","until","groups","length","checkGroups","transformFn","has","meta","strategy","getStrategy","exposedProperties","getExposedProperties","excludeExtraneousValues","concat","excludedProperties_1","getExcludedProperties","indexOf","excludePrefixes","every","substr","prefix","self","decision","some","optionGroup","array"],"sourceRoot":".","sources":["../../src/TransformOperationExecutor.ts"],"sourcesContent":["import { ClassTransformOptions } from \"./ClassTransformOptions\";\nimport { defaultMetadataStorage } from \"./storage\";\nimport { TypeHelpOptions, TypeOptions } from \"./metadata/ExposeExcludeOptions\";\nimport { TypeMetadata } from \"./metadata/TypeMetadata\";\n\nexport enum TransformationType {\n    PLAIN_TO_CLASS,\n    CLASS_TO_PLAIN,\n    CLASS_TO_CLASS\n}\n\nexport class TransformOperationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private recursionStack = new Set<Object>();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private transformationType: TransformationType,\n        private options: ClassTransformOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform(source: Object | Object[] | any,\n        value: Object | Object[] | any,\n        targetType: Function | TypeMetadata,\n        arrayType: Function,\n        isMap: boolean,\n        level: number = 0) {\n\n        if (Array.isArray(value) || value instanceof Set) {\n            const newValue = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];\n            (value as any[]).forEach((subValue, index) => {\n                const subSource = source ? source[index] : undefined;\n                if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n                    let realTargetType;\n                    if (typeof targetType !== \"function\" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {\n                        if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                            realTargetType = targetType.options.discriminator.subTypes.find((subType) => subType.name === subValue[(targetType as { options: TypeOptions }).options.discriminator.property]);\n                            const options: TypeHelpOptions = { newObject: newValue, object: subValue, property: undefined };\n                            const newType = targetType.typeFunction(options);\n                            realTargetType === undefined ? realTargetType = newType : realTargetType = realTargetType.value;\n                            if (!targetType.options.keepDiscriminatorProperty) delete subValue[targetType.options.discriminator.property];\n                        }\n                        if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                            realTargetType = subValue.constructor;\n                        }\n                        if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                            subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;\n                        }\n                    } else {\n                        realTargetType = targetType;\n                    }\n                    const value = this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\n\n                    if (newValue instanceof Set) {\n                        newValue.add(value);\n                    } else {\n                        newValue.push(value);\n                    }\n                } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    if (newValue instanceof Set) {\n                        newValue.add(subValue);\n                    } else {\n                        newValue.push(subValue);\n                    }\n                }\n            });\n            return newValue;\n        } else if (targetType === String && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return String(value);\n\n        } else if (targetType === Number && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Number(value);\n\n        } else if (targetType === Boolean && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Boolean(value);\n\n        } else if ((targetType === Date || value instanceof Date) && !isMap) {\n            if (value instanceof Date) {\n                return new Date(value.valueOf());\n            }\n            if (value === null || value === undefined)\n                return value;\n            return new Date(value);\n\n        } else if (testForBuffer() && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Buffer.from(value);\n\n        } else if (typeof value === \"object\" && value !== null) {\n\n            // try to guess the type\n            if (!targetType && value.constructor !== Object/* && TransformationType === TransformationType.CLASS_TO_PLAIN*/) targetType = value.constructor;\n            if (!targetType && source) targetType = source.constructor;\n\n            if (this.options.enableCircularCheck) {\n                // add transformed type to prevent circular references\n                this.recursionStack.add(value);\n            }\n\n            const keys = this.getKeys((targetType as Function), value);\n            let newValue: any = source ? source : {};\n            if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {\n                if (isMap) {\n                    newValue = new Map();\n                } else if (targetType) {\n                    newValue = new (targetType as any)();\n                } else {\n                    newValue = {};\n                }\n            }\n\n            // traverse over keys\n            for (let key of keys) {\n\n                let valueKey = key, newValueKey = key, propertyName = key;\n                if (!this.options.ignoreDecorators && targetType) {\n                    if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName((targetType as Function), key);\n                        if (exposeMetadata) {\n                            propertyName = exposeMetadata.propertyName;\n                            newValueKey = exposeMetadata.propertyName;\n                        }\n\n                    } else if (this.transformationType === TransformationType.CLASS_TO_PLAIN || this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                        const exposeMetadata = defaultMetadataStorage.findExposeMetadata((targetType as Function), key);\n                        if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n                            newValueKey = exposeMetadata.options.name;\n                        }\n                    }\n                }\n\n                // get a subvalue\n                let subValue: any = undefined;\n                if (value instanceof Map) {\n                    subValue = value.get(valueKey);\n                } else if (value[valueKey] instanceof Function) {\n                    subValue = value[valueKey]();\n                } else {\n                    subValue = value[valueKey];\n                }\n\n                // determine a type\n                let type: any = undefined, isSubValueMap = subValue instanceof Map;\n                if (targetType && isMap) {\n                    type = targetType;\n\n                } else if (targetType) {\n\n                    const metadata = defaultMetadataStorage.findTypeMetadata((targetType as Function), propertyName);\n                    if (metadata) {\n                        const options: TypeHelpOptions = { newObject: newValue, object: value, property: propertyName };\n                        const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;\n                        if (metadata.options && metadata.options.discriminator && metadata.options.discriminator.property && metadata.options.discriminator.subTypes) {\n                            if (!(value[valueKey] instanceof Array)) {\n                                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                                    type = metadata.options.discriminator.subTypes.find((subType) => {\n                                        if (subValue && metadata.options.discriminator.property in subValue) {\n                                            return subType.name === subValue[metadata.options.discriminator.property]\n                                        }\n                                    });\n                                    type === undefined ? type = newType : type = type.value;\n                                    if (!metadata.options.keepDiscriminatorProperty) {\n                                        if (subValue && metadata.options.discriminator.property in subValue) {\n                                            delete subValue[metadata.options.discriminator.property];\n                                        }\n                                    }\n                                }\n                                if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                                    type = subValue.constructor;\n                                }\n                                if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                                    subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;\n                                }\n                            } else {\n                                type = metadata;\n                            }\n                        } else {\n                            type = newType;\n                        }\n                        isSubValueMap = isSubValueMap || metadata.reflectedType === Map;\n                    } else if (this.options.targetMaps) { // try to find a type in target maps\n                        this.options.targetMaps\n                            .filter(map => map.target === targetType && !!map.properties[propertyName])\n                            .forEach(map => type = map.properties[propertyName]);\n                    } else if(this.options.enableImplicitConversion && this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        // if we have no registererd type via the @Type() decorator then we check if we have any\n                        // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n                        const reflectedType = Reflect.getMetadata(\"design:type\", (targetType as Function).prototype, propertyName);\n\n                        if (reflectedType) {\n                            type = reflectedType;\n                        }\n                    }\n                }\n\n                // if value is an array try to get its custom array type\n                const arrayType = Array.isArray(value[valueKey]) ? this.getReflectedType((targetType as Function), propertyName) : undefined;\n\n                // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n                const subSource = source ? source[valueKey] : undefined;\n\n                // if its deserialization then type if required\n                // if we uncomment this types like string[] will not work\n                // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n                //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n\n                // if newValue is a source object that has method that match newKeyName then skip it\n                if (newValue.constructor.prototype) {\n                    const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n                    if ((this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)\n                        && ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function)) //  || TransformationType === TransformationType.CLASS_TO_CLASS\n                        continue;\n                }\n\n                if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n                    let transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n                    let finalValue;\n\n                    if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                        // Get original value\n                        finalValue = value[transformKey];\n                        // Apply custom transformation\n                        finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), transformKey, value, this.transformationType);\n                        // If nothing change, it means no custom transformation was applied, so use the subValue.\n                        finalValue = (value[transformKey] === finalValue) ? subValue : finalValue;\n                        // Apply the default transformation\n                        finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);\n                    } else {\n                        finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);\n                        finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), transformKey, value, this.transformationType);\n                    }\n\n                    if (newValue instanceof Map) {\n                        newValue.set(newValueKey, finalValue);\n                    } else {\n                        newValue[newValueKey] = finalValue;\n                    }\n                } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    let finalValue = subValue;\n                    finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), key, value, this.transformationType);\n                    if (newValue instanceof Map) {\n                        newValue.set(newValueKey, finalValue);\n                    } else {\n                        newValue[newValueKey] = finalValue;\n                    }\n                }\n\n            }\n\n            if (this.options.enableCircularCheck) {\n                this.recursionStack.delete(value);\n            }\n\n            return newValue;\n\n        } else {\n            return value;\n        }\n    }\n\n    private applyCustomTransformations(value: any, target: Function, key: string, obj: any, transformationType: TransformationType) {\n        let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\n\n        // apply versioning options\n        if (this.options.version !== undefined) {\n            metadatas = metadatas.filter(metadata => {\n                if (!metadata.options)\n                    return true;\n\n                return this.checkVersion(metadata.options.since, metadata.options.until);\n            });\n        }\n\n        // apply grouping options\n        if (this.options.groups && this.options.groups.length) {\n            metadatas = metadatas.filter(metadata => {\n                if (!metadata.options)\n                    return true;\n\n                return this.checkGroups(metadata.options.groups);\n            });\n        } else {\n            metadatas = metadatas.filter(metadata => {\n                return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n            });\n        }\n\n        metadatas.forEach(metadata => {\n            value = metadata.transformFn(value, obj, transformationType);\n        });\n\n        return value;\n    }\n\n    // preventing circular references\n    private isCircular(object: Object) {\n        return this.recursionStack.has(object);\n    }\n\n    private getReflectedType(target: Function, propertyName: string) {\n        if (!target) return undefined;\n        const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n        return meta ? meta.reflectedType : undefined;\n    }\n\n    private getKeys(target: Function, object: Object): string[] {\n\n        // determine exclusion strategy\n        let strategy = defaultMetadataStorage.getStrategy(target);\n        if (strategy === \"none\")\n            strategy = this.options.strategy || \"exposeAll\"; // exposeAll is default strategy\n\n        // get all keys that need to expose\n        let keys: any[] = [];\n        if (strategy === \"exposeAll\") {\n            if (object instanceof Map) {\n                keys = Array.from(object.keys());\n            } else {\n                keys = Object.keys(object);\n            }\n        }\n\n        if (!this.options.ignoreDecorators && target) {\n\n            // add all exposed to list of keys\n            let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                exposedProperties = exposedProperties.map(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n                        return exposeMetadata.options.name;\n                    }\n\n                    return key;\n                });\n            }\n            if (this.options.excludeExtraneousValues) {\n                keys = exposedProperties;\n            } else {\n                keys = keys.concat(exposedProperties);\n            }\n\n            // exclude excluded properties\n            const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n            if (excludedProperties.length > 0) {\n                keys = keys.filter(key => {\n                    return excludedProperties.indexOf(key) === -1;\n                });\n            }\n\n            // apply versioning options\n            if (this.options.version !== undefined) {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n\n                    return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n                });\n            }\n\n            // apply grouping options\n            if (this.options.groups && this.options.groups.length) {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n\n                    return this.checkGroups(exposeMetadata.options.groups);\n                });\n            } else {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;\n                });\n            }\n        }\n\n        // exclude prefixed properties\n        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n            keys = keys.filter(key => this.options.excludePrefixes.every(prefix => {\n                return key.substr(0, prefix.length) !== prefix;\n            }));\n        }\n\n        // make sure we have unique keys\n        keys = keys.filter((key, index, self) => {\n            return self.indexOf(key) === index;\n        });\n\n        return keys;\n    }\n\n    private checkVersion(since: number, until: number) {\n        let decision = true;\n        if (decision && since)\n            decision = this.options.version >= since;\n        if (decision && until)\n            decision = this.options.version < until;\n\n        return decision;\n    }\n\n    private checkGroups(groups: string[]) {\n        if (!groups)\n            return true;\n\n        return this.options.groups.some(optionGroup => groups.indexOf(optionGroup) !== -1);\n    }\n\n}\n\nfunction instantiateArrayType(arrayType: Function): Array<any> | Set<any> {\n    const array = new (arrayType as any)();\n    if (!(array instanceof Set) && !(\"push\" in array)) {\n        return [];\n    }\n    return array;\n}\n\nexport function testForBuffer(): boolean {\n    try {\n        Buffer\n        return true;\n    } catch { }\n    return false;\n}\n"]},"metadata":{},"sourceType":"script"}