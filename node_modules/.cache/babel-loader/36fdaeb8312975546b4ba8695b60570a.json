{"ast":null,"code":"'use strict';\n\nconst normalizeNodes = require('./utils').normalizeNodes;\n\nconst BigNumber = require('bignumber.js');\n\nfunction parsePaymentChannelStatus(node) {\n  if (node.diffType === 'CreatedNode') {\n    return 'created';\n  }\n\n  if (node.diffType === 'ModifiedNode') {\n    return 'modified';\n  }\n\n  if (node.diffType === 'DeletedNode') {\n    return 'deleted';\n  }\n\n  return undefined;\n}\n\nfunction summarizePaymentChannel(node) {\n  const final = node.diffType === 'CreatedNode' ? node.newFields : node.finalFields;\n  const prev = node.previousFields || {};\n  const summary = {\n    // Status may be 'created', 'modified', or 'deleted'.\n    status: parsePaymentChannelStatus(node),\n    // The LedgerIndex indicates the Channel ID,\n    // which is necessary to sign claims.\n    channelId: node.ledgerIndex,\n    // The source address that owns this payment channel.\n    // This comes from the sending address of the\n    // transaction that created the channel.\n    source: final.Account,\n    // The destination address for this payment channel.\n    // While the payment channel is open, this address is the only one that can receive\n    // XRP from the channel. This comes from the Destination field of the transaction\n    // that created the channel.\n    destination: final.Destination,\n    // Total XRP, in drops, that has been allocated to this channel.\n    // This includes XRP that has been paid to the destination address.\n    // This is initially set by the transaction that created the channel and\n    // can be increased if the source address sends a PaymentChannelFund transaction.\n    channelAmountDrops: new BigNumber(final.Amount || 0).toString(10),\n    // Total XRP, in drops, already paid out by the channel.\n    // The difference between this value and the Amount field is how much XRP can still\n    // be paid to the destination address with PaymentChannelClaim transactions.\n    // If the channel closes, the remaining difference is returned to the source address.\n    channelBalanceDrops: new BigNumber(final.Balance || 0).toString(10)\n  };\n\n  if (prev.Amount) {\n    // The change in the number of XRP drops allocated to this channel.\n    // This is positive if this is a PaymentChannelFund transaction.\n    summary.channelAmountChangeDrops = new BigNumber(final.Amount).minus(new BigNumber(prev.Amount || 0)).toString(10);\n  }\n\n  if (prev.Balance) {\n    // The change in the number of XRP drops already paid out by the channel.\n    summary.channelBalanceChangeDrops = new BigNumber(final.Balance).minus(new BigNumber(prev.Balance || 0)).toString(10);\n  }\n\n  if (node.PreviousTxnID) {\n    // The identifying hash of the transaction that\n    // most recently modified this payment channel object.\n    // You can use this to retrieve the object's history.\n    summary.previousTxnId = node.PreviousTxnID;\n  }\n\n  return summary;\n}\n\nfunction parseChannelChanges(metadata) {\n  const paymentChannels = normalizeNodes(metadata).filter(n => {\n    return n.entryType === 'PayChannel';\n  });\n  return paymentChannels.length === 1 ? summarizePaymentChannel(paymentChannels[0]) : undefined;\n}\n\nmodule.exports.parseChannelChanges = parseChannelChanges;","map":{"version":3,"sources":["C:/Users/masho/OneDrive/Desktop/Blockchain/Biconomy/Projects/NFT_minter/node_modules/ripple-lib-transactionparser/src/channelchanges.js"],"names":["normalizeNodes","require","BigNumber","parsePaymentChannelStatus","node","diffType","undefined","summarizePaymentChannel","final","newFields","finalFields","prev","previousFields","summary","status","channelId","ledgerIndex","source","Account","destination","Destination","channelAmountDrops","Amount","toString","channelBalanceDrops","Balance","channelAmountChangeDrops","minus","channelBalanceChangeDrops","PreviousTxnID","previousTxnId","parseChannelChanges","metadata","paymentChannels","filter","n","entryType","length","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,cAAc,GAAGC,OAAO,CAAC,SAAD,CAAP,CAAmBD,cAA1C;;AACA,MAAME,SAAS,GAAGD,OAAO,CAAC,cAAD,CAAzB;;AAEA,SAASE,yBAAT,CAAmCC,IAAnC,EAAyC;AACvC,MAAIA,IAAI,CAACC,QAAL,KAAkB,aAAtB,EAAqC;AACnC,WAAO,SAAP;AACD;;AAED,MAAID,IAAI,CAACC,QAAL,KAAkB,cAAtB,EAAsC;AACpC,WAAO,UAAP;AACD;;AAED,MAAID,IAAI,CAACC,QAAL,KAAkB,aAAtB,EAAqC;AACnC,WAAO,SAAP;AACD;;AACD,SAAOC,SAAP;AACD;;AAED,SAASC,uBAAT,CAAiCH,IAAjC,EAAuC;AAErC,QAAMI,KAAK,GAAIJ,IAAI,CAACC,QAAL,KAAkB,aAAnB,GACZD,IAAI,CAACK,SADO,GACKL,IAAI,CAACM,WADxB;AAEA,QAAMC,IAAI,GAAGP,IAAI,CAACQ,cAAL,IAAuB,EAApC;AAEA,QAAMC,OAAO,GAAG;AACd;AACAC,IAAAA,MAAM,EAAEX,yBAAyB,CAACC,IAAD,CAFnB;AAId;AACA;AACAW,IAAAA,SAAS,EAAEX,IAAI,CAACY,WANF;AAQd;AACA;AACA;AACAC,IAAAA,MAAM,EAAET,KAAK,CAACU,OAXA;AAad;AACA;AACA;AACA;AACAC,IAAAA,WAAW,EAAEX,KAAK,CAACY,WAjBL;AAmBd;AACA;AACA;AACA;AACAC,IAAAA,kBAAkB,EACZ,IAAInB,SAAJ,CAAcM,KAAK,CAACc,MAAN,IAAgB,CAA9B,EAAiCC,QAAjC,CAA0C,EAA1C,CAxBQ;AA0Bd;AACA;AACA;AACA;AACAC,IAAAA,mBAAmB,EACb,IAAItB,SAAJ,CAAcM,KAAK,CAACiB,OAAN,IAAiB,CAA/B,EAAkCF,QAAlC,CAA2C,EAA3C;AA/BQ,GAAhB;;AAkCA,MAAIZ,IAAI,CAACW,MAAT,EAAiB;AACf;AACA;AACAT,IAAAA,OAAO,CAACa,wBAAR,GAAmC,IAAIxB,SAAJ,CAAcM,KAAK,CAACc,MAApB,EAChCK,KADgC,CAC1B,IAAIzB,SAAJ,CAAcS,IAAI,CAACW,MAAL,IAAe,CAA7B,CAD0B,EAEhCC,QAFgC,CAEvB,EAFuB,CAAnC;AAGD;;AAED,MAAIZ,IAAI,CAACc,OAAT,EAAkB;AAChB;AACAZ,IAAAA,OAAO,CAACe,yBAAR,GAAoC,IAAI1B,SAAJ,CAAcM,KAAK,CAACiB,OAApB,EACjCE,KADiC,CAC3B,IAAIzB,SAAJ,CAAcS,IAAI,CAACc,OAAL,IAAgB,CAA9B,CAD2B,EAEjCF,QAFiC,CAExB,EAFwB,CAApC;AAGD;;AAED,MAAInB,IAAI,CAACyB,aAAT,EAAwB;AACtB;AACA;AACA;AACAhB,IAAAA,OAAO,CAACiB,aAAR,GAAwB1B,IAAI,CAACyB,aAA7B;AACD;;AAED,SAAOhB,OAAP;AACD;;AAED,SAASkB,mBAAT,CAA6BC,QAA7B,EAAuC;AACrC,QAAMC,eAAe,GAAGjC,cAAc,CAACgC,QAAD,CAAd,CACrBE,MADqB,CACdC,CAAC,IAAI;AACX,WAAOA,CAAC,CAACC,SAAF,KAAgB,YAAvB;AACD,GAHqB,CAAxB;AAKA,SAAQH,eAAe,CAACI,MAAhB,KAA2B,CAA5B,GACL9B,uBAAuB,CAAC0B,eAAe,CAAC,CAAD,CAAhB,CADlB,GAEL3B,SAFF;AAGD;;AAEDgC,MAAM,CAACC,OAAP,CAAeR,mBAAf,GAAqCA,mBAArC","sourcesContent":["'use strict'\n\nconst normalizeNodes = require('./utils').normalizeNodes\nconst BigNumber = require('bignumber.js')\n\nfunction parsePaymentChannelStatus(node) {\n  if (node.diffType === 'CreatedNode') {\n    return 'created'\n  }\n\n  if (node.diffType === 'ModifiedNode') {\n    return 'modified'\n  }\n\n  if (node.diffType === 'DeletedNode') {\n    return 'deleted'\n  }\n  return undefined\n}\n\nfunction summarizePaymentChannel(node) {\n\n  const final = (node.diffType === 'CreatedNode') ?\n    node.newFields : node.finalFields\n  const prev = node.previousFields || {}\n\n  const summary = {\n    // Status may be 'created', 'modified', or 'deleted'.\n    status: parsePaymentChannelStatus(node),\n\n    // The LedgerIndex indicates the Channel ID,\n    // which is necessary to sign claims.\n    channelId: node.ledgerIndex,\n\n    // The source address that owns this payment channel.\n    // This comes from the sending address of the\n    // transaction that created the channel.\n    source: final.Account,\n\n    // The destination address for this payment channel.\n    // While the payment channel is open, this address is the only one that can receive\n    // XRP from the channel. This comes from the Destination field of the transaction\n    // that created the channel.\n    destination: final.Destination,\n\n    // Total XRP, in drops, that has been allocated to this channel.\n    // This includes XRP that has been paid to the destination address.\n    // This is initially set by the transaction that created the channel and\n    // can be increased if the source address sends a PaymentChannelFund transaction.\n    channelAmountDrops:\n          new BigNumber(final.Amount || 0).toString(10),\n\n    // Total XRP, in drops, already paid out by the channel.\n    // The difference between this value and the Amount field is how much XRP can still\n    // be paid to the destination address with PaymentChannelClaim transactions.\n    // If the channel closes, the remaining difference is returned to the source address.\n    channelBalanceDrops:\n          new BigNumber(final.Balance || 0).toString(10)\n  }\n\n  if (prev.Amount) {\n    // The change in the number of XRP drops allocated to this channel.\n    // This is positive if this is a PaymentChannelFund transaction.\n    summary.channelAmountChangeDrops = new BigNumber(final.Amount)\n      .minus(new BigNumber(prev.Amount || 0))\n      .toString(10)\n  }\n\n  if (prev.Balance) {\n    // The change in the number of XRP drops already paid out by the channel.\n    summary.channelBalanceChangeDrops = new BigNumber(final.Balance)\n      .minus(new BigNumber(prev.Balance || 0))\n      .toString(10)\n  }\n\n  if (node.PreviousTxnID) {\n    // The identifying hash of the transaction that\n    // most recently modified this payment channel object.\n    // You can use this to retrieve the object's history.\n    summary.previousTxnId = node.PreviousTxnID\n  }\n\n  return summary\n}\n\nfunction parseChannelChanges(metadata) {\n  const paymentChannels = normalizeNodes(metadata)\n    .filter(n => {\n      return n.entryType === 'PayChannel'\n    })\n\n  return (paymentChannels.length === 1) ?\n    summarizePaymentChannel(paymentChannels[0]) :\n    undefined\n}\n\nmodule.exports.parseChannelChanges = parseChannelChanges\n"]},"metadata":{},"sourceType":"script"}