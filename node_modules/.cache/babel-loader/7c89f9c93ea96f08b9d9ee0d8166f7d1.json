{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar BigNumber = require('bignumber.js');\n\nvar normalizeNodes = require('./utils').normalizeNodes;\n\nvar dropsToXRP = require('./utils').dropsToXRP;\n\nfunction groupByAddress(balanceChanges) {\n  var grouped = _.groupBy(balanceChanges, function (node) {\n    return node.address;\n  });\n\n  return _.mapValues(grouped, function (group) {\n    return _.map(group, function (node) {\n      return node.balance;\n    });\n  });\n}\n\nfunction parseValue(value) {\n  return new BigNumber(value.value || value);\n}\n\nfunction computeBalanceChange(node) {\n  var value = null;\n\n  if (node.newFields.Balance) {\n    value = parseValue(node.newFields.Balance);\n  } else if (node.previousFields.Balance && node.finalFields.Balance) {\n    value = parseValue(node.finalFields.Balance).minus(parseValue(node.previousFields.Balance));\n  }\n\n  return value === null ? null : value.isZero() ? null : value;\n}\n\nfunction parseFinalBalance(node) {\n  if (node.newFields.Balance) {\n    return parseValue(node.newFields.Balance);\n  } else if (node.finalFields.Balance) {\n    return parseValue(node.finalFields.Balance);\n  }\n\n  return null;\n}\n\nfunction parseXRPQuantity(node, valueParser) {\n  var value = valueParser(node);\n\n  if (value === null) {\n    return null;\n  }\n\n  return {\n    address: node.finalFields.Account || node.newFields.Account,\n    balance: {\n      counterparty: '',\n      currency: 'XRP',\n      value: dropsToXRP(value).toString()\n    }\n  };\n}\n\nfunction flipTrustlinePerspective(quantity) {\n  var negatedBalance = new BigNumber(quantity.balance.value).negated();\n  return {\n    address: quantity.balance.counterparty,\n    balance: {\n      counterparty: quantity.address,\n      currency: quantity.balance.currency,\n      value: negatedBalance.toString()\n    }\n  };\n}\n\nfunction parseTrustlineQuantity(node, valueParser) {\n  var value = valueParser(node);\n\n  if (value === null) {\n    return null;\n  }\n  /*\n   * A trustline can be created with a non-zero starting balance\n   * If an offer is placed to acquire an asset with no existing trustline,\n   * the trustline can be created when the offer is taken.\n   */\n\n\n  var fields = _.isEmpty(node.newFields) ? node.finalFields : node.newFields; // the balance is always from low node's perspective\n\n  var result = {\n    address: fields.LowLimit.issuer,\n    balance: {\n      counterparty: fields.HighLimit.issuer,\n      currency: fields.Balance.currency,\n      value: value.toString()\n    }\n  };\n  return [result, flipTrustlinePerspective(result)];\n}\n\nfunction parseQuantities(metadata, valueParser) {\n  var values = normalizeNodes(metadata).map(function (node) {\n    if (node.entryType === 'AccountRoot') {\n      return [parseXRPQuantity(node, valueParser)];\n    } else if (node.entryType === 'RippleState') {\n      return parseTrustlineQuantity(node, valueParser);\n    }\n\n    return [];\n  });\n  return groupByAddress(_.compact(_.flatten(values)));\n}\n/**\n *  Computes the complete list of every balance that changed in the ledger\n *  as a result of the given transaction.\n *\n *  @param {Object} metadata Transaction metada\n *  @returns {Object} parsed balance changes\n */\n\n\nfunction parseBalanceChanges(metadata) {\n  return parseQuantities(metadata, computeBalanceChange);\n}\n/**\n *  Computes the complete list of every final balance in the ledger\n *  as a result of the given transaction.\n *\n *  @param {Object} metadata Transaction metada\n *  @returns {Object} parsed balances\n */\n\n\nfunction parseFinalBalances(metadata) {\n  return parseQuantities(metadata, parseFinalBalance);\n}\n\nmodule.exports.parseBalanceChanges = parseBalanceChanges;\nmodule.exports.parseFinalBalances = parseFinalBalances;","map":{"version":3,"sources":["C:/Users/masho/OneDrive/Desktop/Blockchain/Biconomy/Projects/NFT_minter/node_modules/ripple-lib-transactionparser/src/balancechanges.js"],"names":["_","require","BigNumber","normalizeNodes","dropsToXRP","groupByAddress","balanceChanges","grouped","groupBy","node","address","mapValues","group","map","balance","parseValue","value","computeBalanceChange","newFields","Balance","previousFields","finalFields","minus","isZero","parseFinalBalance","parseXRPQuantity","valueParser","Account","counterparty","currency","toString","flipTrustlinePerspective","quantity","negatedBalance","negated","parseTrustlineQuantity","fields","isEmpty","result","LowLimit","issuer","HighLimit","parseQuantities","metadata","values","entryType","compact","flatten","parseBalanceChanges","parseFinalBalances","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar _ = require('lodash')\nvar BigNumber = require('bignumber.js')\nvar normalizeNodes = require('./utils').normalizeNodes\nvar dropsToXRP = require('./utils').dropsToXRP\n\nfunction groupByAddress(balanceChanges) {\n  var grouped = _.groupBy(balanceChanges, function(node) {\n    return node.address\n  })\n  return _.mapValues(grouped, function(group) {\n    return _.map(group, function(node) {\n      return node.balance\n    })\n  })\n}\n\nfunction parseValue(value) {\n  return new BigNumber(value.value || value)\n}\n\nfunction computeBalanceChange(node) {\n  var value = null\n  if (node.newFields.Balance) {\n    value = parseValue(node.newFields.Balance)\n  } else if (node.previousFields.Balance && node.finalFields.Balance) {\n    value = parseValue(node.finalFields.Balance).minus(\n      parseValue(node.previousFields.Balance))\n  }\n  return value === null ? null : value.isZero() ? null : value\n}\n\nfunction parseFinalBalance(node) {\n  if (node.newFields.Balance) {\n    return parseValue(node.newFields.Balance)\n  } else if (node.finalFields.Balance) {\n    return parseValue(node.finalFields.Balance)\n  }\n  return null\n}\n\n\nfunction parseXRPQuantity(node, valueParser) {\n  var value = valueParser(node)\n\n  if (value === null) {\n    return null\n  }\n\n  return {\n    address: node.finalFields.Account || node.newFields.Account,\n    balance: {\n      counterparty: '',\n      currency: 'XRP',\n      value: dropsToXRP(value).toString()\n    }\n  }\n}\n\nfunction flipTrustlinePerspective(quantity) {\n  var negatedBalance = (new BigNumber(quantity.balance.value)).negated()\n  return {\n    address: quantity.balance.counterparty,\n    balance: {\n      counterparty: quantity.address,\n      currency: quantity.balance.currency,\n      value: negatedBalance.toString()\n    }\n  }\n}\n\nfunction parseTrustlineQuantity(node, valueParser) {\n  var value = valueParser(node)\n\n  if (value === null) {\n    return null\n  }\n\n  /*\n   * A trustline can be created with a non-zero starting balance\n   * If an offer is placed to acquire an asset with no existing trustline,\n   * the trustline can be created when the offer is taken.\n   */\n  var fields = _.isEmpty(node.newFields) ? node.finalFields : node.newFields\n\n  // the balance is always from low node's perspective\n  var result = {\n    address: fields.LowLimit.issuer,\n    balance: {\n      counterparty: fields.HighLimit.issuer,\n      currency: fields.Balance.currency,\n      value: value.toString()\n    }\n  }\n  return [result, flipTrustlinePerspective(result)]\n}\n\nfunction parseQuantities(metadata, valueParser) {\n  var values = normalizeNodes(metadata).map(function(node) {\n    if (node.entryType === 'AccountRoot') {\n      return [parseXRPQuantity(node, valueParser)]\n    } else if (node.entryType === 'RippleState') {\n      return parseTrustlineQuantity(node, valueParser)\n    }\n    return []\n  })\n  return groupByAddress(_.compact(_.flatten(values)))\n}\n\n/**\n *  Computes the complete list of every balance that changed in the ledger\n *  as a result of the given transaction.\n *\n *  @param {Object} metadata Transaction metada\n *  @returns {Object} parsed balance changes\n */\nfunction parseBalanceChanges(metadata) {\n  return parseQuantities(metadata, computeBalanceChange)\n}\n\n\n/**\n *  Computes the complete list of every final balance in the ledger\n *  as a result of the given transaction.\n *\n *  @param {Object} metadata Transaction metada\n *  @returns {Object} parsed balances\n */\nfunction parseFinalBalances(metadata) {\n  return parseQuantities(metadata, parseFinalBalance)\n}\n\nmodule.exports.parseBalanceChanges = parseBalanceChanges\nmodule.exports.parseFinalBalances = parseFinalBalances\n"]},"metadata":{},"sourceType":"script"}