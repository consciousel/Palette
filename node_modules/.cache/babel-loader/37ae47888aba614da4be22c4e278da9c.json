{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport fetchPonyfill from \"fetch-ponyfill\";\nimport URI from \"urijs\";\nimport { delay } from \"../util/promises\";\nexport function makeRestPayloadSender(_a) {\n  var _this = this;\n\n  var url = _a.url,\n      config = _a.config; // The rest payload sender only works for alchemy.com http endpoints.\n\n  var error;\n\n  if (/^wss?:\\/\\//.test(url)) {\n    error = \"Alchemy rest endpoints are not available via websockets\";\n  }\n\n  if (!url.includes(\"alchemy\")) {\n    error = \"Alchemy specific rest endpoints are not available with a non Alchemy provider.\";\n  }\n\n  if (url.includes(\"alchemyapi.io\") && !url.includes(\"eth-\")) {\n    error = \"Alchemy specific rest endpoints on L2 networks are not available with our legacy endpoints on alchemyapi.io. Please switch over to alchemy.com\";\n  } // Don't use the native `URL` class for this. It doesn't work in React Native.\n\n\n  var urlObject = new URI(url);\n  var origin = urlObject.origin();\n  var pathname = urlObject.path();\n  var apiKey = pathname.substring(pathname.lastIndexOf(\"/\") + 1);\n  var fetch = fetchPonyfill().fetch;\n\n  var sendRestPayload = function (path, payload) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var maxRetries, retryInterval, retryJitter, endpoint, i, response, status_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (error) {\n              throw new Error(error);\n            }\n\n            maxRetries = config.maxRetries, retryInterval = config.retryInterval, retryJitter = config.retryJitter;\n            if (!(origin && apiKey)) return [3\n            /*break*/\n            , 6];\n            endpoint = new URI(origin).search(payload).path(apiKey + path).toString();\n            i = 0;\n            _a.label = 1;\n\n          case 1:\n            if (!(i < maxRetries + 1)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , fetch(endpoint)];\n\n          case 2:\n            response = _a.sent();\n            status_1 = response.status;\n\n            switch (status_1) {\n              case 200:\n                return [2\n                /*return*/\n                , response.json()];\n\n              case 429:\n                break;\n\n              default:\n                throw new Error(response.status + \":\" + response.statusText);\n            }\n\n            return [4\n            /*yield*/\n            , delay(retryInterval + (retryJitter * Math.random() | 0))];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 5:\n            throw new Error(\"Rate limited for \" + (maxRetries + 1) + \" consecutive attempts.\");\n\n          case 6:\n            return [2\n            /*return*/\n            , Promise.resolve()];\n        }\n      });\n    });\n  };\n\n  return {\n    sendRestPayload: sendRestPayload\n  };\n}","map":{"version":3,"mappings":";AAAA,OAAOA,aAAP,MAA0B,gBAA1B;AACA,OAAOC,GAAP,MAAgB,OAAhB;AAEA,SAASC,KAAT,QAAsB,kBAAtB;AAgBA,OAAM,SAAUC,qBAAV,CAAgCC,EAAhC,EAGc;AAHpB;;MACEC,GAAG;MACHC,MAAM,aACY,CAClB;;AACA,MAAIC,KAAJ;;AACA,MAAI,aAAaC,IAAb,CAAkBH,GAAlB,CAAJ,EAA4B;AAC1BE,SAAK,GAAG,yDAAR;AACD;;AACD,MAAI,CAACF,GAAG,CAACI,QAAJ,CAAa,SAAb,CAAL,EAA8B;AAC5BF,SAAK,GACH,gFADF;AAED;;AACD,MAAIF,GAAG,CAACI,QAAJ,CAAa,eAAb,KAAiC,CAACJ,GAAG,CAACI,QAAJ,CAAa,MAAb,CAAtC,EAA4D;AAC1DF,SAAK,GACH,gJADF;AAED,GAbiB,CAelB;;;AACA,MAAMG,SAAS,GAAG,IAAIT,GAAJ,CAAQI,GAAR,CAAlB;AACA,MAAMM,MAAM,GAAGD,SAAS,CAACC,MAAV,EAAf;AACA,MAAMC,QAAQ,GAAGF,SAAS,CAACG,IAAV,EAAjB;AACA,MAAMC,MAAM,GAAGF,QAAQ,CAACG,SAAT,CAAmBH,QAAQ,CAACI,WAAT,CAAqB,GAArB,IAA4B,CAA/C,CAAf;AAEQ,WAAK,GAAKhB,aAAa,GAAEiB,KAAzB;;AAER,MAAMC,eAAe,GAAG,UACtBL,IADsB,EAEtBM,OAFsB,EAEM;AAAA;;;;;AAE5B,gBAAIZ,KAAJ,EAAW;AACT,oBAAM,IAAIa,KAAJ,CAAUb,KAAV,CAAN;AACD;;AACOc,sBAAU,GAAiCf,MAAM,WAAjD,EAAYgB,aAAa,GAAkBhB,MAAM,cAAjD,EAA2BiB,WAAW,GAAKjB,MAAM,YAAjD;kBACJK,MAAM,IAAIG,SAAV;AAAA;AAAA;AACIU,oBAAQ,GAAG,IAAIvB,GAAJ,CAAQU,MAAR,EACdc,MADc,CACPN,OADO,EAEdN,IAFc,CAETC,MAAM,GAAGD,IAFA,EAGda,QAHc,EAAX;AAIGC,aAAC,GAAG,CAAJ;;;;kBAAOA,CAAC,GAAGN,UAAU,GAAG,IAAC;AAAA;AAAA;AACf;AAAA;AAAA,cAAMJ,KAAK,CAACO,QAAD,CAAX;;;AAAXI,oBAAQ,GAAGxB,SAAX;AACEyB,uBAAWD,QAAQ,OAAnB;;AACR,oBAAQC,QAAR;AACE,mBAAK,GAAL;AACE;AAAA;AAAA,kBAAOD,QAAQ,CAACE,IAAT,EAAP;;AACF,mBAAK,GAAL;AACE;;AACF;AACE,sBAAM,IAAIV,KAAJ,CAAUQ,QAAQ,CAACG,MAAT,GAAkB,GAAlB,GAAwBH,QAAQ,CAACI,UAA3C,CAAN;AANJ;;AAQA;AAAA;AAAA,cAAM9B,KAAK,CAACoB,aAAa,IAAKC,WAAW,GAAGU,IAAI,CAACC,MAAL,EAAf,GAAgC,CAApC,CAAd,CAAX;;;AAAA9B;;;;;AAXkCuB,aAAC;;;;;;AAarC,kBAAM,IAAIP,KAAJ,CACJ,uBAAoBC,UAAU,GAAG,CAAjC,IAAkC,wBAD9B,CAAN;;;AAIF;AAAA;AAAA,cAAOc,OAAO,CAACC,OAAR,EAAP;;;KA5B4B;AA6B7B,GA/BD;;AAiCA,SAAO;AACLlB,mBAAe;AADV,GAAP;AAGD","names":["fetchPonyfill","URI","delay","makeRestPayloadSender","_a","url","config","error","test","includes","urlObject","origin","pathname","path","apiKey","substring","lastIndexOf","fetch","sendRestPayload","payload","Error","maxRetries","retryInterval","retryJitter","endpoint","search","toString","i","response","status_1","json","status","statusText","Math","random","Promise","resolve"],"sourceRoot":"","sources":["../../../src/web3-adapter/sendRestPayload.ts"],"sourcesContent":["import fetchPonyfill from \"fetch-ponyfill\";\nimport URI from \"urijs\";\nimport { FullConfig } from \"../types\";\nimport { delay } from \"../util/promises\";\n\nexport interface RestPayloadSender {\n  sendRestPayload: SendRestPayloadFunction;\n}\n\nexport type SendRestPayloadFunction = (\n  path: string,\n  payload: Record<string, any>,\n) => Promise<any>;\n\nexport interface RestPayloadConfig {\n  url: string;\n  config: FullConfig;\n}\n\nexport function makeRestPayloadSender({\n  url,\n  config,\n}: RestPayloadConfig): RestPayloadSender {\n  // The rest payload sender only works for alchemy.com http endpoints.\n  let error: string | undefined;\n  if (/^wss?:\\/\\//.test(url)) {\n    error = \"Alchemy rest endpoints are not available via websockets\";\n  }\n  if (!url.includes(\"alchemy\")) {\n    error =\n      \"Alchemy specific rest endpoints are not available with a non Alchemy provider.\";\n  }\n  if (url.includes(\"alchemyapi.io\") && !url.includes(\"eth-\")) {\n    error =\n      \"Alchemy specific rest endpoints on L2 networks are not available with our legacy endpoints on alchemyapi.io. Please switch over to alchemy.com\";\n  }\n\n  // Don't use the native `URL` class for this. It doesn't work in React Native.\n  const urlObject = new URI(url);\n  const origin = urlObject.origin();\n  const pathname = urlObject.path();\n  const apiKey = pathname.substring(pathname.lastIndexOf(\"/\") + 1);\n\n  const { fetch } = fetchPonyfill();\n\n  const sendRestPayload = async (\n    path: string,\n    payload: Record<string, any>,\n  ): Promise<any> => {\n    if (error) {\n      throw new Error(error);\n    }\n    const { maxRetries, retryInterval, retryJitter } = config;\n    if (origin && apiKey) {\n      const endpoint = new URI(origin)\n        .search(payload)\n        .path(apiKey + path)\n        .toString();\n      for (let i = 0; i < maxRetries + 1; i++) {\n        const response = await fetch(endpoint);\n        const { status } = response;\n        switch (status) {\n          case 200:\n            return response.json();\n          case 429:\n            break;\n          default:\n            throw new Error(response.status + \":\" + response.statusText);\n        }\n        await delay(retryInterval + ((retryJitter * Math.random()) | 0));\n      }\n      throw new Error(\n        `Rate limited for ${maxRetries + 1} consecutive attempts.`,\n      );\n    }\n    return Promise.resolve();\n  };\n\n  return {\n    sendRestPayload,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}