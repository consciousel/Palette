{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionType = exports.TransactionResult = exports.LedgerEntryType = exports.Type = exports.Field = exports.Bytes = exports.TRANSACTION_TYPES = void 0;\n\nvar enums = require(\"./definitions.json\");\n\nvar serialized_type_1 = require(\"../types/serialized-type\");\n\nvar buffer_1 = require(\"buffer/\");\n/*\n * @brief: All valid transaction types\n */\n\n\nexports.TRANSACTION_TYPES = Object.entries(enums.TRANSACTION_TYPES).filter(function (_a) {\n  var _key = _a[0],\n      value = _a[1];\n  return value >= 0;\n}).map(function (_a) {\n  var key = _a[0],\n      _value = _a[1];\n  return key;\n});\nvar TYPE_WIDTH = 2;\nvar LEDGER_ENTRY_WIDTH = 2;\nvar TRANSACTION_TYPE_WIDTH = 2;\nvar TRANSACTION_RESULT_WIDTH = 1;\n/*\n * @brief: Serialize a field based on type_code and Field.nth\n */\n\nfunction fieldHeader(type, nth) {\n  var header = [];\n\n  if (type < 16) {\n    if (nth < 16) {\n      header.push(type << 4 | nth);\n    } else {\n      header.push(type << 4, nth);\n    }\n  } else if (nth < 16) {\n    header.push(nth, type);\n  } else {\n    header.push(0, type, nth);\n  }\n\n  return buffer_1.Buffer.from(header);\n}\n/*\n * @brief: Bytes, name, and ordinal representing one type, ledger_type, transaction type, or result\n */\n\n\nvar Bytes =\n/** @class */\nfunction () {\n  function Bytes(name, ordinal, ordinalWidth) {\n    this.name = name;\n    this.ordinal = ordinal;\n    this.ordinalWidth = ordinalWidth;\n    this.bytes = buffer_1.Buffer.alloc(ordinalWidth);\n\n    for (var i = 0; i < ordinalWidth; i++) {\n      this.bytes[ordinalWidth - i - 1] = ordinal >>> i * 8 & 0xff;\n    }\n  }\n\n  Bytes.prototype.toJSON = function () {\n    return this.name;\n  };\n\n  Bytes.prototype.toBytesSink = function (sink) {\n    sink.put(this.bytes);\n  };\n\n  Bytes.prototype.toBytes = function () {\n    return this.bytes;\n  };\n\n  return Bytes;\n}();\n\nexports.Bytes = Bytes;\n/*\n * @brief: Collection of Bytes objects, mapping bidirectionally\n */\n\nvar BytesLookup =\n/** @class */\nfunction () {\n  function BytesLookup(types, ordinalWidth) {\n    var _this = this;\n\n    this.ordinalWidth = ordinalWidth;\n    Object.entries(types).forEach(function (_a) {\n      var k = _a[0],\n          v = _a[1];\n      _this[k] = new Bytes(k, v, ordinalWidth);\n      _this[v.toString()] = _this[k];\n    });\n  }\n\n  BytesLookup.prototype.from = function (value) {\n    return value instanceof Bytes ? value : this[value];\n  };\n\n  BytesLookup.prototype.fromParser = function (parser) {\n    return this.from(parser.readUIntN(this.ordinalWidth).toString());\n  };\n\n  return BytesLookup;\n}();\n\nfunction buildField(_a) {\n  var name = _a[0],\n      info = _a[1];\n  var typeOrdinal = enums.TYPES[info.type];\n  var field = fieldHeader(typeOrdinal, info.nth);\n  return {\n    name: name,\n    nth: info.nth,\n    isVariableLengthEncoded: info.isVLEncoded,\n    isSerialized: info.isSerialized,\n    isSigningField: info.isSigningField,\n    ordinal: typeOrdinal << 16 | info.nth,\n    type: new Bytes(info.type, typeOrdinal, TYPE_WIDTH),\n    header: field,\n    associatedType: serialized_type_1.SerializedType // For later assignment in ./types/index.js\n\n  };\n}\n/*\n * @brief: The collection of all fields as defined in definitions.json\n */\n\n\nvar FieldLookup =\n/** @class */\nfunction () {\n  function FieldLookup(fields) {\n    var _this = this;\n\n    fields.forEach(function (_a) {\n      var k = _a[0],\n          v = _a[1];\n      _this[k] = buildField([k, v]);\n      _this[_this[k].ordinal.toString()] = _this[k];\n    });\n  }\n\n  FieldLookup.prototype.fromString = function (value) {\n    return this[value];\n  };\n\n  return FieldLookup;\n}();\n\nvar Type = new BytesLookup(enums.TYPES, TYPE_WIDTH);\nexports.Type = Type;\nvar LedgerEntryType = new BytesLookup(enums.LEDGER_ENTRY_TYPES, LEDGER_ENTRY_WIDTH);\nexports.LedgerEntryType = LedgerEntryType;\nvar TransactionType = new BytesLookup(enums.TRANSACTION_TYPES, TRANSACTION_TYPE_WIDTH);\nexports.TransactionType = TransactionType;\nvar TransactionResult = new BytesLookup(enums.TRANSACTION_RESULTS, TRANSACTION_RESULT_WIDTH);\nexports.TransactionResult = TransactionResult;\nvar Field = new FieldLookup(enums.FIELDS);\nexports.Field = Field;","map":{"version":3,"mappings":"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","names":["exports","Object","entries","enums","TRANSACTION_TYPES","filter","_a","_key","value","map","key","_value","TYPE_WIDTH","LEDGER_ENTRY_WIDTH","TRANSACTION_TYPE_WIDTH","TRANSACTION_RESULT_WIDTH","fieldHeader","type","nth","header","push","buffer_1","from","name","ordinal","ordinalWidth","bytes","alloc","i","Bytes","sink","put","types","forEach","k","v","_this","toString","BytesLookup","parser","readUIntN","buildField","info","typeOrdinal","TYPES","field","isVariableLengthEncoded","isVLEncoded","isSerialized","isSigningField","associatedType","serialized_type_1","fields","FieldLookup","Type","LedgerEntryType","LEDGER_ENTRY_TYPES","TransactionType","TransactionResult","TRANSACTION_RESULTS","Field","FIELDS"],"sourceRoot":"","sources":["../../src/enums/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}