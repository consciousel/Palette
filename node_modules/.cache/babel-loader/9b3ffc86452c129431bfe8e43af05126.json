{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar TransformOperationExecutor_1 = require(\"../TransformOperationExecutor\");\n/**\n * Storage all library metadata.\n */\n\n\nvar MetadataStorage =\n/** @class */\nfunction () {\n  function MetadataStorage() {\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n    this._typeMetadatas = new Map();\n    this._transformMetadatas = new Map();\n    this._exposeMetadatas = new Map();\n    this._excludeMetadatas = new Map();\n    this._ancestorsMap = new Map();\n  } // -------------------------------------------------------------------------\n  // Adder Methods\n  // -------------------------------------------------------------------------\n\n\n  MetadataStorage.prototype.addTypeMetadata = function (metadata) {\n    if (!this._typeMetadatas.has(metadata.target)) {\n      this._typeMetadatas.set(metadata.target, new Map());\n    }\n\n    this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  };\n\n  MetadataStorage.prototype.addTransformMetadata = function (metadata) {\n    if (!this._transformMetadatas.has(metadata.target)) {\n      this._transformMetadatas.set(metadata.target, new Map());\n    }\n\n    if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n      this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n    }\n\n    this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n  };\n\n  MetadataStorage.prototype.addExposeMetadata = function (metadata) {\n    if (!this._exposeMetadatas.has(metadata.target)) {\n      this._exposeMetadatas.set(metadata.target, new Map());\n    }\n\n    this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  };\n\n  MetadataStorage.prototype.addExcludeMetadata = function (metadata) {\n    if (!this._excludeMetadatas.has(metadata.target)) {\n      this._excludeMetadatas.set(metadata.target, new Map());\n    }\n\n    this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }; // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  MetadataStorage.prototype.findTransformMetadatas = function (target, propertyName, transformationType) {\n    return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(function (metadata) {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_CLASS || transformationType === TransformOperationExecutor_1.TransformationType.PLAIN_TO_CLASS;\n      }\n\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    });\n  };\n\n  MetadataStorage.prototype.findExcludeMetadata = function (target, propertyName) {\n    return this.findMetadata(this._excludeMetadatas, target, propertyName);\n  };\n\n  MetadataStorage.prototype.findExposeMetadata = function (target, propertyName) {\n    return this.findMetadata(this._exposeMetadatas, target, propertyName);\n  };\n\n  MetadataStorage.prototype.findExposeMetadataByCustomName = function (target, name) {\n    return this.getExposedMetadatas(target).find(function (metadata) {\n      return metadata.options && metadata.options.name === name;\n    });\n  };\n\n  MetadataStorage.prototype.findTypeMetadata = function (target, propertyName) {\n    return this.findMetadata(this._typeMetadatas, target, propertyName);\n  };\n\n  MetadataStorage.prototype.getStrategy = function (target) {\n    var excludeMap = this._excludeMetadatas.get(target);\n\n    var exclude = excludeMap && excludeMap.get(undefined);\n\n    var exposeMap = this._exposeMetadatas.get(target);\n\n    var expose = exposeMap && exposeMap.get(undefined);\n    if (exclude && expose || !exclude && !expose) return \"none\";\n    return exclude ? \"excludeAll\" : \"exposeAll\";\n  };\n\n  MetadataStorage.prototype.getExposedMetadatas = function (target) {\n    return this.getMetadata(this._exposeMetadatas, target);\n  };\n\n  MetadataStorage.prototype.getExcludedMetadatas = function (target) {\n    return this.getMetadata(this._excludeMetadatas, target);\n  };\n\n  MetadataStorage.prototype.getExposedProperties = function (target, transformationType) {\n    return this.getExposedMetadatas(target).filter(function (metadata) {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_CLASS || transformationType === TransformOperationExecutor_1.TransformationType.PLAIN_TO_CLASS;\n      }\n\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    }).map(function (metadata) {\n      return metadata.propertyName;\n    });\n  };\n\n  MetadataStorage.prototype.getExcludedProperties = function (target, transformationType) {\n    return this.getExcludedMetadatas(target).filter(function (metadata) {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_CLASS || transformationType === TransformOperationExecutor_1.TransformationType.PLAIN_TO_CLASS;\n      }\n\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    }).map(function (metadata) {\n      return metadata.propertyName;\n    });\n  };\n\n  MetadataStorage.prototype.clear = function () {\n    this._typeMetadatas.clear();\n\n    this._exposeMetadatas.clear();\n\n    this._excludeMetadatas.clear();\n\n    this._ancestorsMap.clear();\n  }; // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n\n  MetadataStorage.prototype.getMetadata = function (metadatas, target) {\n    var metadataFromTargetMap = metadatas.get(target);\n    var metadataFromTarget;\n\n    if (metadataFromTargetMap) {\n      metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(function (meta) {\n        return meta.propertyName !== undefined;\n      });\n    }\n\n    var metadataFromAncestors = [];\n\n    for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n      var ancestor = _a[_i];\n      var ancestorMetadataMap = metadatas.get(ancestor);\n\n      if (ancestorMetadataMap) {\n        var metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(function (meta) {\n          return meta.propertyName !== undefined;\n        });\n        metadataFromAncestors.push.apply(metadataFromAncestors, metadataFromAncestor);\n      }\n    }\n\n    return metadataFromAncestors.concat(metadataFromTarget || []);\n  };\n\n  MetadataStorage.prototype.findMetadata = function (metadatas, target, propertyName) {\n    var metadataFromTargetMap = metadatas.get(target);\n\n    if (metadataFromTargetMap) {\n      var metadataFromTarget = metadataFromTargetMap.get(propertyName);\n\n      if (metadataFromTarget) {\n        return metadataFromTarget;\n      }\n    }\n\n    for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n      var ancestor = _a[_i];\n      var ancestorMetadataMap = metadatas.get(ancestor);\n\n      if (ancestorMetadataMap) {\n        var ancestorResult = ancestorMetadataMap.get(propertyName);\n\n        if (ancestorResult) {\n          return ancestorResult;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  MetadataStorage.prototype.findMetadatas = function (metadatas, target, propertyName) {\n    var metadataFromTargetMap = metadatas.get(target);\n    var metadataFromTarget;\n\n    if (metadataFromTargetMap) {\n      metadataFromTarget = metadataFromTargetMap.get(propertyName);\n    }\n\n    var metadataFromAncestorsTarget = [];\n\n    for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n      var ancestor = _a[_i];\n      var ancestorMetadataMap = metadatas.get(ancestor);\n\n      if (ancestorMetadataMap) {\n        if (ancestorMetadataMap.has(propertyName)) {\n          metadataFromAncestorsTarget.push.apply(metadataFromAncestorsTarget, ancestorMetadataMap.get(propertyName));\n        }\n      }\n    }\n\n    return metadataFromAncestorsTarget.reverse().concat((metadataFromTarget || []).reverse());\n  };\n\n  MetadataStorage.prototype.getAncestors = function (target) {\n    if (!target) return [];\n\n    if (!this._ancestorsMap.has(target)) {\n      var ancestors = [];\n\n      for (var baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== \"undefined\"; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\n        ancestors.push(baseClass);\n      }\n\n      this._ancestorsMap.set(target, ancestors);\n    }\n\n    return this._ancestorsMap.get(target);\n  };\n\n  return MetadataStorage;\n}();\n\nexports.MetadataStorage = MetadataStorage;","map":{"version":3,"mappings":";;;;;;AAGA;AAGA;;;;;AAGA;AAAA;AAAA;AAAA;AAEI;AACA;AACA;AAEQ,0BAAiB,IAAIA,GAAJ,EAAjB;AACA,+BAAsB,IAAIA,GAAJ,EAAtB;AACA,4BAAmB,IAAIA,GAAJ,EAAnB;AACA,6BAAoB,IAAIA,GAAJ,EAApB;AACA,yBAAgB,IAAIA,GAAJ,EAAhB;AAsNX,GAhOD,CAYI;AACA;AACA;;;AAEAC,wDAAgBC,QAAhB,EAAsC;AAClC,QAAI,CAAC,KAAKC,cAAL,CAAoBC,GAApB,CAAwBF,QAAQ,CAACG,MAAjC,CAAL,EAA+C;AAC3C,WAAKF,cAAL,CAAoBG,GAApB,CAAwBJ,QAAQ,CAACG,MAAjC,EAAyC,IAAIL,GAAJ,EAAzC;AACP;;AACG,SAAKG,cAAL,CAAoBI,GAApB,CAAwBL,QAAQ,CAACG,MAAjC,EAAyCC,GAAzC,CAA6CJ,QAAQ,CAACM,YAAtD,EAAoEN,QAApE;AACH,GALD;;AAOAD,6DAAqBC,QAArB,EAAgD;AAC5C,QAAI,CAAC,KAAKO,mBAAL,CAAyBL,GAAzB,CAA6BF,QAAQ,CAACG,MAAtC,CAAL,EAAoD;AAChD,WAAKI,mBAAL,CAAyBH,GAAzB,CAA6BJ,QAAQ,CAACG,MAAtC,EAA8C,IAAIL,GAAJ,EAA9C;AACP;;AACG,QAAI,CAAC,KAAKS,mBAAL,CAAyBF,GAAzB,CAA6BL,QAAQ,CAACG,MAAtC,EAA8CD,GAA9C,CAAkDF,QAAQ,CAACM,YAA3D,CAAL,EAA+E;AAC3E,WAAKC,mBAAL,CAAyBF,GAAzB,CAA6BL,QAAQ,CAACG,MAAtC,EAA8CC,GAA9C,CAAkDJ,QAAQ,CAACM,YAA3D,EAAyE,EAAzE;AACH;;AACD,SAAKC,mBAAL,CAAyBF,GAAzB,CAA6BL,QAAQ,CAACG,MAAtC,EAA8CE,GAA9C,CAAkDL,QAAQ,CAACM,YAA3D,EAAyEE,IAAzE,CAA8ER,QAA9E;AACH,GARD;;AAUAD,0DAAkBC,QAAlB,EAA0C;AACtC,QAAI,CAAC,KAAKS,gBAAL,CAAsBP,GAAtB,CAA0BF,QAAQ,CAACG,MAAnC,CAAL,EAAiD;AAC7C,WAAKM,gBAAL,CAAsBL,GAAtB,CAA0BJ,QAAQ,CAACG,MAAnC,EAA2C,IAAIL,GAAJ,EAA3C;AACP;;AACG,SAAKW,gBAAL,CAAsBJ,GAAtB,CAA0BL,QAAQ,CAACG,MAAnC,EAA2CC,GAA3C,CAA+CJ,QAAQ,CAACM,YAAxD,EAAsEN,QAAtE;AACH,GALD;;AAOAD,2DAAmBC,QAAnB,EAA4C;AACxC,QAAI,CAAC,KAAKU,iBAAL,CAAuBR,GAAvB,CAA2BF,QAAQ,CAACG,MAApC,CAAL,EAAkD;AAC9C,WAAKO,iBAAL,CAAuBN,GAAvB,CAA2BJ,QAAQ,CAACG,MAApC,EAA4C,IAAIL,GAAJ,EAA5C;AACP;;AACG,SAAKY,iBAAL,CAAuBL,GAAvB,CAA2BL,QAAQ,CAACG,MAApC,EAA4CC,GAA5C,CAAgDJ,QAAQ,CAACM,YAAzD,EAAuEN,QAAvE;AACH,GALD,CAxCJ,CA+CI;AACA;AACA;;;AAEAD,+DAAuBI,MAAvB,EAAyCG,YAAzC,EAA+DK,kBAA/D,EAAqG;AACjG,WAAO,KAAKC,aAAL,CAAmB,KAAKL,mBAAxB,EAA6CJ,MAA7C,EAAqDG,YAArD,EACFO,MADE,CACK,oBAAQ;AACZ,UAAI,CAACb,QAAQ,CAACc,OAAd,EACI,OAAO,IAAP;AACJ,UAAId,QAAQ,CAACc,OAAT,CAAiBC,WAAjB,KAAiC,IAAjC,IAAyCf,QAAQ,CAACc,OAAT,CAAiBE,WAAjB,KAAiC,IAA9E,EACI,OAAO,IAAP;;AAEJ,UAAIhB,QAAQ,CAACc,OAAT,CAAiBC,WAAjB,KAAiC,IAArC,EAA2C;AACvC,eAAOJ,kBAAkB,KAAKM,gDAAmBC,cAA1C,IAA6DP,kBAAkB,KAAKM,gDAAmBE,cAA9G;AACH;;AACD,UAAInB,QAAQ,CAACc,OAAT,CAAiBE,WAAjB,KAAiC,IAArC,EAA2C;AACvC,eAAOL,kBAAkB,KAAKM,gDAAmBG,cAAjD;AACH;;AAED,aAAO,IAAP;AACH,KAfE,CAAP;AAgBH,GAjBD;;AAmBArB,4DAAoBI,MAApB,EAAsCG,YAAtC,EAA0D;AACtD,WAAO,KAAKe,YAAL,CAAkB,KAAKX,iBAAvB,EAA0CP,MAA1C,EAAkDG,YAAlD,CAAP;AACH,GAFD;;AAIAP,2DAAmBI,MAAnB,EAAqCG,YAArC,EAAyD;AACrD,WAAO,KAAKe,YAAL,CAAkB,KAAKZ,gBAAvB,EAAyCN,MAAzC,EAAiDG,YAAjD,CAAP;AACH,GAFD;;AAIAP,uEAA+BI,MAA/B,EAAiDmB,IAAjD,EAA6D;AACzD,WAAO,KAAKC,mBAAL,CAAyBpB,MAAzB,EAAiCqB,IAAjC,CAAsC,oBAAQ;AACjD,aAAOxB,QAAQ,CAACc,OAAT,IAAoBd,QAAQ,CAACc,OAAT,CAAiBQ,IAAjB,KAA0BA,IAArD;AACH,KAFM,CAAP;AAGH,GAJD;;AAMAvB,yDAAiBI,MAAjB,EAAmCG,YAAnC,EAAuD;AACnD,WAAO,KAAKe,YAAL,CAAkB,KAAKpB,cAAvB,EAAuCE,MAAvC,EAA+CG,YAA/C,CAAP;AACH,GAFD;;AAIAP,oDAAYI,MAAZ,EAA4B;AACxB,QAAMsB,UAAU,GAAG,KAAKf,iBAAL,CAAuBL,GAAvB,CAA2BF,MAA3B,CAAnB;;AACA,QAAMuB,OAAO,GAAGD,UAAU,IAAIA,UAAU,CAACpB,GAAX,CAAesB,SAAf,CAA9B;;AACA,QAAMC,SAAS,GAAG,KAAKnB,gBAAL,CAAsBJ,GAAtB,CAA0BF,MAA1B,CAAlB;;AACA,QAAM0B,MAAM,GAAGD,SAAS,IAAIA,SAAS,CAACvB,GAAV,CAAcsB,SAAd,CAA5B;AACA,QAAKD,OAAO,IAAIG,MAAZ,IAAwB,CAACH,OAAD,IAAY,CAACG,MAAzC,EAAkD,OAAO,MAAP;AAClD,WAAOH,OAAO,GAAG,YAAH,GAAkB,WAAhC;AACH,GAPD;;AASA3B,4DAAoBI,MAApB,EAAoC;AAChC,WAAO,KAAK2B,WAAL,CAAiB,KAAKrB,gBAAtB,EAAwCN,MAAxC,CAAP;AACH,GAFD;;AAIAJ,6DAAqBI,MAArB,EAAqC;AACjC,WAAO,KAAK2B,WAAL,CAAiB,KAAKpB,iBAAtB,EAAyCP,MAAzC,CAAP;AACH,GAFD;;AAIAJ,6DAAqBI,MAArB,EAAuCQ,kBAAvC,EAA6E;AACzE,WAAO,KAAKY,mBAAL,CAAyBpB,MAAzB,EACFU,MADE,CACK,oBAAQ;AACZ,UAAI,CAACb,QAAQ,CAACc,OAAd,EACI,OAAO,IAAP;AACJ,UAAId,QAAQ,CAACc,OAAT,CAAiBC,WAAjB,KAAiC,IAAjC,IAAyCf,QAAQ,CAACc,OAAT,CAAiBE,WAAjB,KAAiC,IAA9E,EACI,OAAO,IAAP;;AAEJ,UAAIhB,QAAQ,CAACc,OAAT,CAAiBC,WAAjB,KAAiC,IAArC,EAA2C;AACvC,eAAOJ,kBAAkB,KAAKM,gDAAmBC,cAA1C,IAA6DP,kBAAkB,KAAKM,gDAAmBE,cAA9G;AACH;;AACD,UAAInB,QAAQ,CAACc,OAAT,CAAiBE,WAAjB,KAAiC,IAArC,EAA2C;AACvC,eAAOL,kBAAkB,KAAKM,gDAAmBG,cAAjD;AACH;;AAED,aAAO,IAAP;AACH,KAfE,EAgBFW,GAhBE,CAgBE,oBAAQ;AAAI,qBAAQ,CAACzB,YAAT;AAAqB,KAhBnC,CAAP;AAiBH,GAlBD;;AAoBAP,8DAAsBI,MAAtB,EAAwCQ,kBAAxC,EAA8E;AAC1E,WAAO,KAAKqB,oBAAL,CAA0B7B,MAA1B,EACFU,MADE,CACK,oBAAQ;AACZ,UAAI,CAACb,QAAQ,CAACc,OAAd,EACI,OAAO,IAAP;AACJ,UAAId,QAAQ,CAACc,OAAT,CAAiBC,WAAjB,KAAiC,IAAjC,IAAyCf,QAAQ,CAACc,OAAT,CAAiBE,WAAjB,KAAiC,IAA9E,EACI,OAAO,IAAP;;AAEJ,UAAIhB,QAAQ,CAACc,OAAT,CAAiBC,WAAjB,KAAiC,IAArC,EAA2C;AACvC,eAAOJ,kBAAkB,KAAKM,gDAAmBC,cAA1C,IAA6DP,kBAAkB,KAAKM,gDAAmBE,cAA9G;AACH;;AACD,UAAInB,QAAQ,CAACc,OAAT,CAAiBE,WAAjB,KAAiC,IAArC,EAA2C;AACvC,eAAOL,kBAAkB,KAAKM,gDAAmBG,cAAjD;AACH;;AAED,aAAO,IAAP;AACH,KAfE,EAgBFW,GAhBE,CAgBE,oBAAQ;AAAI,qBAAQ,CAACzB,YAAT;AAAqB,KAhBnC,CAAP;AAiBH,GAlBD;;AAoBAP;AACI,SAAKE,cAAL,CAAoBgC,KAApB;;AACA,SAAKxB,gBAAL,CAAsBwB,KAAtB;;AACA,SAAKvB,iBAAL,CAAuBuB,KAAvB;;AACA,SAAKC,aAAL,CAAmBD,KAAnB;AACH,GALD,CAjJJ,CAwJI;AACA;AACA;;;AAEQlC,0CAAR,UAA0EoC,SAA1E,EAAoHhC,MAApH,EAAoI;AAChI,QAAMiC,qBAAqB,GAAGD,SAAS,CAAC9B,GAAV,CAAcF,MAAd,CAA9B;AACA,QAAIkC,kBAAJ;;AACA,QAAID,qBAAJ,EAA2B;AACvBC,wBAAkB,GAAGC,KAAK,CAACC,IAAN,CAAWH,qBAAqB,CAACI,MAAtB,EAAX,EAA2C3B,MAA3C,CAAkD,gBAAI;AAAI,mBAAI,CAACP,YAAL,KAAsBqB,SAAtB;AAA+B,OAAzF,CAArB;AACH;;AACD,QAAIc,qBAAqB,GAAQ,EAAjC;;AACA,SAAuB,sBAAKC,YAAL,CAAkBvC,MAAlB,CAAvB,EAAuBwC,cAAvB,EAAuBA,IAAvB,EAAkD;AAA7C,UAAMC,QAAQ,SAAd;AACD,UAAMC,mBAAmB,GAAGV,SAAS,CAAC9B,GAAV,CAAcuC,QAAd,CAA5B;;AACA,UAAIC,mBAAJ,EAAyB;AACrB,YAAMC,oBAAoB,GAAGR,KAAK,CAACC,IAAN,CAAWM,mBAAmB,CAACL,MAApB,EAAX,EAAyC3B,MAAzC,CAAgD,gBAAI;AAAI,qBAAI,CAACP,YAAL,KAAsBqB,SAAtB;AAA+B,SAAvF,CAA7B;AACAc,6BAAqB,CAACjC,IAAtB,CAA0BuC,KAA1B,wBAA8BD,oBAA9B;AACH;AACJ;;AACD,WAAOL,qBAAqB,CAACO,MAAtB,CAA6BX,kBAAkB,IAAI,EAAnD,CAAP;AACH,GAfO;;AAiBAtC,2CAAR,UAA2EoC,SAA3E,EAAqHhC,MAArH,EAAuIG,YAAvI,EAA2J;AACvJ,QAAM8B,qBAAqB,GAAGD,SAAS,CAAC9B,GAAV,CAAcF,MAAd,CAA9B;;AACA,QAAIiC,qBAAJ,EAA2B;AACvB,UAAMC,kBAAkB,GAAGD,qBAAqB,CAAC/B,GAAtB,CAA0BC,YAA1B,CAA3B;;AACA,UAAI+B,kBAAJ,EAAwB;AACpB,eAAOA,kBAAP;AACH;AACJ;;AACD,SAAuB,sBAAKK,YAAL,CAAkBvC,MAAlB,CAAvB,EAAuBwC,cAAvB,EAAuBA,IAAvB,EAAkD;AAA7C,UAAMC,QAAQ,SAAd;AACD,UAAMC,mBAAmB,GAAGV,SAAS,CAAC9B,GAAV,CAAcuC,QAAd,CAA5B;;AACA,UAAIC,mBAAJ,EAAyB;AACrB,YAAMI,cAAc,GAAGJ,mBAAmB,CAACxC,GAApB,CAAwBC,YAAxB,CAAvB;;AACA,YAAI2C,cAAJ,EAAoB;AAClB,iBAAOA,cAAP;AACD;AACJ;AACJ;;AACD,WAAOtB,SAAP;AACH,GAlBO;;AAoBA5B,4CAAR,UAA4EoC,SAA5E,EAAwHhC,MAAxH,EAA0IG,YAA1I,EAA8J;AAC1J,QAAM8B,qBAAqB,GAAGD,SAAS,CAAC9B,GAAV,CAAcF,MAAd,CAA9B;AACA,QAAIkC,kBAAJ;;AACA,QAAID,qBAAJ,EAA2B;AACvBC,wBAAkB,GAAGD,qBAAqB,CAAC/B,GAAtB,CAA0BC,YAA1B,CAArB;AACH;;AACD,QAAI4C,2BAA2B,GAAQ,EAAvC;;AACA,SAAuB,sBAAKR,YAAL,CAAkBvC,MAAlB,CAAvB,EAAuBwC,cAAvB,EAAuBA,IAAvB,EAAkD;AAA7C,UAAMC,QAAQ,SAAd;AACD,UAAMC,mBAAmB,GAAGV,SAAS,CAAC9B,GAAV,CAAcuC,QAAd,CAA5B;;AACA,UAAIC,mBAAJ,EAAyB;AACrB,YAAIA,mBAAmB,CAAC3C,GAApB,CAAwBI,YAAxB,CAAJ,EAA2C;AACzC4C,qCAA2B,CAAC1C,IAA5B,CAAgCuC,KAAhC,8BAAoCF,mBAAmB,CAACxC,GAApB,CAAwBC,YAAxB,CAApC;AACD;AACJ;AACJ;;AACD,WAAQ4C,2BAAD,CAA8BC,OAA9B,GAAwCH,MAAxC,CAA+C,CAACX,kBAAkB,IAAI,EAAvB,EAA2Bc,OAA3B,EAA/C,CAAP;AACH,GAhBO;;AAkBApD,2CAAR,UAAqBI,MAArB,EAAqC;AACjC,QAAI,CAACA,MAAL,EAAa,OAAO,EAAP;;AACb,QAAI,CAAC,KAAK+B,aAAL,CAAmBhC,GAAnB,CAAuBC,MAAvB,CAAL,EAAqC;AACjC,UAAIiD,SAAS,GAAe,EAA5B;;AACA,WAAK,IAAIC,SAAS,GAAGC,MAAM,CAACC,cAAP,CAAsBpD,MAAM,CAACqD,SAAP,CAAiBC,WAAvC,CAArB,EACK,OAAOJ,SAAS,CAACG,SAAjB,KAA+B,WADpC,EAEKH,SAAS,GAAGC,MAAM,CAACC,cAAP,CAAsBF,SAAS,CAACG,SAAV,CAAoBC,WAA1C,CAFjB,EAEyE;AACrEL,iBAAS,CAAC5C,IAAV,CAAe6C,SAAf;AACH;;AACD,WAAKnB,aAAL,CAAmB9B,GAAnB,CAAuBD,MAAvB,EAA+BiD,SAA/B;AACH;;AACD,WAAO,KAAKlB,aAAL,CAAmB7B,GAAnB,CAAuBF,MAAvB,CAAP;AACH,GAZO;;AAaZ;AAhOA;;AAAauD","names":["Map","MetadataStorage","metadata","_typeMetadatas","has","target","set","get","propertyName","_transformMetadatas","push","_exposeMetadatas","_excludeMetadatas","transformationType","findMetadatas","filter","options","toClassOnly","toPlainOnly","TransformOperationExecutor_1","CLASS_TO_CLASS","PLAIN_TO_CLASS","CLASS_TO_PLAIN","findMetadata","name","getExposedMetadatas","find","excludeMap","exclude","undefined","exposeMap","expose","getMetadata","map","getExcludedMetadatas","clear","_ancestorsMap","metadatas","metadataFromTargetMap","metadataFromTarget","Array","from","values","metadataFromAncestors","getAncestors","_i","ancestor","ancestorMetadataMap","metadataFromAncestor","apply","concat","ancestorResult","metadataFromAncestorsTarget","reverse","ancestors","baseClass","Object","getPrototypeOf","prototype","constructor","exports"],"sourceRoot":"..","sources":["../../src/metadata/MetadataStorage.ts"],"sourcesContent":["import {TypeMetadata} from \"./TypeMetadata\";\nimport {ExposeMetadata} from \"./ExposeMetadata\";\nimport {ExcludeMetadata} from \"./ExcludeMetadata\";\nimport {TransformationType} from \"../TransformOperationExecutor\";\nimport {TransformMetadata} from \"./TransformMetadata\";\n\n/**\n * Storage all library metadata.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    private _typeMetadatas = new Map<Function, Map<string, TypeMetadata>>();\n    private _transformMetadatas = new Map<Function, Map<string, TransformMetadata[]>>();\n    private _exposeMetadatas = new Map<Function, Map<string, ExposeMetadata>>();\n    private _excludeMetadatas = new Map<Function, Map<string, ExcludeMetadata>>();\n    private _ancestorsMap = new Map<Function, Function[]>();\n\n    // -------------------------------------------------------------------------\n    // Adder Methods\n    // -------------------------------------------------------------------------\n\n    addTypeMetadata(metadata: TypeMetadata) {\n        if (!this._typeMetadatas.has(metadata.target)) {\n            this._typeMetadatas.set(metadata.target, new Map<string, TypeMetadata>());\n    }\n        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n\n    addTransformMetadata(metadata: TransformMetadata) {\n        if (!this._transformMetadatas.has(metadata.target)) {\n            this._transformMetadatas.set(metadata.target, new Map<string, TransformMetadata[]>());\n    }\n        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n            this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n        }\n        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n    }\n\n    addExposeMetadata(metadata: ExposeMetadata) {\n        if (!this._exposeMetadatas.has(metadata.target)) {\n            this._exposeMetadatas.set(metadata.target, new Map<string, ExposeMetadata>());\n    }\n        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n\n    addExcludeMetadata(metadata: ExcludeMetadata) {\n        if (!this._excludeMetadatas.has(metadata.target)) {\n            this._excludeMetadatas.set(metadata.target, new Map<string, ExcludeMetadata>());\n    }\n        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    findTransformMetadatas(target: Function, propertyName: string, transformationType: TransformationType): TransformMetadata[] {\n        return this.findMetadatas(this._transformMetadatas, target, propertyName)\n            .filter(metadata => {\n                if (!metadata.options)\n                    return true;\n                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                    return true;\n\n                if (metadata.options.toClassOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;\n                }\n                if (metadata.options.toPlainOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_PLAIN;\n                }\n\n                return true;\n            });\n    }\n\n    findExcludeMetadata(target: Function, propertyName: string): ExcludeMetadata {\n        return this.findMetadata(this._excludeMetadatas, target, propertyName);\n    }\n\n    findExposeMetadata(target: Function, propertyName: string): ExposeMetadata {\n        return this.findMetadata(this._exposeMetadatas, target, propertyName);\n    }\n\n    findExposeMetadataByCustomName(target: Function, name: string): ExposeMetadata {\n        return this.getExposedMetadatas(target).find(metadata => {\n            return metadata.options && metadata.options.name === name;\n        });\n    }\n\n    findTypeMetadata(target: Function, propertyName: string) {\n        return this.findMetadata(this._typeMetadatas, target, propertyName);\n    }\n\n    getStrategy(target: Function): \"excludeAll\"|\"exposeAll\"|\"none\" {\n        const excludeMap = this._excludeMetadatas.get(target);\n        const exclude = excludeMap && excludeMap.get(undefined);\n        const exposeMap = this._exposeMetadatas.get(target);\n        const expose = exposeMap && exposeMap.get(undefined);\n        if ((exclude && expose) || (!exclude && !expose)) return \"none\";\n        return exclude ? \"excludeAll\" : \"exposeAll\";\n    }\n\n    getExposedMetadatas(target: Function): ExposeMetadata[] {\n        return this.getMetadata(this._exposeMetadatas, target);\n    }\n\n    getExcludedMetadatas(target: Function): ExcludeMetadata[] {\n        return this.getMetadata(this._excludeMetadatas, target);\n    }\n\n    getExposedProperties(target: Function, transformationType: TransformationType): string[] {\n        return this.getExposedMetadatas(target)\n            .filter(metadata => {\n                if (!metadata.options)\n                    return true;\n                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                    return true;\n\n                if (metadata.options.toClassOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;\n                }\n                if (metadata.options.toPlainOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_PLAIN;\n                }\n\n                return true;\n            })\n            .map(metadata => metadata.propertyName);\n    }\n\n    getExcludedProperties(target: Function, transformationType: TransformationType): string[] {\n        return this.getExcludedMetadatas(target)\n            .filter(metadata => {\n                if (!metadata.options)\n                    return true;\n                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                    return true;\n\n                if (metadata.options.toClassOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;\n                }\n                if (metadata.options.toPlainOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_PLAIN;\n                }\n\n                return true;\n            })\n            .map(metadata => metadata.propertyName);\n    }\n\n    clear() {\n        this._typeMetadatas.clear();\n        this._exposeMetadatas.clear();\n        this._excludeMetadatas.clear();\n        this._ancestorsMap.clear();\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private getMetadata<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<String, T>>, target: Function): T[] {\n        const metadataFromTargetMap = metadatas.get(target);\n        let metadataFromTarget: T[];\n        if (metadataFromTargetMap) {\n            metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);\n        }\n        let metadataFromAncestors: T[] = [];\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(meta => meta.propertyName !== undefined);\n                metadataFromAncestors.push(...metadataFromAncestor);\n            }\n        }        \n        return metadataFromAncestors.concat(metadataFromTarget || []);\n    }\n\n    private findMetadata<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<string, T>>, target: Function, propertyName: string): T {\n        const metadataFromTargetMap = metadatas.get(target);\n        if (metadataFromTargetMap) {\n            const metadataFromTarget = metadataFromTargetMap.get(propertyName);  \n            if (metadataFromTarget) {\n                return metadataFromTarget;\n            }\n        }\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                const ancestorResult = ancestorMetadataMap.get(propertyName);\n                if (ancestorResult) {\n                  return ancestorResult;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    private findMetadatas<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<string, T[]>>, target: Function, propertyName: string): T[] {\n        const metadataFromTargetMap = metadatas.get(target);\n        let metadataFromTarget: T[];\n        if (metadataFromTargetMap) {\n            metadataFromTarget = metadataFromTargetMap.get(propertyName);    \n        }\n        let metadataFromAncestorsTarget: T[] = [];\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                if (ancestorMetadataMap.has(propertyName)) {\n                  metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));\n                }\n            }\n        }\n        return (metadataFromAncestorsTarget).reverse().concat((metadataFromTarget || []).reverse());\n    }\n\n    private getAncestors(target: Function): Function[] {\n        if (!target) return [];\n        if (!this._ancestorsMap.has(target)) {\n            let ancestors: Function[] = [];\n            for (let baseClass = Object.getPrototypeOf(target.prototype.constructor);\n                 typeof baseClass.prototype !== \"undefined\";\n                 baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\n                ancestors.push(baseClass);\n            }\n            this._ancestorsMap.set(target, ancestors);\n        }\n        return this._ancestorsMap.get(target);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}