{"ast":null,"code":"'use strict';\n\nvar helpers = require('./helpers');\n/** @type ValidatorResult */\n\n\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\n\nvar SchemaError = helpers.SchemaError;\nvar attribute = {};\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'exclusiveMinimum': true,\n  'exclusiveMaximum': true,\n  'additionalItems': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n/**\n * @name validators\n */\n\nvar validators = attribute.validators = {};\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\n\nvalidators.type = function validateType(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      return v.id && '<' + v.id + '>' || v + '';\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list\n    });\n  }\n\n  return result;\n};\n\nfunction testSchema(instance, options, ctx, callback, schema) {\n  var res = this.validateSchema(instance, schema, options, ctx);\n\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n\n  return res.valid;\n}\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\n\n\nvalidators.anyOf = function validateAnyOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!Array.isArray(schema.anyOf)) {\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n\n  if (!schema.anyOf.some(testSchema.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  }))) {\n    var list = schema.anyOf.map(function (v, i) {\n      return v.id && '<' + v.id + '>' || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n    });\n\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.allOf = function validateAllOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema.allOf)) {\n    throw new SchemaError(\"allOf must be an array\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function (v, i) {\n    var valid = self.validateSchema(instance, v, options, ctx);\n\n    if (!valid.valid) {\n      var msg = v.id && '<' + v.id + '>' || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n      result.addError({\n        name: 'allOf',\n        argument: {\n          id: msg,\n          length: valid.errors.length,\n          valid: valid\n        },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:'\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.oneOf = function validateOneOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema.oneOf)) {\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(testSchema.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  })).length;\n  var list = schema.oneOf.map(function (v, i) {\n    return v.id && '<' + v.id + '>' || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n  });\n\n  if (count !== 1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.properties = function validateProperties(instance, schema, options, ctx) {\n  if (instance === undefined || !(instance instanceof Object)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n\n  for (var property in properties) {\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, properties[property], options, ctx);\n    }\n\n    var prop = (instance || undefined) && instance[property];\n    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n\n  return result;\n};\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\n\n\nfunction testAdditionalProperty(instance, schema, options, ctx, property, result) {\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"additionalProperty \" + JSON.stringify(property) + \" exists in instance when not allowed\"\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.patternProperties = function validatePatternProperties(instance, schema, options, ctx) {\n  if (instance === undefined) return;\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n\n    for (var pattern in patternProperties) {\n      var expr = new RegExp(pattern);\n\n      if (!expr.test(property)) {\n        continue;\n      }\n\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, patternProperties[pattern], options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));\n      if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.additionalProperties = function validateAdditionalProperties(instance, schema, options, ctx) {\n  if (instance === undefined) return;\n  if (!this.types.object(instance)) return; // if patternProperties is defined then we'll test when that one is called instead\n\n  if (schema.patternProperties) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minProperties = function validateMinProperties(instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxProperties = function validateMaxProperties(instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties\n    });\n  }\n\n  return result;\n};\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.items = function validateItems(instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n\n  var self = this;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (instance === undefined || !schema.items) {\n    return result;\n  }\n\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? schema.items[i] || schema.additionalItems : schema.items;\n\n    if (items === undefined) {\n      return true;\n    }\n\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\"\n      });\n      return false;\n    }\n\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if (res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minimum = function validateMinimum(instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = true;\n\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    valid = instance > schema.minimum;\n  } else {\n    valid = instance >= schema.minimum;\n  }\n\n  if (!valid) {\n    result.addError({\n      name: 'minimum',\n      argument: schema.minimum,\n      message: \"must have a minimum value of \" + schema.minimum\n    });\n  }\n\n  return result;\n};\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maximum = function validateMaximum(instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid;\n\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    valid = instance < schema.maximum;\n  } else {\n    valid = instance <= schema.maximum;\n  }\n\n  if (!valid) {\n    result.addError({\n      name: 'maximum',\n      argument: schema.maximum,\n      message: \"must have a maximum value of \" + schema.maximum\n    });\n  }\n\n  return result;\n};\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\n\n\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, validationType, errorMessage) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n\n  var validationArgument = schema[validationType];\n\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n  var maxDecimals = Math.max(instanceDecimals, divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument: validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.multipleOf = function validateMultipleOf(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.divisibleBy = function validateDivisibleBy(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.required = function validateRequired(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatability with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (instance && typeof instance === 'object' && Array.isArray(schema.required)) {\n    schema.required.forEach(function (n) {\n      if (instance[n] === undefined) {\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n)\n        });\n      }\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.pattern = function validatePattern(instance, schema, options, ctx) {\n  if (typeof instance !== 'string') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!instance.match(schema.pattern)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern)\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\n\n\nvalidators.format = function validateFormat(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\"\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minLength = function validateMinLength(instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxLength = function validateMaxLength(instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minItems = function validateMinItems(instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxItems = function validateMaxItems(instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems\n    });\n  }\n\n  return result;\n};\n/**\n * Validates that every item in an instance array is unique, when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!Array.isArray(instance)) {\n    return result;\n  }\n\n  function testArrays(v, i, a) {\n    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\"\n    });\n  }\n\n  return result;\n};\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\n\n\nfunction testArrays(v, i, a) {\n  var j,\n      len = a.length;\n\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\n\n\nvalidators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\"\n    });\n  }\n\n  return result;\n};\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\n\n\nvalidators.dependencies = function validateDependencies(instance, schema, options, ctx) {\n  if (!instance || typeof instance != 'object') {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if (result.instance !== res.instance) result.instance = res.instance;\n\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\n\n\nvalidators['enum'] = function validateEnum(instance, schema, options, ctx) {\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\n\n\nvalidators['const'] = function validateEnum(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const']\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\n\n\nvalidators.not = validators.disallow = function validateNot(instance, schema, options, ctx) {\n  var self = this;\n  if (instance === undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if (!notTypes) return null;\n  if (!Array.isArray(notTypes)) notTypes = [notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var schemaId = type && type.id && '<' + type.id + '>' || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;","map":{"version":3,"sources":["C:/Users/masho/OneDrive/Desktop/Blockchain/Biconomy/Projects/NFT_minter/node_modules/jsonschema/lib/attribute.js"],"names":["helpers","require","ValidatorResult","SchemaError","attribute","ignoreProperties","validators","type","validateType","instance","schema","options","ctx","undefined","result","types","Array","isArray","some","testType","bind","list","map","v","id","addError","name","argument","message","testSchema","callback","res","validateSchema","valid","Function","anyOf","validateAnyOf","inner","importErrors","i","title","JSON","stringify","nestedErrors","join","allOf","validateAllOf","self","forEach","msg","length","errors","oneOf","validateOneOf","count","filter","properties","validateProperties","Object","property","preValidateProperty","prop","makeChild","testAdditionalProperty","additionalProperties","patternProperties","validatePatternProperties","object","test","pattern","expr","RegExp","call","validateAdditionalProperties","minProperties","validateMinProperties","keys","maxProperties","validateMaxProperties","items","validateItems","every","value","additionalItems","minimum","validateMinimum","exclusiveMinimum","maximum","validateMaximum","exclusiveMaximum","validateMultipleOfOrDivisbleBy","validationType","errorMessage","validationArgument","instanceDecimals","getDecimalPlaces","divisorDecimals","maxDecimals","Math","max","multiplier","pow","round","multipleOf","validateMultipleOf","divisibleBy","validateDivisibleBy","required","validateRequired","n","validatePattern","match","format","validateFormat","disableFormat","isFormat","minLength","validateMinLength","maxLength","validateMaxLength","minItems","validateMinItems","maxItems","validateMaxItems","uniqueItems","validateUniqueItems","testArrays","a","j","deepCompareStrict","len","dependencies","validateDependencies","dep","childContext","propertyPath","validateEnum","not","disallow","validateNot","notTypes","schemaId","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('./helpers');\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\n\nvar attribute = {};\n\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'exclusiveMinimum': true,\n  'exclusiveMaximum': true,\n  'additionalItems': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      return v.id && ('<' + v.id + '>') || (v+'');\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list,\n    });\n  }\n  return result;\n};\n\nfunction testSchema(instance, options, ctx, callback, schema){\n  var res = this.validateSchema(instance, schema, options, ctx);\n  if (! res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)){\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(\n    testSchema.bind(\n      this, instance, options, ctx, function(res){inner.importErrors(res);}\n      ))) {\n    var list = schema.anyOf.map(function (v, i) {\n      return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)){\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function(v, i){\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if(!valid.valid){\n      var msg = (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n      result.addError({\n        name: 'allOf',\n        argument: { id: msg, length: valid.errors.length, valid: valid },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)){\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(\n    testSchema.bind(\n      this, instance, options, ctx, function(res) {inner.importErrors(res);}\n      ) ).length;\n  var list = schema.oneOf.map(function (v, i) {\n    return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n  });\n  if (count!==1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n  if(instance === undefined || !(instance instanceof Object)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, properties[property], options, ctx);\n    }\n\n    var prop = (instance || undefined) && instance[property];\n    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"additionalProperty \" + JSON.stringify(property) + \" exists in instance when not allowed\",\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n  if(instance === undefined) return;\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var expr = new RegExp(pattern);\n      if (!expr.test(property)) {\n        continue;\n      }\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, patternProperties[pattern], options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));\n      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n  if(instance === undefined) return;\n  if(!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties,\n    })\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var self = this;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined || !schema.items) {\n    return result;\n  }\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\",\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = true;\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    valid = instance > schema.minimum;\n  } else {\n    valid = instance >= schema.minimum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'minimum',\n      argument: schema.minimum,\n      message: \"must have a minimum value of \" + schema.minimum,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid;\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    valid = instance < schema.maximum;\n  } else {\n    valid = instance <= schema.maximum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'maximum',\n      argument: schema.maximum,\n      message: \"must have a maximum value of \" + schema.maximum,\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n\n  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument:  validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatability with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (instance && typeof instance==='object' && Array.isArray(schema.required)) {\n    schema.required.forEach(function(n){\n      if(instance[n]===undefined){\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n),\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n  if (typeof instance !== 'string') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.match(schema.pattern)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates that every item in an instance array is unique, when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(instance)) {\n    return result;\n  }\n  function testArrays (v, i, a) {\n    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n    return true;\n  }\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays (v, i, a) {\n  var j, len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n  if (!instance || typeof instance != 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if(result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath,\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const'],\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n  var self = this;\n  if(instance===undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if(!notTypes) return null;\n  if(!Array.isArray(notTypes)) notTypes=[notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var schemaId = type && type.id && ('<' + type.id + '>') || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId,\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;\n"]},"metadata":{},"sourceType":"script"}