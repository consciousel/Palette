{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sendTronOffchainTransaction = void 0;\n\nconst tatum_1 = require(\"../connector/tatum\");\n\nconst constants_1 = require(\"../constants\");\n\nconst ledger_1 = require(\"../ledger\");\n\nconst request_1 = require(\"../model/request\");\n\nconst transaction_1 = require(\"../transaction\");\n\nconst wallet_1 = require(\"../wallet\");\n\nconst common_1 = require(\"./common\");\n\nconst kms_1 = require(\"./kms\");\n/**\n * Send Tron transaction from Tatum Ledger account to the blockchain. This method broadcasts signed transaction to the blockchain.\n * This operation is irreversible.\n * @param testnet mainnet or testnet version\n * @param body content of the transaction to broadcast\n * @returns transaction id of the transaction in the blockchain or id of the withdrawal, if it was not cancelled automatically\n */\n\n\nconst sendTronOffchainTransaction = async (testnet, body) => {\n  if (body.signatureId) {\n    return kms_1.offchainTransferTronKMS(body);\n  }\n\n  await tatum_1.validateBody(body, request_1.TransferTrxOffchain);\n\n  const {\n    mnemonic,\n    index,\n    fromPrivateKey\n  } = body,\n        withdrawal = __rest(body, [\"mnemonic\", \"index\", \"fromPrivateKey\"]);\n\n  const {\n    amount,\n    address\n  } = withdrawal;\n  let fromPriv;\n\n  if (mnemonic && index !== undefined) {\n    fromPriv = mnemonic && index ? await wallet_1.generatePrivateKeyFromMnemonic(request_1.Currency.TRON, testnet, mnemonic, index) : fromPrivateKey;\n  } else if (fromPrivateKey) {\n    fromPriv = fromPrivateKey;\n  } else {\n    throw new Error('No mnemonic or private key is present.');\n  }\n\n  withdrawal.fee = withdrawal.fee || '2.5';\n  const account = await ledger_1.getAccountById(withdrawal.senderAccountId);\n  let txData;\n\n  if (account.currency === request_1.Currency.TRON) {\n    txData = await transaction_1.prepareTronSignedTransaction(testnet, {\n      amount,\n      fromPrivateKey: fromPriv,\n      to: address\n    });\n  } else if (account.currency === request_1.Currency.USDT_TRON || account.currency === request_1.Currency.INRT_TRON) {\n    txData = await transaction_1.prepareTronTrc20SignedTransaction(testnet, {\n      amount,\n      fromPrivateKey: fromPriv,\n      to: address,\n      tokenAddress: constants_1.CONTRACT_ADDRESSES[account.currency],\n      feeLimit: parseFloat(withdrawal.fee)\n    });\n  } else {\n    const vc = await ledger_1.getVirtualCurrencyByName(account.currency);\n\n    if (vc.trcType === request_1.TrcType.TRC10) {\n      txData = await transaction_1.prepareTronTrc10SignedTransaction(testnet, {\n        amount,\n        fromPrivateKey: fromPriv,\n        to: address,\n        tokenId: vc.erc20Address\n      }, vc.precision);\n    } else if (vc.trcType === request_1.TrcType.TRC20) {\n      txData = await transaction_1.prepareTronTrc20SignedTransaction(testnet, {\n        amount,\n        feeLimit: parseFloat(withdrawal.fee),\n        fromPrivateKey: fromPriv,\n        to: address,\n        tokenAddress: vc.erc20Address\n      });\n    } else {\n      throw new Error('Unsupported account.');\n    }\n  }\n\n  const {\n    id\n  } = await common_1.offchainStoreWithdrawal(withdrawal);\n\n  try {\n    return Object.assign(Object.assign({}, await common_1.offchainBroadcast({\n      txData,\n      withdrawalId: id,\n      currency: request_1.Currency.TRON\n    })), {\n      id\n    });\n  } catch (e) {\n    console.error(e);\n\n    try {\n      await common_1.offchainCancelWithdrawal(id);\n    } catch (e1) {\n      console.log(e);\n      return {\n        id\n      };\n    }\n  }\n};\n\nexports.sendTronOffchainTransaction = sendTronOffchainTransaction;","map":{"version":3,"mappings":"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","names":["sendTronOffchainTransaction","testnet","body","signatureId","kms_1","tatum_1","request_1","mnemonic","index","fromPrivateKey","withdrawal","amount","address","fromPriv","undefined","wallet_1","TRON","Error","fee","account","ledger_1","senderAccountId","txData","currency","transaction_1","to","USDT_TRON","INRT_TRON","tokenAddress","constants_1","feeLimit","parseFloat","vc","trcType","TRC10","tokenId","erc20Address","precision","TRC20","id","common_1","withdrawalId","e","console","error","e1","log","exports"],"sourceRoot":"","sources":["../../../src/offchain/tron.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}