{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\n\nconst utils_1 = require(\"../../utils\");\n\nconst types_1 = require(\"./types\");\n\nclass OptionType extends types_1.Type {\n  constructor(typeParameter) {\n    super(\"Option\", [typeParameter]);\n  }\n\n  isAssignableFrom(type) {\n    if (!(type instanceof OptionType)) {\n      return false;\n    }\n\n    let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n    let fakeCovarianceToNull = type.getFirstTypeParameter() instanceof types_1.NullType;\n    return invariantTypeParameters || fakeCovarianceToNull;\n  }\n\n}\n\nexports.OptionType = OptionType;\n\nclass ListType extends types_1.Type {\n  constructor(typeParameter) {\n    super(\"List\", [typeParameter]);\n  }\n\n}\n\nexports.ListType = ListType;\n\nclass OptionValue extends types_1.TypedValue {\n  constructor(type) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(type); // TODO: assert value is of type type.getFirstTypeParameter()\n\n    this.value = value;\n  }\n  /**\n   * Creates an OptionValue, as a missing option argument.\n   */\n\n\n  static newMissing() {\n    let type = new OptionType(new types_1.NullType());\n    return new OptionValue(type);\n  }\n\n  static newMissingType(type) {\n    return new OptionValue(new OptionType(type));\n  }\n  /**\n   * Creates an OptionValue, as a provided option argument.\n   */\n\n\n  static newProvided(typedValue) {\n    let type = new OptionType(typedValue.getType());\n    return new OptionValue(type, typedValue);\n  }\n\n  isSet() {\n    return this.value ? true : false;\n  }\n\n  getTypedValue() {\n    utils_1.guardValueIsSet(\"value\", this.value);\n    return this.value;\n  }\n\n  valueOf() {\n    return this.value ? this.value.valueOf() : null;\n  }\n\n  equals(other) {\n    var _a;\n\n    return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n  }\n\n}\n\nexports.OptionValue = OptionValue; // TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\n\nclass List extends types_1.TypedValue {\n  /**\n   *\n   * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n   * @param items the items, having the type type.getFirstTypeParameter()\n   */\n  constructor(type, items) {\n    super(type); // TODO: assert items are of type type.getFirstTypeParameter()\n\n    this.items = items;\n  }\n\n  static fromItems(items) {\n    if (items.length == 0) {\n      return new List(new types_1.TypePlaceholder(), []);\n    }\n\n    let typeParameter = items[0].getType();\n    return new List(typeParameter, items);\n  }\n\n  getLength() {\n    return this.items.length;\n  }\n\n  getItems() {\n    return this.items;\n  }\n\n  valueOf() {\n    return this.items.map(item => item.valueOf());\n  }\n\n  equals(other) {\n    if (this.getLength() != other.getLength()) {\n      return false;\n    }\n\n    for (let i = 0; i < this.getLength(); i++) {\n      let selfItem = this.items[i];\n      let otherItem = other.items[i];\n\n      if (!selfItem.equals(otherItem)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexports.List = List;","map":{"version":3,"mappings":"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","names":["OptionType","types_1","constructor","typeParameter","isAssignableFrom","type","invariantTypeParameters","getFirstTypeParameter","equals","fakeCovarianceToNull","exports","ListType","OptionValue","value","newMissing","newMissingType","newProvided","typedValue","getType","isSet","getTypedValue","utils_1","valueOf","other","_a","List","items","fromItems","length","getLength","getItems","map","item","i","selfItem","otherItem"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/generic.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}