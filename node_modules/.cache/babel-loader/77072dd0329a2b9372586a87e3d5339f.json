{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FormattedCall = exports.formatEndpoint = void 0;\n\nconst __1 = require(\"..\");\n/**\n * Creates a FormattedCall from the given endpoint and args.\n */\n\n\nfunction formatEndpoint(executingEndpoint, interpretingEndpoint) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  return new FormattedCall(executingEndpoint, interpretingEndpoint, args);\n}\n\nexports.formatEndpoint = formatEndpoint;\n/**\n * Formats and validates the arguments of a bound call.\n * A bound call is represented by a function and its arguments packed together.\n * A function is defined as something that has an EndpointDefinition and may be:\n * - a smart contract method\n * - a built-in function (such as an ESDT transfer)\n */\n\nclass FormattedCall {\n  constructor(executingEndpoint, interpretingEndpoint, args) {\n    this.executingEndpoint = executingEndpoint;\n    this.interpretingEndpoint = interpretingEndpoint;\n    this.args = args;\n  }\n\n  getExecutingFunction() {\n    return new __1.ContractFunction(this.executingEndpoint.name);\n  }\n\n  getInterpretingFunction() {\n    return new __1.ContractFunction(this.interpretingEndpoint.name);\n  }\n  /**\n   * Takes the given arguments, and converts them to typed values, validating them against the given endpoint in the process.\n   */\n\n\n  toTypedValues() {\n    let expandedArgs = this.getExpandedArgs();\n    return __1.NativeSerializer.nativeToTypedValues(expandedArgs, this.executingEndpoint);\n  }\n\n  toArgBuffers() {\n    let typedValues = this.toTypedValues();\n    return new __1.ArgSerializer().valuesToBuffers(typedValues);\n  }\n  /**\n   * Formats the function name and its arguments as an array of buffers.\n   * This is useful for nested calls (for the multisig smart contract or for ESDT transfers).\n   * A formatted deploy call does not return the function name.\n   */\n\n\n  toCallBuffers() {\n    if (this.executingEndpoint.isConstructor()) {\n      return this.toArgBuffers();\n    }\n\n    return [Buffer.from(this.executingEndpoint.name), ...this.toArgBuffers()];\n  }\n\n  getExpandedArgs() {\n    let expanded = [];\n\n    for (let value of this.args) {\n      if (value instanceof FormattedCall) {\n        expanded = expanded.concat(value.toCallBuffers());\n      } else {\n        expanded.push(value);\n      }\n    }\n\n    return expanded;\n  }\n\n}\n\nexports.FormattedCall = FormattedCall;","map":{"version":3,"mappings":";;;;;;;AAAA;AAEA;;;;;AAGA,SAAgBA,cAAhB,CAA+BC,iBAA/B,EAAsEC,oBAAtE,EAA8H;AAAA,oCAAXC,IAAW;AAAXA,QAAW;AAAA;;AAC1H,SAAO,IAAIC,aAAJ,CAAkBH,iBAAlB,EAAqCC,oBAArC,EAA2DC,IAA3D,CAAP;AACH;;AAFDE;AAIA;;;;;;;;AAOA,MAAaD,aAAb,CAA0B;AAKtBE,cAAYL,iBAAZ,EAAmDC,oBAAnD,EAA6FC,IAA7F,EAAwG;AACpG,SAAKF,iBAAL,GAAyBA,iBAAzB;AACA,SAAKC,oBAAL,GAA4BA,oBAA5B;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACH;;AAEDI,sBAAoB;AAChB,WAAO,IAAIC,oBAAJ,CAAqB,KAAKP,iBAAL,CAAuBQ,IAA5C,CAAP;AACH;;AAEDC,yBAAuB;AACnB,WAAO,IAAIF,oBAAJ,CAAqB,KAAKN,oBAAL,CAA0BO,IAA/C,CAAP;AACH;AAED;;;;;AAGAE,eAAa;AACT,QAAIC,YAAY,GAAG,KAAKC,eAAL,EAAnB;AACA,WAAOL,qBAAiBM,mBAAjB,CAAqCF,YAArC,EAAmD,KAAKX,iBAAxD,CAAP;AACH;;AAEDc,cAAY;AACR,QAAIC,WAAW,GAAG,KAAKL,aAAL,EAAlB;AACA,WAAO,IAAIH,iBAAJ,GAAoBS,eAApB,CAAoCD,WAApC,CAAP;AACH;AAED;;;;;;;AAKAE,eAAa;AACT,QAAI,KAAKjB,iBAAL,CAAuBkB,aAAvB,EAAJ,EAA4C;AACxC,aAAO,KAAKJ,YAAL,EAAP;AACH;;AACD,WAAO,CAACK,MAAM,CAACC,IAAP,CAAY,KAAKpB,iBAAL,CAAuBQ,IAAnC,CAAD,EAA2C,GAAG,KAAKM,YAAL,EAA9C,CAAP;AACH;;AAEOF,iBAAe;AACnB,QAAIS,QAAQ,GAAU,EAAtB;;AACA,SAAK,IAAIC,KAAT,IAAkB,KAAKpB,IAAvB,EAA6B;AACzB,UAAIoB,KAAK,YAAYnB,aAArB,EAAoC;AAChCkB,gBAAQ,GAAGA,QAAQ,CAACE,MAAT,CAAgBD,KAAK,CAACL,aAAN,EAAhB,CAAX;AACH,OAFD,MAEO;AACHI,gBAAQ,CAACG,IAAT,CAAcF,KAAd;AACH;AACJ;;AACD,WAAOD,QAAP;AACH;;AAtDqB;;AAA1BjB","names":["formatEndpoint","executingEndpoint","interpretingEndpoint","args","FormattedCall","exports","constructor","getExecutingFunction","__1","name","getInterpretingFunction","toTypedValues","expandedArgs","getExpandedArgs","nativeToTypedValues","toArgBuffers","typedValues","valuesToBuffers","toCallBuffers","isConstructor","Buffer","from","expanded","value","concat","push"],"sourceRoot":"","sources":["../../../src/smartcontracts/wrapper/formattedCall.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}