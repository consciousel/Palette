{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport Web3 from \"web3\";\nimport web3CoreSubscriptions from \"web3-core-subscriptions\";\nimport { decodeParameter } from \"web3-eth-abi\";\nimport { toHex } from \"web3-utils\";\nimport { formatBlock } from \"./util/hex\";\nimport { callWhenDone } from \"./util/promises\";\nimport { makeAlchemyContext } from \"./web3-adapter/alchemyContext\";\nimport { patchEnableCustomRPC } from \"./web3-adapter/customRPC\";\nimport { patchEthMaxPriorityFeePerGasMethod } from \"./web3-adapter/eth_maxPriorityFeePerGas\";\nexport * from \"./alchemy-apis/types\";\nvar DEFAULT_MAX_RETRIES = 3;\nvar DEFAULT_RETRY_INTERVAL = 1000;\nvar DEFAULT_RETRY_JITTER = 250;\nvar DEFAULT_CONTRACT_ADDRESS = \"DEFAULT_TOKENS\";\nexport function createAlchemyWeb3(alchemyUrl, config) {\n  var fullConfig = fillInConfigDefaults(config);\n\n  var _a = makeAlchemyContext(alchemyUrl, fullConfig),\n      provider = _a.provider,\n      jsonRpcSenders = _a.jsonRpcSenders,\n      restSender = _a.restSender,\n      setWriteProvider = _a.setWriteProvider;\n\n  var alchemyWeb3 = new Web3(provider);\n\n  alchemyWeb3.setProvider = function () {\n    throw new Error(\"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\");\n  };\n\n  alchemyWeb3.setWriteProvider = setWriteProvider;\n\n  function getNfts(params, callback) {\n    return callAlchemyRestEndpoint({\n      restSender: restSender,\n      callback: callback,\n      params: params,\n      path: \"/v1/getNFTs/\"\n    });\n  }\n\n  alchemyWeb3.alchemy = {\n    getTokenAllowance: function (params, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        method: \"alchemy_getTokenAllowance\",\n        params: [params]\n      });\n    },\n    getTokenBalances: function (address, contractAddresses, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        method: \"alchemy_getTokenBalances\",\n        params: [address, contractAddresses || DEFAULT_CONTRACT_ADDRESS],\n        processResponse: processTokenBalanceResponse\n      });\n    },\n    getTokenMetadata: function (address, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        params: [address],\n        method: \"alchemy_getTokenMetadata\"\n      });\n    },\n    getAssetTransfers: function (params, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        params: [__assign(__assign({}, params), {\n          fromBlock: params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n          toBlock: params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n          maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n        })],\n        method: \"alchemy_getAssetTransfers\"\n      });\n    },\n    getNftMetadata: function (params, callback) {\n      return callAlchemyRestEndpoint({\n        restSender: restSender,\n        callback: callback,\n        params: params,\n        path: \"/v1/getNFTMetadata/\"\n      });\n    },\n    getNfts: getNfts,\n    getTransactionReceipts: function (params, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        method: \"alchemy_getTransactionReceipts\",\n        params: [params]\n      });\n    }\n  };\n  patchSubscriptions(alchemyWeb3);\n  patchEnableCustomRPC(alchemyWeb3);\n  patchEthMaxPriorityFeePerGasMethod(alchemyWeb3);\n  return alchemyWeb3;\n}\n\nfunction fillInConfigDefaults(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.writeProvider,\n      writeProvider = _c === void 0 ? getWindowProvider() : _c,\n      _d = _b.maxRetries,\n      maxRetries = _d === void 0 ? DEFAULT_MAX_RETRIES : _d,\n      _e = _b.retryInterval,\n      retryInterval = _e === void 0 ? DEFAULT_RETRY_INTERVAL : _e,\n      _f = _b.retryJitter,\n      retryJitter = _f === void 0 ? DEFAULT_RETRY_JITTER : _f;\n\n  return {\n    writeProvider: writeProvider,\n    maxRetries: maxRetries,\n    retryInterval: retryInterval,\n    retryJitter: retryJitter\n  };\n}\n\nfunction getWindowProvider() {\n  return typeof window !== \"undefined\" ? window.ethereum : null;\n}\n\nfunction callAlchemyJsonRpcMethod(_a) {\n  var _this = this;\n\n  var jsonRpcSenders = _a.jsonRpcSenders,\n      method = _a.method,\n      params = _a.params,\n      _b = _a.callback,\n      callback = _b === void 0 ? noop : _b,\n      _c = _a.processResponse,\n      processResponse = _c === void 0 ? identity : _c;\n\n  var promise = function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , jsonRpcSenders.send(method, params)];\n\n          case 1:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , processResponse(result)];\n        }\n      });\n    });\n  }();\n\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction callAlchemyRestEndpoint(_a) {\n  var _this = this;\n\n  var restSender = _a.restSender,\n      path = _a.path,\n      params = _a.params,\n      _b = _a.callback,\n      callback = _b === void 0 ? noop : _b,\n      _c = _a.processResponse,\n      processResponse = _c === void 0 ? identity : _c;\n  var fixedParams = fixArrayQueryParams(params);\n\n  var promise = function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , restSender.sendRestPayload(path, fixedParams)];\n\n          case 1:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , processResponse(result)];\n        }\n      });\n    });\n  }();\n\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction processTokenBalanceResponse(rawResponse) {\n  // Convert token balance fields from hex-string to decimal-string.\n  var fixedTokenBalances = rawResponse.tokenBalances.map(function (balance) {\n    return balance.tokenBalance != null ? __assign(__assign({}, balance), {\n      tokenBalance: decodeParameter(\"uint256\", balance.tokenBalance)\n    }) : balance;\n  });\n  return __assign(__assign({}, rawResponse), {\n    tokenBalances: fixedTokenBalances\n  });\n}\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions. This is to handle alternate namings of the existing\n * subscription endpoints, but the officially documented interfaces are\n * specified in the AlchemyEth interface.\n */\n\n\nfunction patchSubscriptions(web3) {\n  var eth = web3.eth;\n  var oldSubscribe = eth.subscribe.bind(eth);\n\n  eth.subscribe = function (type) {\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    if (type === \"alchemy_fullPendingTransactions\" || type === \"alchemy_newFullPendingTransactions\") {\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_newFullPendingTransactions\"], __read(rest)));\n      });\n    }\n\n    if (type === \"alchemy_filteredNewFullPendingTransactions\" || type === \"alchemy_filteredPendingTransactions\" || type === \"alchemy_filteredFullPendingTransactions\") {\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_filteredNewFullPendingTransactions\"], __read(rest)));\n      });\n    }\n\n    return oldSubscribe.apply(void 0, __spreadArray([type], __read(rest)));\n  };\n}\n/**\n * VERY hacky wrapper to suppress a spurious warning when subscribing to an\n * Alchemy subscription that isn't built into Web3.\n */\n\n\nfunction suppressNoSubscriptionExistsWarning(f) {\n  var oldConsoleWarn = console.warn;\n\n  console.warn = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (typeof args[0] === \"string\" && args[0].includes(\" doesn't exist. Subscribing anyway.\")) {\n      return;\n    }\n\n    return oldConsoleWarn.apply(console, args);\n  };\n\n  try {\n    return f();\n  } finally {\n    console.warn = oldConsoleWarn;\n  }\n}\n/**\n * Another VERY hacky monkeypatch to make sure that we can take extra parameters to certain alchemy subscriptions\n * I hate doing this, but the other option is to fork web3-core and I think for now this is better\n */\n\n\nvar subscription = web3CoreSubscriptions.subscription;\nvar oldSubscriptionPrototypeValidateArgs = subscription.prototype._validateArgs;\n\nsubscription.prototype._validateArgs = function (args) {\n  if ([\"alchemy_filteredNewFullPendingTransactions\", \"alchemy_filteredPendingTransactions\", \"alchemy_filteredFullPendingTransactions\"].includes(this.subscriptionMethod)) {// This particular subscription type is allowed to have additional parameters\n  } else {\n    if ([\"alchemy_fullPendingTransactions\", \"alchemy_newFullPendingTransactions\"].includes(this.subscriptionMethod)) {\n      if (this.options.subscription) {\n        this.options.subscription.subscriptionName = this.subscriptionMethod;\n      }\n    }\n\n    var validator = oldSubscriptionPrototypeValidateArgs.bind(this);\n    validator(args);\n  }\n};\n\nfunction noop() {// Nothing.\n}\n\nfunction identity(x) {\n  return x;\n}\n/**\n * Alchemy's APIs receive multivalued params via keys with `[]` at the end.\n * Update any query params whose values are arrays to match this convention.\n */\n\n\nfunction fixArrayQueryParams(params) {\n  var result = {};\n  Object.keys(params).forEach(function (key) {\n    var value = params[key];\n    var fixedKey = Array.isArray(value) ? toArrayKey(key) : key;\n    result[fixedKey] = value;\n  });\n  return result;\n}\n\nfunction toArrayKey(key) {\n  return endsWith(key, \"[]\") ? key : key + \"[]\";\n}\n/**\n * Like `String#endsWith`, for older environments.\n */\n\n\nfunction endsWith(s, ending) {\n  var index = s.lastIndexOf(ending);\n  return index >= 0 && index === s.length - ending.length;\n}","map":{"version":3,"mappings":"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","names":["Web3","web3CoreSubscriptions","decodeParameter","toHex","formatBlock","callWhenDone","makeAlchemyContext","patchEnableCustomRPC","patchEthMaxPriorityFeePerGasMethod","DEFAULT_MAX_RETRIES","DEFAULT_RETRY_INTERVAL","DEFAULT_RETRY_JITTER","DEFAULT_CONTRACT_ADDRESS","createAlchemyWeb3","alchemyUrl","config","fullConfig","fillInConfigDefaults","provider","jsonRpcSenders","restSender","setWriteProvider","alchemyWeb3","setProvider","Error","getNfts","params","callback","callAlchemyRestEndpoint","path","alchemy","getTokenAllowance","method","getTokenBalances","address","contractAddresses","processResponse","processTokenBalanceResponse","getTokenMetadata","getAssetTransfers","fromBlock","undefined","toBlock","maxCount","getNftMetadata","getTransactionReceipts","patchSubscriptions","_a","_b","_c","writeProvider","getWindowProvider","_d","maxRetries","_e","retryInterval","_f","retryJitter","window","ethereum","callAlchemyJsonRpcMethod","noop","identity","promise","send","result","fixedParams","fixArrayQueryParams","sendRestPayload","rawResponse","fixedTokenBalances","tokenBalances","map","balance","tokenBalance","__assign","web3","oldSubscribe","eth","subscribe","bind","type","rest","suppressNoSubscriptionExistsWarning","__spreadArray","__read","f","oldConsoleWarn","console","warn","args","includes","apply","oldSubscriptionPrototypeValidateArgs","subscription","prototype","_validateArgs","subscriptionMethod","options","subscriptionName","validator","x","Object","keys","forEach","key","value","fixedKey","Array","isArray","toArrayKey","endsWith","s","ending","index","lastIndexOf","length"],"sourceRoot":"","sources":["../../src/index.ts"],"sourcesContent":["import Web3 from \"web3\";\nimport { Log, LogsOptions, Transaction } from \"web3-core\";\nimport web3CoreSubscriptions, { Subscription } from \"web3-core-subscriptions\";\nimport { BlockHeader, Eth, Syncing } from \"web3-eth\";\nimport { decodeParameter } from \"web3-eth-abi\";\nimport { toHex } from \"web3-utils\";\nimport {\n  AssetTransfersParams,\n  AssetTransfersResponse,\n  GetNftMetadataParams,\n  GetNftMetadataResponse,\n  GetNftsParams,\n  GetNftsParamsWithoutMetadata,\n  GetNftsResponse,\n  GetNftsResponseWithoutMetadata,\n  TokenAllowanceParams,\n  TokenAllowanceResponse,\n  TokenBalancesResponse,\n  TokenMetadataResponse,\n  TransactionReceiptsParams,\n  TransactionReceiptsResponse,\n} from \"./alchemy-apis/types\";\nimport {\n  AlchemyWeb3Config,\n  FullConfig,\n  Provider,\n  TransactionsOptions,\n  Web3Callback,\n} from \"./types\";\nimport { formatBlock } from \"./util/hex\";\nimport { JsonRpcSenders } from \"./util/jsonRpc\";\nimport { callWhenDone } from \"./util/promises\";\nimport { makeAlchemyContext } from \"./web3-adapter/alchemyContext\";\nimport { patchEnableCustomRPC } from \"./web3-adapter/customRPC\";\nimport { patchEthMaxPriorityFeePerGasMethod } from \"./web3-adapter/eth_maxPriorityFeePerGas\";\nimport { RestPayloadSender } from \"./web3-adapter/sendRestPayload\";\n\nexport * from \"./alchemy-apis/types\";\n\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_RETRY_INTERVAL = 1000;\nconst DEFAULT_RETRY_JITTER = 250;\nconst DEFAULT_CONTRACT_ADDRESS = \"DEFAULT_TOKENS\";\n\nexport interface AlchemyWeb3 extends Web3 {\n  alchemy: AlchemyMethods;\n  eth: AlchemyEth;\n  setWriteProvider(provider: Provider | null | undefined): void;\n}\n\nexport interface AlchemyMethods {\n  getTokenAllowance(\n    params: TokenAllowanceParams,\n    callback?: Web3Callback<TokenAllowanceResponse>,\n  ): Promise<TokenAllowanceResponse>;\n  getTokenBalances(\n    address: string,\n    contractAddresses?: string[],\n    callback?: Web3Callback<TokenBalancesResponse>,\n  ): Promise<TokenBalancesResponse>;\n  getTokenMetadata(\n    address: string,\n    callback?: Web3Callback<TokenMetadataResponse>,\n  ): Promise<TokenMetadataResponse>;\n  getAssetTransfers(\n    params: AssetTransfersParams,\n    callback?: Web3Callback<AssetTransfersResponse>,\n  ): Promise<AssetTransfersResponse>;\n  getNftMetadata(\n    params: GetNftMetadataParams,\n    callback?: Web3Callback<GetNftMetadataResponse>,\n  ): Promise<GetNftMetadataResponse>;\n  getNfts(\n    params: GetNftsParamsWithoutMetadata,\n    callback?: Web3Callback<GetNftsResponseWithoutMetadata>,\n  ): Promise<GetNftsResponseWithoutMetadata>;\n  getNfts(\n    params: GetNftsParams,\n    callback?: Web3Callback<GetNftsResponse>,\n  ): Promise<GetNftsResponse>;\n  getTransactionReceipts(\n    params: TransactionReceiptsParams,\n    callback?: Web3Callback<TransactionReceiptsResponse>,\n  ): Promise<TransactionReceiptsResponse>;\n}\n\n/**\n * Same as Eth, but with `subscribe` allowing more types.\n */\nexport interface AlchemyEth extends Eth {\n  subscribe(\n    type: \"logs\",\n    options?: LogsOptions,\n    callback?: (error: Error, log: Log) => void,\n  ): Subscription<Log>;\n  subscribe(\n    type: \"syncing\",\n    callback?: (error: Error, result: Syncing) => void,\n  ): Subscription<Syncing>;\n  subscribe(\n    type: \"newBlockHeaders\",\n    callback?: (error: Error, blockHeader: BlockHeader) => void,\n  ): Subscription<BlockHeader>;\n  subscribe(\n    type: \"pendingTransactions\",\n    callback?: (error: Error, transactionHash: string) => void,\n  ): Subscription<string>;\n  subscribe(\n    type: \"alchemy_fullPendingTransactions\",\n    callback?: (error: Error, transaction: Transaction) => void,\n  ): Subscription<Transaction>;\n  subscribe(\n    type: \"alchemy_filteredFullPendingTransactions\",\n    options?: TransactionsOptions,\n    callback?: (error: Error, transaction: Transaction) => void,\n  ): Subscription<Transaction>;\n  subscribe(\n    type:\n      | \"pendingTransactions\"\n      | \"logs\"\n      | \"syncing\"\n      | \"newBlockHeaders\"\n      | \"alchemy_fullPendingTransactions\"\n      | \"alchemy_filteredFullPendingTransactions\",\n    options?: null | LogsOptions | TransactionsOptions,\n    callback?: (\n      error: Error,\n      item: Log | Syncing | BlockHeader | string | Transaction,\n    ) => void,\n  ): Subscription<Log | BlockHeader | Syncing | string>;\n  getMaxPriorityFeePerGas(\n    callback?: (error: Error, fee: string) => void,\n  ): Promise<string>;\n}\n\ninterface EthereumWindow extends Window {\n  ethereum?: any;\n}\n\ndeclare const window: EthereumWindow;\n\nexport function createAlchemyWeb3(\n  alchemyUrl: string,\n  config?: AlchemyWeb3Config,\n): AlchemyWeb3 {\n  const fullConfig = fillInConfigDefaults(config);\n  const { provider, jsonRpcSenders, restSender, setWriteProvider } =\n    makeAlchemyContext(alchemyUrl, fullConfig);\n  const alchemyWeb3 = new Web3(provider) as AlchemyWeb3;\n  alchemyWeb3.setProvider = () => {\n    throw new Error(\n      \"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\",\n    );\n  };\n  alchemyWeb3.setWriteProvider = setWriteProvider;\n\n  // Define function separately in order to allow for overloads.\n  function getNfts(\n    params: GetNftsParamsWithoutMetadata,\n    callback?: Web3Callback<GetNftsResponseWithoutMetadata>,\n  ): Promise<GetNftsResponseWithoutMetadata>;\n  function getNfts(\n    params: GetNftsParams,\n    callback?: Web3Callback<GetNftsResponse>,\n  ): Promise<GetNftsResponse>;\n  function getNfts(\n    params: GetNftsParams | GetNftsParamsWithoutMetadata,\n    callback?:\n      | Web3Callback<GetNftsResponseWithoutMetadata>\n      | Web3Callback<GetNftsResponse>,\n  ): Promise<GetNftsResponse | GetNftsResponseWithoutMetadata> {\n    return callAlchemyRestEndpoint({\n      restSender,\n      callback,\n      params,\n      path: \"/v1/getNFTs/\",\n    });\n  }\n\n  alchemyWeb3.alchemy = {\n    getTokenAllowance: (params: TokenAllowanceParams, callback) =>\n      callAlchemyJsonRpcMethod({\n        jsonRpcSenders,\n        callback,\n        method: \"alchemy_getTokenAllowance\",\n        params: [params],\n      }),\n    getTokenBalances: (address, contractAddresses, callback) =>\n      callAlchemyJsonRpcMethod({\n        jsonRpcSenders,\n        callback,\n        method: \"alchemy_getTokenBalances\",\n        params: [address, contractAddresses || DEFAULT_CONTRACT_ADDRESS],\n        processResponse: processTokenBalanceResponse,\n      }),\n    getTokenMetadata: (address, callback) =>\n      callAlchemyJsonRpcMethod({\n        jsonRpcSenders,\n        callback,\n        params: [address],\n        method: \"alchemy_getTokenMetadata\",\n      }),\n    getAssetTransfers: (params: AssetTransfersParams, callback) =>\n      callAlchemyJsonRpcMethod({\n        jsonRpcSenders,\n        callback,\n        params: [\n          {\n            ...params,\n            fromBlock:\n              params.fromBlock != null\n                ? formatBlock(params.fromBlock)\n                : undefined,\n            toBlock:\n              params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n            maxCount:\n              params.maxCount != null ? toHex(params.maxCount) : undefined,\n          },\n        ],\n        method: \"alchemy_getAssetTransfers\",\n      }),\n    getNftMetadata: (params: GetNftMetadataParams, callback) =>\n      callAlchemyRestEndpoint({\n        restSender,\n        callback,\n        params,\n        path: \"/v1/getNFTMetadata/\",\n      }),\n    getNfts,\n    getTransactionReceipts: (params: TransactionReceiptsParams, callback) =>\n      callAlchemyJsonRpcMethod({\n        jsonRpcSenders,\n        callback,\n        method: \"alchemy_getTransactionReceipts\",\n        params: [params],\n      }),\n  };\n  patchSubscriptions(alchemyWeb3);\n  patchEnableCustomRPC(alchemyWeb3);\n  patchEthMaxPriorityFeePerGasMethod(alchemyWeb3);\n  return alchemyWeb3;\n}\n\nfunction fillInConfigDefaults({\n  writeProvider = getWindowProvider(),\n  maxRetries = DEFAULT_MAX_RETRIES,\n  retryInterval = DEFAULT_RETRY_INTERVAL,\n  retryJitter = DEFAULT_RETRY_JITTER,\n}: AlchemyWeb3Config = {}): FullConfig {\n  return { writeProvider, maxRetries, retryInterval, retryJitter };\n}\n\nfunction getWindowProvider(): Provider | null {\n  return typeof window !== \"undefined\" ? window.ethereum : null;\n}\n\ninterface CallAlchemyJsonRpcMethodParams<T> {\n  jsonRpcSenders: JsonRpcSenders;\n  method: string;\n  params: any[];\n  callback?: Web3Callback<T>;\n  processResponse?(response: any): T;\n}\n\ninterface CallAlchemyRestEndpoint<T> {\n  restSender: RestPayloadSender;\n  path: string;\n  params: Record<string, any>;\n  callback?: Web3Callback<T>;\n  processResponse?(response: any): T;\n}\n\nfunction callAlchemyJsonRpcMethod<T>({\n  jsonRpcSenders,\n  method,\n  params,\n  callback = noop,\n  processResponse = identity,\n}: CallAlchemyJsonRpcMethodParams<T>): Promise<T> {\n  const promise = (async () => {\n    const result = await jsonRpcSenders.send(method, params);\n    return processResponse(result);\n  })();\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction callAlchemyRestEndpoint<T>({\n  restSender,\n  path,\n  params,\n  callback = noop,\n  processResponse = identity,\n}: CallAlchemyRestEndpoint<T>): Promise<T> {\n  const fixedParams = fixArrayQueryParams(params);\n  const promise = (async () => {\n    const result = await restSender.sendRestPayload(path, fixedParams);\n    return processResponse(result);\n  })();\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction processTokenBalanceResponse(\n  rawResponse: TokenBalancesResponse,\n): TokenBalancesResponse {\n  // Convert token balance fields from hex-string to decimal-string.\n  const fixedTokenBalances = rawResponse.tokenBalances.map((balance) =>\n    balance.tokenBalance != null\n      ? {\n          ...balance,\n          tokenBalance: decodeParameter(\"uint256\", balance.tokenBalance),\n        }\n      : balance,\n  );\n  return { ...rawResponse, tokenBalances: fixedTokenBalances };\n}\n\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions. This is to handle alternate namings of the existing\n * subscription endpoints, but the officially documented interfaces are\n * specified in the AlchemyEth interface.\n */\nfunction patchSubscriptions(web3: Web3): void {\n  const { eth } = web3;\n  const oldSubscribe = eth.subscribe.bind(eth);\n  eth.subscribe = ((type: string, ...rest: any[]) => {\n    if (\n      type === \"alchemy_fullPendingTransactions\" ||\n      type === \"alchemy_newFullPendingTransactions\"\n    ) {\n      return suppressNoSubscriptionExistsWarning(() =>\n        oldSubscribe(\"alchemy_newFullPendingTransactions\" as any, ...rest),\n      );\n    }\n    if (\n      type === \"alchemy_filteredNewFullPendingTransactions\" ||\n      type === \"alchemy_filteredPendingTransactions\" ||\n      type === \"alchemy_filteredFullPendingTransactions\"\n    ) {\n      return suppressNoSubscriptionExistsWarning(() =>\n        oldSubscribe(\n          \"alchemy_filteredNewFullPendingTransactions\" as any,\n          ...rest,\n        ),\n      );\n    }\n    return oldSubscribe(type as any, ...rest);\n  }) as any;\n}\n\n/**\n * VERY hacky wrapper to suppress a spurious warning when subscribing to an\n * Alchemy subscription that isn't built into Web3.\n */\nfunction suppressNoSubscriptionExistsWarning<T>(f: () => T): T {\n  const oldConsoleWarn = console.warn;\n  console.warn = (...args: unknown[]) => {\n    if (\n      typeof args[0] === \"string\" &&\n      args[0].includes(\" doesn't exist. Subscribing anyway.\")\n    ) {\n      return;\n    }\n    return oldConsoleWarn.apply(console, args);\n  };\n  try {\n    return f();\n  } finally {\n    console.warn = oldConsoleWarn;\n  }\n}\n\n/**\n * Another VERY hacky monkeypatch to make sure that we can take extra parameters to certain alchemy subscriptions\n * I hate doing this, but the other option is to fork web3-core and I think for now this is better\n */\nconst { subscription } = web3CoreSubscriptions as any;\nconst oldSubscriptionPrototypeValidateArgs =\n  subscription.prototype._validateArgs;\nsubscription.prototype._validateArgs = function (args: any) {\n  if (\n    [\n      \"alchemy_filteredNewFullPendingTransactions\",\n      \"alchemy_filteredPendingTransactions\",\n      \"alchemy_filteredFullPendingTransactions\",\n    ].includes(this.subscriptionMethod)\n  ) {\n    // This particular subscription type is allowed to have additional parameters\n  } else {\n    if (\n      [\n        \"alchemy_fullPendingTransactions\",\n        \"alchemy_newFullPendingTransactions\",\n      ].includes(this.subscriptionMethod)\n    ) {\n      if (this.options.subscription) {\n        this.options.subscription.subscriptionName = this.subscriptionMethod;\n      }\n    }\n\n    const validator = oldSubscriptionPrototypeValidateArgs.bind(this);\n    validator(args);\n  }\n};\n\nfunction noop(): void {\n  // Nothing.\n}\n\nfunction identity<T>(x: T): T {\n  return x;\n}\n\n/**\n * Alchemy's APIs receive multivalued params via keys with `[]` at the end.\n * Update any query params whose values are arrays to match this convention.\n */\nfunction fixArrayQueryParams(params: Record<string, any>): Record<string, any> {\n  const result: Record<string, any> = {};\n  Object.keys(params).forEach((key) => {\n    const value = params[key];\n    const fixedKey = Array.isArray(value) ? toArrayKey(key) : key;\n    result[fixedKey] = value;\n  });\n  return result;\n}\n\nfunction toArrayKey(key: string): string {\n  return endsWith(key, \"[]\") ? key : `${key}[]`;\n}\n\n/**\n * Like `String#endsWith`, for older environments.\n */\nfunction endsWith(s: string, ending: string): boolean {\n  const index = s.lastIndexOf(ending);\n  return index >= 0 && index === s.length - ending.length;\n}\n"]},"metadata":{},"sourceType":"module"}