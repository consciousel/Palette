{"ast":null,"code":"const bip39 = require('bip39');\n\nconst {\n  validateBuffer,\n  validateDerivationIndex,\n  validateDerivationScheme,\n  validateMnemonic\n} = require(\"../utils/validation\");\n\nconst crypto = require(\"./crypto-primitives\");\n\nconst pbkdf2 = require('../utils/pbkdf2');\n\nconst Module = require('../lib.js');\n\nasync function mnemonicToRootKeypair(mnemonic, derivationScheme) {\n  validateDerivationScheme(derivationScheme);\n\n  if (derivationScheme === 1) {\n    return mnemonicToRootKeypairV1(mnemonic);\n  } else if (derivationScheme === 2) {\n    return mnemonicToRootKeypairV2(mnemonic, '');\n  } else {\n    throw Error(`Derivation scheme ${derivationScheme} not implemented`);\n  }\n}\n\nfunction mnemonicToRootKeypairV1(mnemonic) {\n  const seed = mnemonicToSeedV1(mnemonic);\n  return seedToKeypairV1(seed);\n}\n\nfunction mnemonicToSeedV1(mnemonic) {\n  validateMnemonic(mnemonic);\n  const entropy = Buffer.from(bip39.mnemonicToEntropy(mnemonic), 'hex');\n  return cborEncodeBuffer(crypto.blake2b(cborEncodeBuffer(entropy), 32));\n}\n\nfunction seedToKeypairV1(seed) {\n  let result;\n\n  for (let i = 1; result === undefined && i <= 1000; i++) {\n    try {\n      const digest = crypto.hmac_sha512(seed, [Buffer.from(`Root Seed Chain ${i}`, 'ascii')]);\n      const tempSeed = digest.slice(0, 32);\n      const chainCode = digest.slice(32, 64);\n      result = trySeedChainCodeToKeypairV1(tempSeed, chainCode);\n    } catch (e) {\n      if (e.name === 'InvalidKeypair') {\n        continue;\n      }\n\n      throw e;\n    }\n  }\n\n  if (result === undefined) {\n    const e = new Error('Secret key generation from mnemonic is looping forever');\n    e.name = 'RuntimeException';\n    throw e;\n  }\n\n  return result;\n}\n\nfunction trySeedChainCodeToKeypairV1(seed, chainCode) {\n  validateBuffer(seed, 32);\n  validateBuffer(chainCode, 32);\n\n  const seedArrPtr = Module._malloc(32);\n\n  const seedArr = new Uint8Array(Module.HEAPU8.buffer, seedArrPtr, 32);\n\n  const chainCodeArrPtr = Module._malloc(32);\n\n  const chainCodeArr = new Uint8Array(Module.HEAPU8.buffer, chainCodeArrPtr, 32);\n\n  const keypairArrPtr = Module._malloc(128);\n\n  const keypairArr = new Uint8Array(Module.HEAPU8.buffer, keypairArrPtr, 128);\n  seedArr.set(seed);\n  chainCodeArr.set(chainCode);\n\n  const returnCode = Module._emscripten_wallet_secret_from_seed(seedArrPtr, chainCodeArrPtr, keypairArrPtr);\n\n  Module._free(seedArrPtr);\n\n  Module._free(chainCodeArrPtr);\n\n  Module._free(keypairArrPtr);\n\n  if (returnCode === 1) {\n    const e = new Error('Invalid keypair');\n    e.name = 'InvalidKeypair';\n    throw e;\n  }\n\n  return Buffer.from(keypairArr);\n}\n\nasync function mnemonicToRootKeypairV2(mnemonic, password) {\n  const seed = mnemonicToSeedV2(mnemonic);\n  const rootSecret = await seedToKeypairV2(seed, password);\n  return seedToKeypairV2(seed, password);\n}\n\nfunction mnemonicToSeedV2(mnemonic) {\n  validateMnemonic(mnemonic);\n  return Buffer.from(bip39.mnemonicToEntropy(mnemonic), 'hex');\n}\n\nasync function seedToKeypairV2(seed, password) {\n  const xprv = await pbkdf2(password, seed, 4096, 96, 'sha512');\n  xprv[0] &= 248;\n  xprv[31] &= 31;\n  xprv[31] |= 64;\n  const publicKey = toPublic(xprv.slice(0, 64));\n  return Buffer.concat([xprv.slice(0, 64), publicKey, xprv.slice(64)]);\n}\n\nfunction toPublic(privateKey) {\n  validateBuffer(privateKey, 64);\n\n  const privateKeyArrPtr = Module._malloc(64);\n\n  const privateKeyArr = new Uint8Array(Module.HEAPU8.buffer, privateKeyArrPtr, 64);\n\n  const publicKeyArrPtr = Module._malloc(32);\n\n  const publicKeyArr = new Uint8Array(Module.HEAPU8.buffer, publicKeyArrPtr, 32);\n  privateKeyArr.set(privateKey);\n\n  Module._emscripten_to_public(privateKeyArrPtr, publicKeyArrPtr);\n\n  Module._free(privateKeyArrPtr);\n\n  Module._free(publicKeyArrPtr);\n\n  return Buffer.from(publicKeyArr);\n}\n\nfunction derivePrivate(parentKey, index, derivationScheme) {\n  validateBuffer(parentKey, 128);\n  validateDerivationIndex(index);\n  validateDerivationScheme(derivationScheme);\n\n  const parentKeyArrPtr = Module._malloc(128);\n\n  const parentKeyArr = new Uint8Array(Module.HEAPU8.buffer, parentKeyArrPtr, 128);\n\n  const childKeyArrPtr = Module._malloc(128);\n\n  const childKeyArr = new Uint8Array(Module.HEAPU8.buffer, childKeyArrPtr, 128);\n  parentKeyArr.set(parentKey);\n\n  Module._emscripten_derive_private(parentKeyArrPtr, index, childKeyArrPtr, derivationScheme);\n\n  Module._free(parentKeyArrPtr);\n\n  Module._free(childKeyArrPtr);\n\n  return Buffer.from(childKeyArr);\n}\n\nfunction derivePublic(parentExtPubKey, index, derivationScheme) {\n  validateBuffer(parentExtPubKey, 64);\n  validateDerivationIndex(index);\n  validateDerivationScheme(derivationScheme);\n  const parentPubKey = parentExtPubKey.slice(0, 32);\n  const parentChainCode = parentExtPubKey.slice(32, 64);\n\n  const parentPubKeyArrPtr = Module._malloc(32);\n\n  const parentPubKeyArr = new Uint8Array(Module.HEAPU8.buffer, parentPubKeyArrPtr, 32);\n\n  const parentChainCodeArrPtr = Module._malloc(32);\n\n  const parentChainCodeArr = new Uint8Array(Module.HEAPU8.buffer, parentChainCodeArrPtr, 32);\n\n  const childPubKeyArrPtr = Module._malloc(32);\n\n  const childPubKeyArr = new Uint8Array(Module.HEAPU8.buffer, childPubKeyArrPtr, 32);\n\n  const childChainCodeArrPtr = Module._malloc(32);\n\n  const childChainCodeArr = new Uint8Array(Module.HEAPU8.buffer, childChainCodeArrPtr, 32);\n  parentPubKeyArr.set(parentPubKey);\n  parentChainCodeArr.set(parentChainCode);\n\n  const resultCode = Module._emscripten_derive_public(parentPubKeyArrPtr, parentChainCodeArrPtr, index, childPubKeyArrPtr, childChainCodeArrPtr, derivationScheme);\n\n  Module._free(parentPubKeyArrPtr);\n\n  Module._free(parentChainCodeArrPtr);\n\n  Module._free(parentPubKeyArrPtr);\n\n  Module._free(parentChainCodeArrPtr);\n\n  if (resultCode !== 0) {\n    throw Error(`derivePublic has exited with code ${resultCode}`);\n  }\n\n  return Buffer.concat([Buffer.from(childPubKeyArr), Buffer.from(childChainCodeArr)]);\n}\n\nfunction cborEncodeBuffer(input) {\n  validateBuffer(input);\n  const len = input.length;\n  let cborPrefix = [];\n\n  if (len < 24) {\n    cborPrefix = [0x40 + len];\n  } else if (len < 256) {\n    cborPrefix = [0x58, len];\n  } else {\n    throw Error('CBOR encode for more than 256 bytes not yet implemented');\n  }\n\n  return Buffer.concat([Buffer.from(cborPrefix), input]);\n}\n\nmodule.exports = {\n  mnemonicToRootKeypair,\n  derivePublic,\n  derivePrivate,\n  toPublic,\n  _mnemonicToSeedV1: mnemonicToSeedV1,\n  _seedToKeypairV1: seedToKeypairV1,\n  _seedToKeypairV2: seedToKeypairV2,\n  _mnemonicToSeedV2: mnemonicToSeedV2\n};","map":{"version":3,"sources":["C:/Users/masho/OneDrive/Desktop/Blockchain/Biconomy/Projects/NFT_minter/node_modules/cardano-crypto.js/features/key-derivation.js"],"names":["bip39","require","validateBuffer","validateDerivationIndex","validateDerivationScheme","validateMnemonic","crypto","pbkdf2","Module","mnemonicToRootKeypair","mnemonic","derivationScheme","mnemonicToRootKeypairV1","mnemonicToRootKeypairV2","Error","seed","mnemonicToSeedV1","seedToKeypairV1","entropy","Buffer","from","mnemonicToEntropy","cborEncodeBuffer","blake2b","result","i","undefined","digest","hmac_sha512","tempSeed","slice","chainCode","trySeedChainCodeToKeypairV1","e","name","seedArrPtr","_malloc","seedArr","Uint8Array","HEAPU8","buffer","chainCodeArrPtr","chainCodeArr","keypairArrPtr","keypairArr","set","returnCode","_emscripten_wallet_secret_from_seed","_free","password","mnemonicToSeedV2","rootSecret","seedToKeypairV2","xprv","publicKey","toPublic","concat","privateKey","privateKeyArrPtr","privateKeyArr","publicKeyArrPtr","publicKeyArr","_emscripten_to_public","derivePrivate","parentKey","index","parentKeyArrPtr","parentKeyArr","childKeyArrPtr","childKeyArr","_emscripten_derive_private","derivePublic","parentExtPubKey","parentPubKey","parentChainCode","parentPubKeyArrPtr","parentPubKeyArr","parentChainCodeArrPtr","parentChainCodeArr","childPubKeyArrPtr","childPubKeyArr","childChainCodeArrPtr","childChainCodeArr","resultCode","_emscripten_derive_public","input","len","length","cborPrefix","module","exports","_mnemonicToSeedV1","_seedToKeypairV1","_seedToKeypairV2","_mnemonicToSeedV2"],"mappings":"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","sourcesContent":["const bip39 = require('bip39')\n\nconst {validateBuffer, validateDerivationIndex, validateDerivationScheme, validateMnemonic} = require(\"../utils/validation\")\nconst crypto = require(\"./crypto-primitives\")\nconst pbkdf2 = require('../utils/pbkdf2')\nconst Module = require('../lib.js')\n\nasync function mnemonicToRootKeypair(mnemonic, derivationScheme) {\n  validateDerivationScheme(derivationScheme)\n\n  if (derivationScheme === 1) {\n    return mnemonicToRootKeypairV1(mnemonic)\n  } else if (derivationScheme === 2) {\n    return mnemonicToRootKeypairV2(mnemonic, '')\n  } else {\n    throw Error(`Derivation scheme ${derivationScheme} not implemented`)\n  }\n}\n\nfunction mnemonicToRootKeypairV1(mnemonic) {\n  const seed = mnemonicToSeedV1(mnemonic)\n  return seedToKeypairV1(seed)\n}\n\nfunction mnemonicToSeedV1(mnemonic) {\n  validateMnemonic(mnemonic)\n  const entropy = Buffer.from(bip39.mnemonicToEntropy(mnemonic), 'hex')\n\n  return cborEncodeBuffer(crypto.blake2b(cborEncodeBuffer(entropy), 32))\n}\n\nfunction seedToKeypairV1(seed) {\n  let result\n  for (let i = 1; result === undefined && i <= 1000; i++) {\n    try {\n      const digest = crypto.hmac_sha512(seed, [Buffer.from(`Root Seed Chain ${i}`, 'ascii')])\n      const tempSeed = digest.slice(0, 32)\n      const chainCode = digest.slice(32, 64)\n\n      result = trySeedChainCodeToKeypairV1(tempSeed, chainCode)\n\n    } catch (e) {\n      if (e.name === 'InvalidKeypair') {\n        continue\n      }\n\n      throw e\n    }\n  }\n\n  if (result === undefined) {\n    const e = new Error('Secret key generation from mnemonic is looping forever')\n    e.name = 'RuntimeException'\n    throw e\n  }\n\n  return result\n}\n\nfunction trySeedChainCodeToKeypairV1(seed, chainCode) {\n  validateBuffer(seed, 32)\n  validateBuffer(chainCode, 32)\n\n  const seedArrPtr = Module._malloc(32)\n  const seedArr = new Uint8Array(Module.HEAPU8.buffer, seedArrPtr, 32)\n  const chainCodeArrPtr = Module._malloc(32)\n  const chainCodeArr = new Uint8Array(Module.HEAPU8.buffer, chainCodeArrPtr, 32)\n  const keypairArrPtr = Module._malloc(128)\n  const keypairArr = new Uint8Array(Module.HEAPU8.buffer, keypairArrPtr, 128)\n\n  seedArr.set(seed)\n  chainCodeArr.set(chainCode)\n\n  const returnCode = Module._emscripten_wallet_secret_from_seed(seedArrPtr, chainCodeArrPtr, keypairArrPtr)\n\n  Module._free(seedArrPtr)\n  Module._free(chainCodeArrPtr)\n  Module._free(keypairArrPtr)\n\n  if (returnCode === 1) {\n    const e = new Error('Invalid keypair')\n    e.name = 'InvalidKeypair'\n\n    throw e\n  }\n\n  return Buffer.from(keypairArr)\n}\n\nasync function mnemonicToRootKeypairV2(mnemonic, password) {\n  const seed = mnemonicToSeedV2(mnemonic)\n  const rootSecret = await seedToKeypairV2(seed, password)\n\n  return seedToKeypairV2(seed, password)\n}\n\nfunction mnemonicToSeedV2(mnemonic) {\n  validateMnemonic(mnemonic)\n  return Buffer.from(bip39.mnemonicToEntropy(mnemonic), 'hex')\n}\n\nasync function seedToKeypairV2(seed, password) {\n  const xprv = await pbkdf2(password, seed, 4096, 96, 'sha512')\n\n  xprv[0] &= 248\n  xprv[31] &= 31\n  xprv[31] |= 64\n\n  const publicKey = toPublic(xprv.slice(0, 64))\n\n  return Buffer.concat([xprv.slice(0, 64), publicKey, xprv.slice(64,)])\n}\n\nfunction toPublic(privateKey) {\n  validateBuffer(privateKey, 64)\n\n  const privateKeyArrPtr = Module._malloc(64)\n  const privateKeyArr = new Uint8Array(Module.HEAPU8.buffer, privateKeyArrPtr, 64)\n  const publicKeyArrPtr = Module._malloc(32)\n  const publicKeyArr = new Uint8Array(Module.HEAPU8.buffer, publicKeyArrPtr, 32)\n\n  privateKeyArr.set(privateKey)\n\n  Module._emscripten_to_public(privateKeyArrPtr, publicKeyArrPtr)\n\n  Module._free(privateKeyArrPtr)\n  Module._free(publicKeyArrPtr)\n\n  return Buffer.from(publicKeyArr)\n}\n\nfunction derivePrivate(parentKey, index, derivationScheme) {\n  validateBuffer(parentKey, 128)\n  validateDerivationIndex(index)\n  validateDerivationScheme(derivationScheme)\n\n  const parentKeyArrPtr = Module._malloc(128)\n  const parentKeyArr = new Uint8Array(Module.HEAPU8.buffer, parentKeyArrPtr, 128)\n  const childKeyArrPtr = Module._malloc(128)\n  const childKeyArr = new Uint8Array(Module.HEAPU8.buffer, childKeyArrPtr, 128)\n\n  parentKeyArr.set(parentKey)\n\n  Module._emscripten_derive_private(parentKeyArrPtr, index, childKeyArrPtr, derivationScheme)\n  Module._free(parentKeyArrPtr)\n  Module._free(childKeyArrPtr)\n\n  return Buffer.from(childKeyArr)\n}\n\nfunction derivePublic(parentExtPubKey, index, derivationScheme) {\n  validateBuffer(parentExtPubKey, 64)\n  validateDerivationIndex(index)\n  validateDerivationScheme(derivationScheme)\n\n  const parentPubKey = parentExtPubKey.slice(0, 32)\n  const parentChainCode = parentExtPubKey.slice(32, 64)\n\n  const parentPubKeyArrPtr = Module._malloc(32)\n  const parentPubKeyArr = new Uint8Array(Module.HEAPU8.buffer, parentPubKeyArrPtr, 32)\n  const parentChainCodeArrPtr = Module._malloc(32)\n  const parentChainCodeArr = new Uint8Array(Module.HEAPU8.buffer, parentChainCodeArrPtr, 32)\n\n  const childPubKeyArrPtr = Module._malloc(32)\n  const childPubKeyArr = new Uint8Array(Module.HEAPU8.buffer, childPubKeyArrPtr, 32)\n  const childChainCodeArrPtr = Module._malloc(32)\n  const childChainCodeArr = new Uint8Array(Module.HEAPU8.buffer, childChainCodeArrPtr, 32)\n\n  parentPubKeyArr.set(parentPubKey)\n  parentChainCodeArr.set(parentChainCode)\n\n  const resultCode = Module._emscripten_derive_public(parentPubKeyArrPtr, parentChainCodeArrPtr, index, childPubKeyArrPtr, childChainCodeArrPtr, derivationScheme)\n\n  Module._free(parentPubKeyArrPtr)\n  Module._free(parentChainCodeArrPtr)\n  Module._free(parentPubKeyArrPtr)\n  Module._free(parentChainCodeArrPtr)\n\n  if (resultCode !== 0) {\n    throw Error(`derivePublic has exited with code ${resultCode}`)\n  }\n\n  return Buffer.concat([Buffer.from(childPubKeyArr), Buffer.from(childChainCodeArr)])\n}\n\nfunction cborEncodeBuffer(input) {\n  validateBuffer(input)\n\n  const len = input.length\n  let cborPrefix = []\n\n  if (len < 24) {\n    cborPrefix = [0x40 + len]\n  } else if (len < 256) {\n    cborPrefix = [0x58, len]\n  } else {\n    throw Error('CBOR encode for more than 256 bytes not yet implemented')\n  }\n\n  return Buffer.concat([Buffer.from(cborPrefix), input])\n}\n\nmodule.exports = {\n  mnemonicToRootKeypair,\n  derivePublic,\n  derivePrivate,\n  toPublic,\n  _mnemonicToSeedV1: mnemonicToSeedV1,\n  _seedToKeypairV1: seedToKeypairV1,\n  _seedToKeypairV2: seedToKeypairV2,\n  _mnemonicToSeedV2: mnemonicToSeedV2,\n}"]},"metadata":{},"sourceType":"script"}