"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendAlgoBurnFTSignedTransaction = exports.prepareAlgoBurnFTSignedTransaction = exports.sendAlgoTransferFTSignedTransaction = exports.prepareAlgoTransferFTSignedTransaction = exports.sendAlgoCreateFTSignedTransaction = exports.prepareAlgoCreateFTSignedTransaction = exports.sendAlgoBurnFractionalNFTSignedTransaction = exports.prepareAlgoBurnFractionalNFTSignedTransaction = exports.sendAlgoTransferFractionalNFTSignedTransaction = exports.prepareAlgoTransferFractionalNFTSignedTransaction = exports.sendAlgoCreateFractionalNFTSignedTransaction = exports.prepareAlgoCreateFractionalNFTSignedTransaction = exports.sendAlgoBurnNFTSignedTransaction = exports.prepareAlgoBurnNFTSignedTransaction = exports.sendAlgoTransferNFTSignedTransaction = exports.prepareAlgoTransferNFTSignedTransaction = exports.sendAlgoCreateNFTSignedTransaction = exports.prepareAlgoCreateNFTSignedTransaction = exports.signAlgoKMSTransaction = exports.sendAlgoSignedTransaction = exports.prepareAlgoSignedTransaction = exports.getAlgoIndexerClient = exports.getAlgoClient = void 0;
const algosdk = require('algosdk');
const base32 = require('base32.js');
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const util_1 = require("util");
const blockchain_1 = require("../blockchain");
const model_1 = require("../model");
const wallet_1 = require("../wallet");
const Url = require('url-parse');
/**
 * Algod V2 Client
 * @param testnet if the algorand node is testnet or not
 * @param provider url of the algorand server endpoint
 * @returns algorand Client
 */
const getAlgoClient = (testnet, provider) => {
    if (provider) {
        return new algosdk.Algodv2(`${(testnet ? process.env.TATUM_ALGORAND_TESTNET_TOKEN : process.env.TATUM_ALGORAND_MAINNET_TOKEN) || 'DUMMYTOKEN'}`, provider, Url(provider).port);
    }
    else {
        return new algosdk.Algodv2({ 'X-API-Key': testnet ? `${process.env.TATUM_ALGORAND_TESTNET_THIRD_API_KEY}` : `${process.env.TATUM_ALGORAND_MAINNET_THIRD_API_KEY}` }, testnet ? `${process.env.TATUM_ALGORAND_TESTNET_THIRD_API_ALGOD_URL}` : `${process.env.TATUM_ALGORAND_MAINNET_THIRD_API_ALGOD_URL}`, '');
    }
};
exports.getAlgoClient = getAlgoClient;
/**
 * Algo Indexer Client
 * @param testnet if the algorand node is testnet or not
 * @param provider url of the algorand server endpoint
 * @returns algorand Indexer Client
 */
const getAlgoIndexerClient = (testnet, provider) => {
    if (provider) {
        return new algosdk.Indexer(`${(testnet ? process.env.TATUM_ALGORAND_TESTNET_TOKEN : process.env.TATUM_ALGORAND_MAINNET_TOKEN) || 'DUMMYTOKEN'}`, provider, Url(provider).port);
    }
    else {
        return new algosdk.Indexer({ 'X-API-Key': testnet ? `${process.env.TATUM_ALGORAND_TESTNET_THIRD_API_KEY}` : `${process.env.TATUM_ALGORAND_MAINNET_THIRD_API_KEY}` }, testnet ? `${process.env.TATUM_ALGORAND_TESTNET_THIRD_API_INDEXER_URL}` : `${process.env.TATUM_ALGORAND_MAINNET_THIRD_API_INDEXER_URL}`, '');
    }
};
exports.getAlgoIndexerClient = getAlgoIndexerClient;
/**
 * Algorand transaction signing
 * @param testnet if the algorand node is testnet or not
 * @param tx content of the transaction to broadcast
 * @param provider url of the algorand server endpoint for purestake.io restapi
 * @returns transaction data to be broadcast to blockchain
 */
const prepareAlgoSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const enc = new util_1.TextEncoder();
    const note = enc.encode(tx.note ? tx.note : '');
    const txn = algosdk.makePaymentTxnWithSuggestedParams(tx.from, tx.to, new bignumber_js_1.default(tx.amount).multipliedBy(1000000).toNumber(), undefined, note, Object.assign(Object.assign({}, params), { fee: new bignumber_js_1.default(tx.fee).multipliedBy(1000000).toNumber(), flatFee: true }));
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return txn.signTxn(secretKey);
};
exports.prepareAlgoSignedTransaction = prepareAlgoSignedTransaction;
/**
 * Send Algorand transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * This operation is irreversible.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain
 */
const sendAlgoSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoSignedTransaction = sendAlgoSignedTransaction;
/**
 * Sign Algorand pending transaction from Tatum KMS
 * @param tx pendding transaction from Tatum KMS
 * @param fromPrivateKey private key to sign transaction with
 * @param testnet mainnet or testnet version
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const signAlgoKMSTransaction = async (tx, fromPrivateKey, testnet, provider) => {
    if (tx.chain !== model_1.Currency.ALGO) {
        throw Error('Unsupported chain.');
    }
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = JSON.parse(tx.serializedTransaction);
    txn.from = algosdk.encodeAddress(new Uint8Array(Object.values(txn.from.publicKey)));
    txn.to = algosdk.encodeAddress(new Uint8Array(Object.values(txn.to.publicKey)));
    txn.note = new Uint8Array(Object.values(txn.note || ''));
    txn.lease = undefined;
    if (txn.tag) {
        if (txn.tag.data) {
            txn.tag = Buffer.from(txn.tag.data);
        }
    }
    txn.genesisHash = Buffer.from(txn.genesisHash.data);
    if (txn.assetManager) {
        txn.assetManager = algosdk.encodeAddress(new Uint8Array(Object.values(txn.assetManager.publicKey)));
    }
    if (txn.assetReserve) {
        txn.assetReserve = undefined;
    }
    if (txn.assetFreeze) {
        txn.assetFreeze = undefined;
    }
    if (txn.assetClawback) {
        txn.assetClawback = undefined;
    }
    if (txn.assetRevocationTarget) {
        txn.assetRevocationTarget = undefined;
    }
    if (txn.reKeyTo) {
        txn.reKeyTo = undefined;
    }
    if (txn.assetMetadataHash) {
        txn.assetMetadataHash = new Uint8Array(Object.values(txn.assetMetadataHash));
    }
    const _txn = new (algosdk.Transaction)(txn);
    const secretKey = new Uint8Array(decoder.write(fromPrivateKey).buf);
    return _txn.signTxn(secretKey);
};
exports.signAlgoKMSTransaction = signAlgoKMSTransaction;
/**
 * Sign Algorand create NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain
 */
const prepareAlgoCreateNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetCreateTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, 1, 0, false, tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, undefined, undefined, tx.symbol, tx.name, tx.url, undefined, params);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return txn.signTxn(secretKey);
};
exports.prepareAlgoCreateNFTSignedTransaction = prepareAlgoCreateNFTSignedTransaction;
/**
 * Send Algorand create NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain
 */
const sendAlgoCreateNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoCreateNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoCreateNFTSignedTransaction = sendAlgoCreateNFTSignedTransaction;
/**
 * Sign Algorand transfer NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoTransferNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetTransferTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, tx.to, undefined, undefined, new bignumber_js_1.default(tx.value).toNumber(), undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params, undefined);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return txn.signTxn(secretKey);
};
exports.prepareAlgoTransferNFTSignedTransaction = prepareAlgoTransferNFTSignedTransaction;
/**
 * Send Algorand Transfer NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoTransferNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoTransferNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoTransferNFTSignedTransaction = sendAlgoTransferNFTSignedTransaction;
/**
 * Sign Algorand burn NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoBurnNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetDestroyTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params, undefined);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return txn.signTxn(secretKey);
};
exports.prepareAlgoBurnNFTSignedTransaction = prepareAlgoBurnNFTSignedTransaction;
/**
 * Send Algorand burn NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoBurnNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoBurnNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoBurnNFTSignedTransaction = sendAlgoBurnNFTSignedTransaction;
/**
 * Sign Algorand create Fractional NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoCreateFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const v = Math.floor(Math.log10(new bignumber_js_1.default(tx.amount).toNumber()));
    const txn = algosdk.makeAssetCreateTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, new bignumber_js_1.default(10).pow(v).toNumber(), v, false, tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, undefined, undefined, tx.tokenId, tx.contractAddress, tx.url, undefined, params);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return txn.signTxn(secretKey);
};
exports.prepareAlgoCreateFractionalNFTSignedTransaction = prepareAlgoCreateFractionalNFTSignedTransaction;
/**
 * Send Algorand create Fractinoal NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoCreateFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoCreateFractionalNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoCreateFractionalNFTSignedTransaction = sendAlgoCreateFractionalNFTSignedTransaction;
/**
 * Sign Algorand transfer Fractional NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoTransferFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetTransferTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, tx.to, undefined, undefined, new bignumber_js_1.default(tx.amount).toNumber(), undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params, undefined);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return txn.signTxn(secretKey);
};
exports.prepareAlgoTransferFractionalNFTSignedTransaction = prepareAlgoTransferFractionalNFTSignedTransaction;
/**
 * Send Algorand transfer Fractinoal NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoTransferFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoTransferFractionalNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoTransferFractionalNFTSignedTransaction = sendAlgoTransferFractionalNFTSignedTransaction;
/**
 * Sign Algorand burn Fracational NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connecto to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoBurnFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetDestroyTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params, undefined);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return txn.signTxn(secretKey);
};
exports.prepareAlgoBurnFractionalNFTSignedTransaction = prepareAlgoBurnFractionalNFTSignedTransaction;
/**
 * Send Algorand burn Fractional NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoBurnFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoBurnFractionalNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoBurnFractionalNFTSignedTransaction = sendAlgoBurnFractionalNFTSignedTransaction;
/**
 * Sign Algorand create FT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connnect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoCreateFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetCreateTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, new bignumber_js_1.default(tx.supply).shiftedBy(new bignumber_js_1.default(tx.digits).toNumber()).toNumber(), new bignumber_js_1.default(tx.digits).toNumber(), false, tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, undefined, undefined, tx.symbol, tx.name, tx.url, undefined, params);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return txn.signTxn(secretKey);
};
exports.prepareAlgoCreateFTSignedTransaction = prepareAlgoCreateFTSignedTransaction;
/**
 * Send Algorand create FT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoCreateFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoCreateFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoCreateFTSignedTransaction = sendAlgoCreateFTSignedTransaction;
/**
 * Sign Algorand transfer FT transaction with private kwy locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoTransferFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetTransferTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, tx.to, undefined, undefined, new bignumber_js_1.default(tx.amount).shiftedBy(tx.digits || 1).toNumber(), undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params, undefined);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return txn.signTxn(secretKey);
};
exports.prepareAlgoTransferFTSignedTransaction = prepareAlgoTransferFTSignedTransaction;
/**
 * Send Algorand transfer FT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoTransferFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoTransferFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoTransferFTSignedTransaction = sendAlgoTransferFTSignedTransaction;
/**
 * Sign ALgorand burn FT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoBurnFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetDestroyTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params, undefined);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return txn.signTxn(secretKey);
};
exports.prepareAlgoBurnFTSignedTransaction = prepareAlgoBurnFTSignedTransaction;
/**
 * Sned Algorand burn FT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoBurnFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoBurnFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoBurnFTSignedTransaction = sendAlgoBurnFTSignedTransaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxnby5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90cmFuc2FjdGlvbi9hbGdvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNuQyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDcEMsZ0VBQXFDO0FBQ3JDLCtCQUFtQztBQUNuQyw4Q0FBa0Q7QUFDbEQsb0NBYWtCO0FBQ2xCLHNDQUErRDtBQUMvRCxNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDakM7Ozs7O0dBS0c7QUFDSSxNQUFNLGFBQWEsR0FBRyxDQUFDLE9BQWdCLEVBQUUsUUFBaUIsRUFBRSxFQUFFO0lBQ2pFLElBQUksUUFBUSxFQUFFO1FBQ1YsT0FBTyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLFlBQVksRUFBRSxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDbEw7U0FBTTtRQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLG9DQUFvQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQ0FBb0MsRUFBRSxFQUFFLEVBQy9KLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLDBDQUEwQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyww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